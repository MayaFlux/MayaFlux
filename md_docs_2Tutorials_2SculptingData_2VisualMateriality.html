<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MayaFlux: &lt;strong&gt;Visual Materiality: Part I&lt;/strong&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MayaFlux<span id="projectnumber">&#160;0.2.0</span>
   </div>
   <div id="projectbrief">Digital-First Multimedia Processing Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2Tutorials_2SculptingData_2VisualMateriality.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">&lt;strong&gt;Visual Materiality: Part I&lt;/strong&gt;</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md516"></a> <em>In <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>, geometry isn't shapes you draw. It's data you generate. <br  />
 Points, vertices, colors: all numerical streams you sculpt and send to the GPU. <br  />
 This tutorial shows you the smallest visual gesture: a single point.</em></p>
<hr  />
<h1><a class="anchor" id="autotoc_md518"></a>
&lt;strong&gt;Tutorial: Points in Space&lt;/strong&gt;</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> window = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Visual&quot;</span>, 800, 600 });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> point = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa77b4d4e117927c699f0ae4022d131a.html#aaa77b4d4e117927c699f0ae4022d131a">PointNode</a>(glm::vec3(0.0f, 0.5f, 0.0f)) | Graphics;</div>
<div class="line">    <span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(point) | Graphics;</div>
<div class="line"> </div>
<div class="line">    buffer-&gt;setup_rendering({ .target_window = window });</div>
<div class="line">    window-&gt;show();</div>
<div class="line">}</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1_html_aa7e28aa8d9ac8e457ca89e2d82a98dc1"><div class="ttname"><a href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">MayaFlux::Creator::GeometryBuffer</a></div><div class="ttdeci">auto GeometryBuffer(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Buffers::GeometryBuffer &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00210">Creator.hpp:210</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_aaa77b4d4e117927c699f0ae4022d131a_html_aaa77b4d4e117927c699f0ae4022d131a"><div class="ttname"><a href="classMayaFlux_1_1Creator_aaa77b4d4e117927c699f0ae4022d131a.html#aaa77b4d4e117927c699f0ae4022d131a">MayaFlux::Creator::PointNode</a></div><div class="ttdeci">auto PointNode(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::GpuSync::PointNode &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a76496539df28697c745cc22b37edcade_html_a76496539df28697c745cc22b37edcade"><div class="ttname"><a href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a></div><div class="ttdeci">std::shared_ptr&lt; Core::Window &gt; create_window(const Core::WindowCreateInfo &amp;create_info)</div><div class="ttdoc">Create a new window with specified parameters.</div><div class="ttdef"><b>Definition</b> <a href="Windowing_8cpp_source.html#l00018">Windowing.cpp:18</a></div></div>
</div><!-- fragment --><p>Run this. You see a white point in the upper half of the window.</p>
<p>Change <code>0.5f</code> to <code>-0.5f</code>. The point moves to the lower half. Try <code>0.0f, 0.0f, 0.0f</code>. It centers.</p>
<p><b>That's it.</b> A point rendered from explicit coordinates. No primitives. Just three numbers.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md520"></a>
Expansion 1: What Is PointNode?</h2>
<details >
<summary >
Click to expand: Points Are Vertex Data</summary>
<p></p>
<p><code>PointNode</code> is a <b>GeometryWriterNode</b>, a node that generates vertex data each frame.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PointVertex {</div>
<div class="line">    glm::vec3 position;  <span class="comment">// x, y, z coordinates</span></div>
<div class="line">    glm::vec3 color;     <span class="comment">// r, g, b values</span></div>
<div class="line">    <span class="keywordtype">float</span> size;          <span class="comment">// point size in pixels</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>When you create <code>vega.PointNode(glm::vec3(0.0f, 0.5f, 0.0f))</code>, you're setting:</p>
<ul>
<li><code>position = {0.0, 0.5, 0.0}</code> (center horizontally, upper half, at origin depth)</li>
<li><code>color = {1.0, 1.0, 1.0}</code> (white, default)</li>
<li><code>size = 10.0</code> (10 pixels, default)</li>
</ul>
<p>Every frame (at <code>GRAPHICS_BACKEND</code> - 60 FPS), <code>compute_frame()</code> writes these values into a CPU byte buffer. That buffer uploads to GPU as vertex data.</p>
<p><b>Coordinates are normalized device coordinates (NDC):</b></p>
<ul>
<li>X: -1.0 (left edge) → +1.0 (right edge)</li>
<li>Y: -1.0 (bottom) → +1.0 (top)</li>
<li>Z: -1.0 (near) → +1.0 (far)</li>
</ul>
<p>The <code>| Graphics</code> token registers the node with the graphics subsystem to run at visual rate. Without it, the node exists but never processes.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md522"></a>
Expansion 2: GeometryBuffer Connects Node → GPU</h2>
<details >
<summary >
Click to expand: The Upload Chain</summary>
<p></p>
<p><code>GeometryBuffer</code> does what <code>SoundContainerBuffer</code> does for audio: connects a data source to processing infrastructure.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(point) | Graphics;</div>
</div><!-- fragment --><p>This creates:</p>
<ol type="1">
<li><b>VKBuffer</b> on GPU (device-local vertex buffer storage)</li>
<li><b>GeometryBindingsProcessor</b> (default processor that handles CPU→GPU upload)</li>
<li><b>BufferProcessingChain</b> (where you can add transformations)</li>
</ol>
<p>The fluent <code>| Graphics</code> token calls <code>setup_processors(ProcessingToken::GRAPHICS_BACKEND)</code> behind the scenes, which:</p>
<ul>
<li>Creates the bindings processor</li>
<li>Sets it as the default processor</li>
<li>Binds the geometry node to this buffer</li>
<li>Registers buffer with graphics subsystem scheduler</li>
</ul>
<p><b>Each frame cycle:</b></p>
<ol type="1">
<li>Scheduler triggers buffer processing at <code>GRAPHICS_BACKEND</code></li>
<li>Default processor runs: <code>GeometryBindingsProcessor::processing_function()</code></li>
<li>Processor calls <code>point-&gt;compute_frame()</code> (generates vertex data)</li>
<li>Processor checks <code>point-&gt;needs_gpu_update()</code> (dirty flag)</li>
<li>If dirty: upload vertex bytes to GPU via staging buffer</li>
<li>Processing chain runs (currently empty, we'll add to it later)</li>
</ol>
<p>This is <b>identical to audio flow</b>, just different data:</p>
<ul>
<li>Audio: <code>SoundContainer → SoundContainerBuffer → FilterProcessor → Speakers</code></li>
<li>Graphics: <code>PointNode → GeometryBuffer → [empty chain] → (needs RenderProcessor)</code></li>
</ul>
<p><b>The separation:</b> Upload and rendering are separate processors. You can upload geometry without rendering it (for compute shader reads), or render the same geometry to multiple windows.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md524"></a>
Expansion 3: setup_rendering() Adds Draw Calls</h2>
<details >
<summary >
Click to expand: RenderProcessor and the Rendering Pipeline</summary>
<p></p>
<div class="fragment"><div class="line">buffer-&gt;setup_rendering({ .target_window = window });</div>
</div><!-- fragment --><p>This creates a <b>RenderProcessor</b> and adds it to the buffer's processing chain. Now the full flow is:</p>
<p><b>Default Processor (GeometryBindingsProcessor):</b></p>
<ul>
<li>Upload vertex data to GPU</li>
</ul>
<p><b>Processing Chain (RenderProcessor):</b></p>
<ul>
<li>Record Vulkan draw commands</li>
<li>Issue draw call</li>
<li>Present to window</li>
</ul>
<p><b>What RenderProcessor does each frame:</b></p>
<div class="fragment"><div class="line"><span class="comment">// Simplified RenderProcessor::execute_shader() flow:</span></div>
<div class="line"><span class="keywordtype">void</span> RenderProcessor::execute_shader(VKBuffer* buffer) {</div>
<div class="line">    <span class="keyword">auto</span> cmd_id = foundry.begin_secondary_commands(color_format);</div>
<div class="line">    <span class="keyword">auto</span> cmd = foundry.get_command_buffer(cmd_id);</div>
<div class="line"> </div>
<div class="line">    flow.begin_render_pass(cmd_id, m_target_window);</div>
<div class="line"> </div>
<div class="line">    flow.bind_pipeline(cmd_id, m_pipeline_id);</div>
<div class="line">    flow.bind_vertex_buffers(cmd_id, {buffer});</div>
<div class="line"> </div>
<div class="line">    flow.draw(cmd_id, vertex_count);  <span class="comment">// vertex_count = 1 for PointNode</span></div>
<div class="line"> </div>
<div class="line">    foundry.end_commands(cmd_id);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>RenderFlow</b> is the high-level rendering API (analogous to RtAudio for audio). It wraps Vulkan command recording but you never touch Vulkan directly unless you want to.</p>
<p><b>RenderConfig</b> lets you customize:</p>
<div class="fragment"><div class="line">Portal::Graphics::RenderConfig {</div>
<div class="line">    .target_window = window,</div>
<div class="line">    .vertex_shader = <span class="stringliteral">&quot;point.vert.spv&quot;</span>,     <span class="comment">// Default: point rendering</span></div>
<div class="line">    .fragment_shader = <span class="stringliteral">&quot;point.frag.spv&quot;</span>,   <span class="comment">// Default: flat color</span></div>
<div class="line">    .topology = PrimitiveTopology::POINT_LIST,  <span class="comment">// POINT_LIST | LINE_LIST | TRIANGLE_LIST</span></div>
<div class="line">    .polygon_mode = PolygonMode::FILL,</div>
<div class="line">    .cull_mode = CullMode::NONE</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Critical: No draw loop.</b> You never write:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (!window.should_close()) {</div>
<div class="line">    draw_something();</div>
<div class="line">    swap_buffers();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The graphics subsystem runs its own thread, ticks at 60 FPS, processes visual-rate nodes, processes graphics buffers, presents frames. <b>You declare what to render. The engine handles when and how.</b></p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md526"></a>
Expansion 4: Windowing and GLFW</h2>
<details >
<summary >
Click to expand: Window Management Without Manual Event Loops</summary>
<p></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> window = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Visual&quot;</span>, 800, 600 });</div>
</div><!-- fragment --><p>Creates a <b>GLFW window</b> (cross-platform windowing library) with:</p>
<ul>
<li>Title: "Visual"</li>
<li>Size: 800x600 pixels</li>
<li>Vulkan surface attached automatically</li>
<li>Event handling registered with <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>'s event system</li>
</ul>
<p><b>WindowManager</b> handles GLFW event polling in the graphics thread. You don't call <code>glfwPollEvents()</code> yourself. It's handled by the subsystem's <code>process()</code> cycle.</p>
<div class="fragment"><div class="line">window-&gt;show();</div>
</div><!-- fragment --><p>Makes the window visible. Windows are created hidden by default so you can set everything up before display.</p>
<p><b>Key architectural point:</b> Windows, like buffers, are resources managed by subsystems. You create them, register them for processing (via the <code>| Graphics</code> token on buffers), and the subsystem schedules their updates.</p>
<p>When you call <code>setup_rendering({ .target_window = window })</code>:</p>
<ol type="1">
<li>RenderProcessor stores window reference</li>
<li>Each frame, processor queries window's Vulkan swapchain</li>
<li>Records draw commands to swapchain framebuffer</li>
<li>Presents frame via DisplayService</li>
</ol>
<p><b>You never manually manage swapchains, framebuffers, or presentation.</b> That's RenderFlow's job.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md528"></a>
Expansion 5: The Fluent API and Separation of Concerns</h2>
<details >
<summary >
Click to expand: Processor Architecture vs. Monolithic Rendering</summary>
<p></p>
<p>Compare this to typical graphics framework code:</p>
<p><b>Typical OpenFrameworks/Processing:</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> draw() {</div>
<div class="line">    ofBackground(0);</div>
<div class="line">    ofSetColor(255);</div>
<div class="line">    ofDrawCircle(width/2, height/2, 10);  <span class="comment">// Immediate mode, mixed concerns</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>:</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> point = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa77b4d4e117927c699f0ae4022d131a.html#aaa77b4d4e117927c699f0ae4022d131a">PointNode</a>(glm::vec3(0.0, 0.0, 0.0)) | Graphics;</div>
<div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(point) | Graphics;</div>
<div class="line">buffer-&gt;setup_rendering({ .target_window = window });</div>
</div><!-- fragment --><p><b>Separation:</b></p>
<ul>
<li><b>PointNode</b>: Data generation (position, color, size)</li>
<li><b>GeometryBuffer</b>: GPU memory management and upload</li>
<li><b>GeometryBindingsProcessor</b>: CPU→GPU transfer logic</li>
<li><b>RenderProcessor</b>: Vulkan command recording and presentation</li>
</ul>
<p>Each processor has one job. You can:</p>
<ul>
<li>Replace GeometryBindingsProcessor with a compute shader that generates vertices on GPU</li>
<li>Add processors between upload and render (transform vertex data, apply shaders)</li>
<li>Render the same buffer to multiple windows with different shaders</li>
<li>Upload geometry without rendering (for other buffers to read)</li>
</ul>
<p><b>The fluent API hides complexity without removing access:</b></p>
<p>Fluent:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(point) | Graphics;</div>
</div><!-- fragment --><p>Explicit equivalent:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> buffer = std::make_shared&lt;GeometryBuffer&gt;(point);</div>
<div class="line">buffer-&gt;setup_processors(ProcessingToken::GRAPHICS_BACKEND);</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a7053b2753707ee4f8671524b071d0957.html#a7053b2753707ee4f8671524b071d0957">MayaFlux::register_buffer</a>(buffer);</div>
<div class="ttc" id="anamespaceMayaFlux_a7053b2753707ee4f8671524b071d0957_html_a7053b2753707ee4f8671524b071d0957"><div class="ttname"><a href="namespaceMayaFlux_a7053b2753707ee4f8671524b071d0957.html#a7053b2753707ee4f8671524b071d0957">MayaFlux::register_buffer</a></div><div class="ttdeci">void register_buffer(const std::shared_ptr&lt; Buffers::Buffer &gt; &amp;buffer, const CreationContext &amp;ctx)</div><div class="ttdef"><b>Definition</b> <a href="Creator_8cpp_source.html#l00071">Creator.cpp:71</a></div></div>
</div><!-- fragment --><p>The <code>vega</code> proxy and <code>| Graphics</code> operator do the setup for you. But you can always access the explicit API when you need control.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md530"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Change position (move to bottom-left)</span></div>
<div class="line"><span class="keyword">auto</span> point = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa77b4d4e117927c699f0ae4022d131a.html#aaa77b4d4e117927c699f0ae4022d131a">PointNode</a>(glm::vec3(-0.8f, -0.8f, 0.0f)) | Graphics;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Change color to red</span></div>
<div class="line"><span class="keyword">auto</span> point = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa77b4d4e117927c699f0ae4022d131a.html#aaa77b4d4e117927c699f0ae4022d131a">PointNode</a>(</div>
<div class="line">    glm::vec3(0.0f, 0.0f, 0.0f),</div>
<div class="line">    glm::vec3(1.0f, 0.0f, 0.0f),  <span class="comment">// RGB: red</span></div>
<div class="line">    10.0f                          <span class="comment">// size</span></div>
<div class="line">) | Graphics;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make it huge</span></div>
<div class="line"><span class="keyword">auto</span> point = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa77b4d4e117927c699f0ae4022d131a.html#aaa77b4d4e117927c699f0ae4022d131a">PointNode</a>() | Graphics;</div>
<div class="line">point-&gt;set_size(100.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Multiple points (each needs its own buffer for now)</span></div>
<div class="line"><span class="keyword">auto</span> p1 = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa77b4d4e117927c699f0ae4022d131a.html#aaa77b4d4e117927c699f0ae4022d131a">PointNode</a>(glm::vec3(-0.5f, 0.0f, 0.0f)) | Graphics;</div>
<div class="line"><span class="keyword">auto</span> p2 = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa77b4d4e117927c699f0ae4022d131a.html#aaa77b4d4e117927c699f0ae4022d131a">PointNode</a>(glm::vec3(0.5f, 0.0f, 0.0f)) | Graphics;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> b1 = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(p1) | Graphics;</div>
<div class="line"><span class="keyword">auto</span> b2 = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(p2) | Graphics;</div>
<div class="line"> </div>
<div class="line">b1-&gt;setup_rendering({ .target_window = window });</div>
<div class="line">b2-&gt;setup_rendering({ .target_window = window });</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md532"></a>
What You've Learned</h2>
<p>You now understand the complete graphics stack:</p>
<p><b>Nodes:</b> Generate vertex data at visual rate (60 FPS) <br  />
 <b>Buffers:</b> Manage GPU memory and processor chains <br  />
 <b>Default Processor (GeometryBindingsProcessor):</b> Upload CPU data to GPU <br  />
 <b>Processing Chain (RenderProcessor):</b> Record draw commands and present <br  />
 <b>Tokens:</b> <code>| Graphics</code> registers components with visual-rate scheduler <br  />
 <b>No draw loop:</b> Subsystem handles timing, you declare structure</p>
<p><b>Next:</b> Section 2 will show you <code>PointCollectionNode</code> for rendering many points efficiently, and Section 3 will drive point positions from audio nodes, finally crossing the audio/visual boundary.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md534"></a>
&lt;strong&gt;Tutorial: Collections and Aggregation&lt;/strong&gt;</h1>
<p><em>In the previous section, you rendered a single point with its own buffer. <br  />
 Now: render many points with one buffer, one upload, one draw call. <br  />
 This is how you work with data at scale: aggregation, not repetition.</em></p>
<hr  />
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> window = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Visual&quot;</span>, 800, 600 });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a spiral of points</span></div>
<div class="line">    <span class="keyword">auto</span> points = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a49d6164d64ce72ec73c335156ee42c6a.html#a49d6164d64ce72ec73c335156ee42c6a">PointCollectionNode</a>() | Graphics;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 200; i++) {</div>
<div class="line">        <span class="keywordtype">float</span> t = i * 0.1f;</div>
<div class="line">        <span class="keywordtype">float</span> radius = t * 0.05f;</div>
<div class="line">        <span class="keywordtype">float</span> x = radius * std::cos(t);</div>
<div class="line">        <span class="keywordtype">float</span> y = radius * std::sin(t);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Color transitions from red → green → blue</span></div>
<div class="line">        <span class="keywordtype">float</span> hue = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(i) / 200.0f;</div>
<div class="line">        glm::vec3 color(</div>
<div class="line">            std::sin(hue * 6.28f) * 0.5f + 0.5f,</div>
<div class="line">            std::sin(hue * 6.28f + 2.09f) * 0.5f + 0.5f,</div>
<div class="line">            std::sin(hue * 6.28f + 4.19f) * 0.5f + 0.5f</div>
<div class="line">        );</div>
<div class="line"> </div>
<div class="line">        points-&gt;add_point({ glm::vec3(x, y, 0.0f), color, 8.0f });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> buffer = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(points) | Graphics;</div>
<div class="line">    buffer-&gt;setup_rendering({ .target_window = window });</div>
<div class="line"> </div>
<div class="line">    window-&gt;show();</div>
<div class="line">}</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a49d6164d64ce72ec73c335156ee42c6a_html_a49d6164d64ce72ec73c335156ee42c6a"><div class="ttname"><a href="classMayaFlux_1_1Creator_a49d6164d64ce72ec73c335156ee42c6a.html#a49d6164d64ce72ec73c335156ee42c6a">MayaFlux::Creator::PointCollectionNode</a></div><div class="ttdeci">auto PointCollectionNode(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::GpuSync::PointCollectionNode &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a206db47ce24592b667c583d0047f745b_html_a206db47ce24592b667c583d0047f745b"><div class="ttname"><a href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">MayaFlux::vega</a></div><div class="ttdeci">Creator vega</div><div class="ttdoc">Global Creator instance for creating nodes, buffers, and containers.</div><div class="ttdef"><b>Definition</b> <a href="Creator_8cpp_source.html#l00018">Creator.cpp:18</a></div></div>
</div><!-- fragment --><p>Run this. You see a colorful spiral expanding from center to edges.</p>
<p>Change the formula. Try <code>float radius = std::sin(t) * 0.5f;</code> for a circular pattern. Try different color equations. The pattern is the same: generate point data procedurally, one buffer handles all of them.</p>
<p><b>That's the key difference:</b> One <code>GeometryBuffer</code>, 200 vertices. One upload cycle, one draw call.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md537"></a>
Expansion 1: What Is PointCollectionNode?</h2>
<details >
<summary >
Click to expand: Unstructured Aggregation</summary>
<p></p>
<p><code>PointCollectionNode</code> is a <b>GeometryWriterNode</b> that manages multiple <code>PointVertex</code> entries in a single vertex buffer.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PointCollectionNode : <span class="keyword">public</span> GeometryWriterNode {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;PointVertex&gt; m_points;  <span class="comment">// CPU-side point storage</span></div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Key methods:</b></p>
<div class="fragment"><div class="line">points-&gt;add_point(PointVertex{position, color, size});     <span class="comment">// Append</span></div>
<div class="line">points-&gt;set_points(std::vector&lt;PointVertex&gt;);              <span class="comment">// Replace all</span></div>
<div class="line">points-&gt;update_point(<span class="keywordtype">size_t</span> index, PointVertex);           <span class="comment">// Modify one</span></div>
<div class="line">points-&gt;clear_points();                                     <span class="comment">// Empty</span></div>
</div><!-- fragment --><p>Each modification sets <code>m_vertex_data_dirty = true</code>. Next frame, <code>compute_frame()</code> uploads the entire collection:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> PointCollectionNode::compute_frame() {</div>
<div class="line">    <span class="keywordflow">if</span> (m_points.empty()) {</div>
<div class="line">        resize_vertex_buffer(0);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Copy all points to flat vertex buffer</span></div>
<div class="line">    set_vertices&lt;PointVertex&gt;(std::span{m_points.data(), m_points.size()});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Update vertex layout metadata</span></div>
<div class="line">    <span class="keyword">auto</span> layout = get_vertex_layout();</div>
<div class="line">    layout-&gt;vertex_count = m_points.size();</div>
<div class="line">    set_vertex_layout(*layout);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Why "unstructured"?</b></p>
<p>Points have no relationships. They're just a list of positions. No topology, no connectivity, no physics.</p>
<p>For particle systems with relationships (springs, forces, neighborhoods), use <code>ParticleNetwork</code> instead (covered in a future tutorial).</p>
<p><b>When to use PointCollectionNode:</b></p>
<ul>
<li>Static data visualization (plot 10,000 data points)</li>
<li>Debug markers (show algorithm execution paths)</li>
<li>Procedural forms (generated geometry like this spiral)</li>
<li>Any collection where points don't interact</li>
</ul>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md539"></a>
Expansion 2: One Buffer, One Draw Call</h2>
<details >
<summary >
Click to expand: Batching and GPU Efficiency</summary>
<p></p>
<p>Compare two approaches:</p>
<p><b>Inefficient (Section 1 pattern repeated):</b></p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 200; i++) {</div>
<div class="line">    <span class="keyword">auto</span> point = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa77b4d4e117927c699f0ae4022d131a.html#aaa77b4d4e117927c699f0ae4022d131a">PointNode</a>(positions[i]) | Graphics;</div>
<div class="line">    <span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(point) | Graphics;</div>
<div class="line">    buffer-&gt;setup_rendering({.target_window = window});</div>
<div class="line">}</div>
</div><!-- fragment --><p>Result:</p>
<ul>
<li>200 buffers</li>
<li>200 upload operations per frame</li>
<li>200 draw calls</li>
<li>Massive CPU→GPU bandwidth waste</li>
</ul>
<p><b>Efficient (current section):</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> points = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a49d6164d64ce72ec73c335156ee42c6a.html#a49d6164d64ce72ec73c335156ee42c6a">PointCollectionNode</a>() | Graphics;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 200; i++) {</div>
<div class="line">    points-&gt;add_point({positions[i], colors[i], 8.0f});</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> buffer = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(points) | Graphics;</div>
<div class="line">buffer-&gt;setup_rendering({.target_window = window});</div>
</div><!-- fragment --><p>Result:</p>
<ul>
<li>1 buffer</li>
<li>1 upload operation per frame (only if dirty)</li>
<li>1 draw call: <code>flow.draw(cmd_id, 200)</code></li>
<li>Minimal overhead</li>
</ul>
<p><b>How GeometryBindingsProcessor batches:</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> GeometryBindingsProcessor::processing_function(Buffer* buffer) {</div>
<div class="line">    <span class="comment">// For EACH bound geometry node (but we only have one):</span></div>
<div class="line">    <span class="keyword">auto</span> vertices = binding.node-&gt;get_vertex_data();  <span class="comment">// All 200 points</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> upload_size = vertices.size_bytes();  <span class="comment">// 200 * sizeof(PointVertex)</span></div>
<div class="line"> </div>
<div class="line">    upload_to_gpu(</div>
<div class="line">        vertices.data(),</div>
<div class="line">        upload_size,</div>
<div class="line">        binding.gpu_vertex_buffer,</div>
<div class="line">        binding.staging_buffer  <span class="comment">// If GPU buffer is device-local</span></div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><p>It uploads the entire vertex array as a contiguous block. GPU reads it sequentially, renders all points in one dispatch.</p>
<p><b>This is fundamental to real-time graphics:</b> minimize state changes, batch identical operations, upload contiguous data.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md541"></a>
Expansion 3: RootGraphicsBuffer and Graphics Subsystem Architecture</h2>
<details >
<summary >
Click to expand: How Rendering Actually Happens</summary>
<p></p>
<p>You've been working with <code>GeometryBuffer</code>, a specialized buffer for vertex data. But there's a hidden orchestrator: <b>RootGraphicsBuffer</b>.</p>
<p><b>The Graphics Subsystem runs its own thread:</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> GraphicsSubsystem::graphics_thread_loop() {</div>
<div class="line">    <span class="keywordflow">while</span> (m_running.load()) {</div>
<div class="line">        m_frame_clock-&gt;tick();  <span class="comment">// Advance to next frame (60 FPS)</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// 1. Process visual-rate nodes (PointCollectionNode::compute_frame())</span></div>
<div class="line">        m_handle-&gt;nodes.process(1);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// 2. Process all graphics buffers</span></div>
<div class="line">        m_handle-&gt;buffers.process(1);  <span class="comment">// &lt;-- This processes RootGraphicsBuffer</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// 3. Window management</span></div>
<div class="line">        m_handle-&gt;windows.process();</div>
<div class="line"> </div>
<div class="line">        m_frame_clock-&gt;wait_for_next_frame();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Inside <code>m_handle-&gt;buffers.process(1)</code>, RootGraphicsBuffer executes:</b></p>
<div class="fragment"><div class="line"><span class="keyword">class </span>RootGraphicsBuffer : <span class="keyword">public</span> Buffer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;std::shared_ptr&lt;VKBuffer&gt;&gt; m_child_buffers;  <span class="comment">// Your GeometryBuffer is here</span></div>
<div class="line">    std::shared_ptr&lt;GraphicsBatchProcessor&gt; m_default_processor;</div>
<div class="line">    std::shared_ptr&lt;PresentProcessor&gt; m_final_processor;</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>The processing sequence:</b></p>
<ol type="1">
<li><b>GraphicsBatchProcessor</b> (default processor) runs first:<ul>
<li>Iterates through all child buffers (your GeometryBuffer)</li>
<li>Calls each buffer's default processor (GeometryBindingsProcessor - uploads vertices)</li>
<li>Calls each buffer's processing chain (RenderProcessor - records draw commands)</li>
<li>Collects buffers that have render commands ready</li>
</ul>
</li>
<li><b>PresentProcessor</b> (final processor) runs last:<ul>
<li>Receives the list of buffers ready to render</li>
<li>Groups buffers by target window</li>
<li>For each window: creates primary command buffer, executes secondary command buffers, presents frame</li>
</ul>
</li>
</ol>
<p><b>GraphicsBatchProcessor code (simplified):</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> GraphicsBatchProcessor::processing_function(Buffer* buffer) {</div>
<div class="line">    <span class="keyword">auto</span> root_buf = std::dynamic_pointer_cast&lt;RootGraphicsBuffer&gt;(buffer);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Process all child buffers</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; ch_buffer : root_buf-&gt;get_child_buffers()) {</div>
<div class="line">        <span class="comment">// Upload vertices (GeometryBindingsProcessor)</span></div>
<div class="line">        <span class="keywordflow">if</span> (ch_buffer-&gt;has_default_processor()) {</div>
<div class="line">            ch_buffer-&gt;process_default();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Run processing chain (RenderProcessor records commands)</span></div>
<div class="line">        <span class="keywordflow">if</span> (ch_buffer-&gt;has_processing_chain()) {</div>
<div class="line">            ch_buffer-&gt;get_processing_chain()-&gt;process(ch_buffer);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If buffer has render pipeline, mark it renderable</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">auto</span> vk_buffer = std::dynamic_pointer_cast&lt;VKBuffer&gt;(ch_buffer)) {</div>
<div class="line">            <span class="keywordflow">if</span> (vk_buffer-&gt;has_render_pipeline()) {</div>
<div class="line">                root_buf-&gt;add_renderable_buffer({</div>
<div class="line">                    .buffer = vk_buffer,</div>
<div class="line">                    .target_window = window,</div>
<div class="line">                    .pipeline_id = pipeline_id,</div>
<div class="line">                    .command_buffer_id = cmd_id</div>
<div class="line">                });</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>PresentProcessor fallback renderer (simplified):</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> PresentProcessor::fallback_renderer(RootGraphicsBuffer* root) {</div>
<div class="line">    <span class="comment">// Group buffers by window</span></div>
<div class="line">    std::unordered_map&lt;Window*, std::vector&lt;BufferInfo&gt;&gt; buffers_by_window;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; renderable : root-&gt;get_renderable_buffers()) {</div>
<div class="line">        buffers_by_window[renderable.target_window].push_back(renderable);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Render each window</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [window, buffer_infos] : buffers_by_window) {</div>
<div class="line">        <span class="comment">// Begin dynamic rendering</span></div>
<div class="line">        <span class="keyword">auto</span> primary_cmd = foundry.begin_commands(GRAPHICS);</div>
<div class="line">        flow.begin_rendering(primary_cmd, window, swapchain_image);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Execute all secondary command buffers for this window</span></div>
<div class="line">        std::vector&lt;vk::CommandBuffer&gt; secondaries;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info : buffer_infos) {</div>
<div class="line">            secondaries.push_back(info.command_buffer);</div>
<div class="line">        }</div>
<div class="line">        primary_cmd.executeCommands(secondaries);</div>
<div class="line"> </div>
<div class="line">        flow.end_rendering(primary_cmd, window);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Submit and present</span></div>
<div class="line">        display_service-&gt;submit_and_present(window, primary_cmd);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Why this architecture?</b></p>
<ul>
<li><b>Separation:</b> Upload (GeometryBindingsProcessor) and rendering (RenderProcessor) are distinct</li>
<li><b>Batching:</b> All uploads happen first, then all rendering</li>
<li><b>Multi-window:</b> Same geometry can render to multiple windows</li>
<li><b>No draw loop:</b> You never write <code>while (!should_close())</code> - the subsystem handles timing</li>
</ul>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md543"></a>
Expansion 4: Dynamic Rendering (Vulkan 1.3)</h2>
<details >
<summary >
Click to expand: No Render Passes, Just Begin/End Rendering</summary>
<p></p>
<p><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> uses <b>Vulkan 1.3 dynamic rendering</b>, which means no <code>VkRenderPass</code> objects.</p>
<p><b>Traditional Vulkan (pre-1.3):</b></p>
<ul>
<li>Create <code>VkRenderPass</code> ahead of time</li>
<li>Specify all attachments (color, depth) statically</li>
<li>Pipeline tied to render pass compatibility</li>
<li>Inflexible: changing attachments requires new pipelines</li>
</ul>
<p><b>Dynamic Rendering (Vulkan 1.3+):</b></p>
<ul>
<li>No <code>VkRenderPass</code> objects</li>
<li>Call <code>vkCmdBeginRendering()</code> with inline attachment info</li>
<li>Specify attachments per-frame dynamically</li>
<li>Flexible: same pipeline works with different attachments</li>
</ul>
<p><b>RenderFlow::begin_rendering() implementation:</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RenderFlow::begin_rendering(</div>
<div class="line">    CommandBufferID cmd_id,</div>
<div class="line">    Window* window,</div>
<div class="line">    vk::Image swapchain_image,</div>
<div class="line">    <span class="keyword">const</span> std::array&lt;float, 4&gt;&amp; clear_color)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> cmd = foundry.get_command_buffer(cmd_id);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Inline color attachment info</span></div>
<div class="line">    vk::RenderingAttachmentInfo color_attachment;</div>
<div class="line">    color_attachment.imageView = swapchain_image_view;</div>
<div class="line">    color_attachment.imageLayout = vk::ImageLayout::eColorAttachmentOptimal;</div>
<div class="line">    color_attachment.loadOp = vk::AttachmentLoadOp::eClear;</div>
<div class="line">    color_attachment.storeOp = vk::AttachmentStoreOp::eStore;</div>
<div class="line">    color_attachment.clearValue.color = vk::ClearColorValue(std::array{</div>
<div class="line">        clear_color[0], clear_color[1], clear_color[2], clear_color[3]</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Dynamic rendering info</span></div>
<div class="line">    vk::RenderingInfo rendering_info;</div>
<div class="line">    rendering_info.renderArea = {{0, 0}, {width, height}};</div>
<div class="line">    rendering_info.layerCount = 1;</div>
<div class="line">    rendering_info.colorAttachmentCount = 1;</div>
<div class="line">    rendering_info.pColorAttachments = &amp;color_attachment;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Begin rendering - no render pass object!</span></div>
<div class="line">    cmd.beginRendering(rendering_info);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Why this matters:</b></p>
<ul>
<li>Post-processing chains: Render to texture A, then B, then screen (no pipeline recreation)</li>
<li>Multi-pass rendering: Different attachments per pass without render pass combinatorial explosion</li>
<li>Flexibility: Attachments decided at runtime, not compile time</li>
</ul>
<p><b>From your perspective:</b> Invisible. <code>RenderProcessor</code> handles it. But it enables advanced techniques later without architectural changes.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md545"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Lissajous curve (parametric 2D oscillation)</span></div>
<div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> w1 = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;lissajous&quot;</span>, 800, 600 });</div>
<div class="line">    <span class="keyword">auto</span> w2 = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;waves&quot;</span>, 800, 600 });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> lissajous = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a49d6164d64ce72ec73c335156ee42c6a.html#a49d6164d64ce72ec73c335156ee42c6a">PointCollectionNode</a>() | Graphics;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 500; i++) {</div>
<div class="line">        <span class="keywordtype">float</span> t = i * 0.02f;</div>
<div class="line">        <span class="keywordtype">float</span> x = std::sin(3.0f * t) * 0.8f;</div>
<div class="line">        <span class="keywordtype">float</span> y = std::cos(5.0f * t) * 0.8f;</div>
<div class="line">        <span class="keywordtype">float</span> intensity = (std::sin(t * 2.0f) + 1.0f) * 0.5f;</div>
<div class="line"> </div>
<div class="line">        lissajous-&gt;add_point({ glm::vec3(x, y, 0.0f),</div>
<div class="line">            glm::vec3(intensity, 1.0f - intensity, 0.5f),</div>
<div class="line">            6.0f });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wave interference pattern</span></div>
<div class="line">    <span class="keyword">auto</span> waves = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a49d6164d64ce72ec73c335156ee42c6a.html#a49d6164d64ce72ec73c335156ee42c6a">PointCollectionNode</a>() | Graphics;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = -20; x &lt;= 20; x++) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = -20; y &lt;= 20; y++) {</div>
<div class="line">            <span class="keywordtype">float</span> nx = x / 20.0f;</div>
<div class="line">            <span class="keywordtype">float</span> ny = y / 20.0f;</div>
<div class="line">            <span class="keywordtype">float</span> dist = std::sqrt(nx * nx + ny * ny);</div>
<div class="line">            <span class="keywordtype">float</span> wave = std::sin(dist * 10.0f) * 0.5f + 0.5f;</div>
<div class="line"> </div>
<div class="line">            waves-&gt;add_point({ glm::vec3(nx * 0.9f, ny * 0.9f, 0.0f),</div>
<div class="line">                glm::vec3(wave, wave, 1.0f),</div>
<div class="line">                4.0f });</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> b1 = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(waves) | Graphics;</div>
<div class="line">    b1-&gt;setup_rendering({ .target_window = w1 });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> b2 = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(lissajous) | Graphics;</div>
<div class="line">    b2-&gt;setup_rendering({ .target_window = w2 });</div>
<div class="line"> </div>
<div class="line">    w1-&gt;show();</div>
<div class="line">    w2-&gt;show();</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md547"></a>
What You've Learned</h2>
<p><b>PointCollectionNode:</b> Aggregate many vertices in one node <br  />
 <b>Batching:</b> One buffer, one upload, one draw call - critical for performance <br  />
 <b>RootGraphicsBuffer:</b> Hidden orchestrator managing all graphics buffers <br  />
 <b>GraphicsBatchProcessor:</b> Default processor coordinating child buffer processing <br  />
 <b>PresentProcessor:</b> Final processor grouping buffers by window and presenting frames <br  />
 <b>Graphics Subsystem Thread:</b> Self-driven loop running at 60 FPS, no manual event loops <br  />
 <b>Dynamic Rendering:</b> Vulkan 1.3 approach with <code>vkCmdBeginRendering</code>, no render pass objects</p>
<p><b>Next:</b> Section 3 crosses domains. We'll drive point positions from audio nodesfor live audio analysis moving visual data. Finally: numbers are just numbers.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md549"></a>
&lt;strong&gt;Tutorial: Time and Updates&lt;/strong&gt;</h1>
<p><em>In the previous sections, geometry was static, created once in <code>compose()</code>. <br  />
 Now: geometry that evolves. Points that grow, move, disappear. <br  />
 This is where <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>'s architecture reveals its power: no draw loop, updates on your terms.</em></p>
<hr  />
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> window = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Growing Spiral&quot;</span>, 1920, 1080 });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> points = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a49d6164d64ce72ec73c335156ee42c6a.html#a49d6164d64ce72ec73c335156ee42c6a">PointCollectionNode</a>(256) | Graphics;</div>
<div class="line">    <span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(points) | Graphics;</div>
<div class="line">    buffer-&gt;setup_rendering({ .target_window = window });</div>
<div class="line"> </div>
<div class="line">    window-&gt;show();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Grow spiral over time: 10 new points per frame</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">float</span> angle = 0.0f;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">float</span> radius = 0.0f;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.016, [points]() {  <span class="comment">// ~60 Hz</span></div>
<div class="line">        angle += 0.02f;</div>
<div class="line">        radius += 0.001f;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Reset when spiral fills screen</span></div>
<div class="line">        <span class="keywordflow">if</span> (radius &gt; 2.0f) {</div>
<div class="line">            points-&gt;clear_points();</div>
<div class="line">            radius = 0.0f;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Add 10 new points this frame</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++i) {</div>
<div class="line">            <span class="keywordtype">float</span> local_angle = angle + (i / 10.0f) * 6.28f;</div>
<div class="line">            <span class="keywordtype">float</span> x = std::cos(local_angle) * radius;</div>
<div class="line">            <span class="keywordtype">float</span> y = std::sin(local_angle) * radius;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordtype">float</span> brightness = 1.0f - radius;</div>
<div class="line">            points-&gt;add_point({</div>
<div class="line">                glm::vec3(x, y, 0.0f),</div>
<div class="line">                glm::vec3(brightness, brightness * 0.8f, brightness * 0.5f),</div>
<div class="line">                10.0f + (i * 2.0f)</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceMayaFlux_a0b2f122006fb411804adab9baa87647d_html_a0b2f122006fb411804adab9baa87647d"><div class="ttname"><a href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a></div><div class="ttdeci">void schedule_metro(double interval_seconds, std::function&lt; void()&gt; callback, std::string name)</div><div class="ttdoc">Creates a metronome task and addes it to the default scheduler list for evaluation.</div><div class="ttdef"><b>Definition</b> <a href="Chronie_8cpp_source.html#l00041">Chronie.cpp:41</a></div></div>
</div><!-- fragment --><p>Run this. The spiral grows from center, fades as it expands, then resets and repeats.</p>
<p><b>That's the pattern:</b> Create geometry once. Schedule updates whenever you want. The graphics subsystem handles the rest.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md552"></a>
Expansion 1: No Draw Loop, &lt;tt&gt;compose()&lt;/tt&gt; Runs Once</h2>
<details >
<summary >
Click to expand: Why This Is Different</summary>
<p></p>
<p><b>Typical graphics framework (Processing, openFrameworks):</b></p>
<div class="fragment"><div class="line"><span class="comment">// Global state (forced pattern)</span></div>
<div class="line">std::vector&lt;Point&gt; points;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">    <span class="comment">// Initialize once</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> draw() {</div>
<div class="line">    background(0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// MUST redraw everything, every frame, forever</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; p : points) {</div>
<div class="line">        circle(p.x, p.y, 10);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Update state for next frame</span></div>
<div class="line">    updatePhysics();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Hidden main loop you don&#39;t control:</span></div>
<div class="line"><span class="keywordflow">while</span> (running) {</div>
<div class="line">    draw();      <span class="comment">// Called automatically at framerate</span></div>
<div class="line">    swap_buffers();</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Problems:</b></p>
<ol type="1">
<li><b>Forced void:</b> <code>draw()</code> is a mandatory callback you're trapped in</li>
<li><b>Global state:</b> Everything must be accessible from both <code>setup()</code> and <code>draw()</code></li>
<li><b>No separation:</b> Update and render are coupled in <code>draw()</code></li>
<li><b>No timing control:</b> Can't easily say "update every 2 frames" or "render at 120 FPS, update at 30 FPS"</li>
</ol>
<hr  />
<p><b><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>:</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="comment">// Setup happens once</span></div>
<div class="line">    <span class="keyword">auto</span> points = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a49d6164d64ce72ec73c335156ee42c6a.html#a49d6164d64ce72ec73c335156ee42c6a">PointCollectionNode</a>() | Graphics;</div>
<div class="line">    <span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(points) | Graphics;</div>
<div class="line">    buffer-&gt;setup_rendering({ .target_window = window });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Schedule updates independently</span></div>
<div class="line">    <a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.033, [points]() {  <span class="comment">// 30 Hz updates</span></div>
<div class="line">        points-&gt;add_point({<span class="comment">/* ... */</span>});</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Rendering happens at 60 FPS automatically in graphics thread</span></div>
<div class="line">    <span class="comment">// No coupling, no forced structure</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>**<code>compose()</code> is not a loop.** It runs once at startup. You declare structure, not repeated execution.</p>
<p><b>Updates are scheduled, not looped:</b> You schedule tasks that run at specific intervals using the task scheduler. These run independently from rendering.</p>
<p><b>Rendering is automatic:</b> The graphics subsystem thread runs at 60 FPS, processes visual-rate nodes, uploads geometry, issues draw calls, presents frames. You never write that loop.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md555"></a>
Expansion 2: Multiple Windows Without Offset Hacks</h2>
<details >
<summary >
Click to expand: Different Content, Different Windows</summary>
<p></p>
<p>Because each buffer targets a specific window through <code>setup_rendering()</code>, you don't need to offset or partition your geometry. Just create separate content for separate windows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> window1 = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Spiral&quot;</span>, 800, 600 });</div>
<div class="line">    <span class="keyword">auto</span> window2 = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Grid&quot;</span>, 800, 600 });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Spiral in window 1</span></div>
<div class="line">    <span class="keyword">auto</span> spiral = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a49d6164d64ce72ec73c335156ee42c6a.html#a49d6164d64ce72ec73c335156ee42c6a">PointCollectionNode</a>() | Graphics;</div>
<div class="line">    <span class="keyword">auto</span> spiral_buffer = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(spiral) | Graphics;</div>
<div class="line">    spiral_buffer-&gt;setup_rendering({ .target_window = window1 });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Grid in window 2</span></div>
<div class="line">    <span class="keyword">auto</span> grid = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a49d6164d64ce72ec73c335156ee42c6a.html#a49d6164d64ce72ec73c335156ee42c6a">PointCollectionNode</a>() | Graphics;</div>
<div class="line">    <span class="keyword">auto</span> grid_buffer = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(grid) | Graphics;</div>
<div class="line">    grid_buffer-&gt;setup_rendering({ .target_window = window2 });</div>
<div class="line"> </div>
<div class="line">    window1-&gt;show();</div>
<div class="line">    window2-&gt;show();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Update spiral</span></div>
<div class="line">    <a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.016, [spiral]() {</div>
<div class="line">        <span class="comment">/* add spiral points */</span></div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Update grid independently</span></div>
<div class="line">    <a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.033, [grid]() {</div>
<div class="line">        <span class="comment">/* add grid points */</span></div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>What PresentProcessor does:</b></p>
<div class="fragment"><div class="line"><span class="comment">// Groups buffers by target window</span></div>
<div class="line">std::unordered_map&lt;Window*, std::vector&lt;BufferInfo&gt;&gt; buffers_by_window;</div>
<div class="line">buffers_by_window[window1].push_back(spiral_buffer_info);</div>
<div class="line">buffers_by_window[window2].push_back(grid_buffer_info);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Each window gets its own rendering pass</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; [window, buffer_infos] : buffers_by_window) {</div>
<div class="line">    begin_dynamic_rendering(window);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; info : buffer_infos) {</div>
<div class="line">        execute_secondary_command_buffer(info.cmd_buffer);</div>
<div class="line">    }</div>
<div class="line">    end_dynamic_rendering(window);</div>
<div class="line">    present(window);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Key point:</b> You're not rendering to one framebuffer and offsetting content. Each window is a separate rendering target. No manual viewport management, no draw call coordination.</p>
<p>Traditional frameworks force you to either:</p>
<ul>
<li>Render everything to one window and manually partition</li>
<li>Manage multiple OpenGL contexts yourself</li>
<li>Fight the framework's assumptions</li>
</ul>
<p><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>: just create another window, point a buffer at it. Done.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md557"></a>
Expansion 3: Update Timing: Three Approaches</h2>
<details >
<summary >
Click to expand: Metro Tasks, Coroutines, and Node Ticks</summary>
<p></p>
<p><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> gives you three ways to schedule updates, each for different use cases:</p>
<p></p>
</details>
<h3><a class="anchor" id="autotoc_md558"></a>
Approach 1: &lt;tt&gt;schedule_metro&lt;/tt&gt; (Simplest)</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(interval_seconds, callback);</div>
</div><!-- fragment --><p>Schedules a callback to run at fixed intervals using the <b>TaskScheduler</b>:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.016, [points]() {  <span class="comment">// ~60 Hz</span></div>
<div class="line">    points-&gt;add_point({<span class="comment">/* ... */</span>});</div>
<div class="line">});</div>
</div><!-- fragment --><p><b>Under the hood:</b></p>
<div class="fragment"><div class="line"><span class="comment">// Creates a SoundRoutine coroutine</span></div>
<div class="line"><span class="keyword">auto</span> metro_routine = [](Vruta::TaskScheduler&amp; scheduler) -&gt; Vruta::SoundRoutine {</div>
<div class="line">    <span class="keyword">auto</span>&amp; promise = <span class="keyword">co_await</span> Kriya::GetAudioPromise{};</div>
<div class="line">    uint64_t interval_samples = scheduler.seconds_to_samples(interval_seconds);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (!promise.should_terminate) {</div>
<div class="line">        callback();  <span class="comment">// Your function</span></div>
<div class="line">        <span class="keyword">co_await</span> Kriya::SampleDelay{interval_samples};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">scheduler-&gt;add_task(std::make_shared&lt;Vruta::SoundRoutine&gt;(metro_routine(*scheduler)));</div>
</div><!-- fragment --><p><b>When to use:</b> Simple periodic updates. Most common case.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md560"></a>
Approach 2: Coroutines with &lt;tt&gt;Sequence&lt;/tt&gt; or &lt;tt&gt;EventChain&lt;/tt&gt;</h3>
<p><b>EventChain</b> for sequential timed events:</p>
<div class="fragment"><div class="line">Kriya::EventChain()</div>
<div class="line">    .then([]() { points-&gt;clear_points(); })</div>
<div class="line">    .then([]() {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 50; i++) {</div>
<div class="line">            points-&gt;add_point({<span class="comment">/* ... */</span>});</div>
<div class="line">        }</div>
<div class="line">    }, 0.5)  <span class="comment">// After 0.5 seconds</span></div>
<div class="line">    .then([]() { <span class="comment">/* do something else */</span> }, 1.0)  <span class="comment">// After another 1.0 seconds</span></div>
<div class="line">    .start();</div>
</div><!-- fragment --><p><b>Under the hood:</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> coroutine_func = [](Vruta::TaskScheduler&amp; scheduler, EventChain* chain) -&gt; Vruta::SoundRoutine {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event : chain-&gt;m_events) {</div>
<div class="line">        <span class="keyword">co_await</span> Kriya::SampleDelay{scheduler.seconds_to_samples(event.delay_seconds)};</div>
<div class="line">        <span class="keyword">event</span>.action();  <span class="comment">// Execute callback</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>When to use:</b> Multi-step animations with specific timing. State machines. Choreographed sequences.</p>
<p><b>Note:</b> <code>Sequence</code> is similar but less commonly used for graphics. See project knowledge for details.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md562"></a>
Approach 3: Node &lt;tt&gt;on_tick&lt;/tt&gt; Callbacks</h3>
<p>Every node can register callbacks that fire whenever it processes a sample:</p>
<div class="fragment"><div class="line">points-&gt;on_tick([points](<span class="keyword">const</span> Nodes::NodeContext&amp; ctx) {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> frame_count = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (++frame_count % 60 == 0) {  <span class="comment">// Every 60 calls</span></div>
<div class="line">        points-&gt;add_point({</div>
<div class="line">            glm::vec3(</div>
<div class="line">                <a class="code hl_function" href="namespaceMayaFlux_a8969856c48c84fe3db8145c202328672.html#a8969856c48c84fe3db8145c202328672">MayaFlux::get_uniform_random</a>(-1.0f, 1.0f),</div>
<div class="line">                <a class="code hl_function" href="namespaceMayaFlux_a8969856c48c84fe3db8145c202328672.html#a8969856c48c84fe3db8145c202328672">MayaFlux::get_uniform_random</a>(-1.0f, 1.0f),</div>
<div class="line">                0.0f</div>
<div class="line">            ),</div>
<div class="line">            glm::vec3(1.0f),</div>
<div class="line">            10.0f</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="ttc" id="anamespaceMayaFlux_a8969856c48c84fe3db8145c202328672_html_a8969856c48c84fe3db8145c202328672"><div class="ttname"><a href="namespaceMayaFlux_a8969856c48c84fe3db8145c202328672.html#a8969856c48c84fe3db8145c202328672">MayaFlux::get_uniform_random</a></div><div class="ttdeci">double get_uniform_random(double start, double end)</div><div class="ttdoc">Generates a uniform random number.</div><div class="ttdef"><b>Definition</b> <a href="API_2Random_8cpp_source.html#l00014">API/Random.cpp:14</a></div></div>
</div><!-- fragment --><p><b>When the callback fires:</b></p>
<div class="fragment"><div class="line"><span class="comment">// Inside PointCollectionNode::compute_frame() or process_sample():</span></div>
<div class="line"><span class="keywordtype">void</span> notify_tick(<span class="keywordtype">double</span> value)<span class="keyword"> override </span>{</div>
<div class="line">    update_context(value);</div>
<div class="line">    <span class="keyword">auto</span>&amp; ctx = get_last_context();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Unconditional callbacks</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; callback : m_callbacks) {</div>
<div class="line">        callback(ctx);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Conditional callbacks</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; [callback, condition] : m_conditional_callbacks) {</div>
<div class="line">        <span class="keywordflow">if</span> (condition(ctx)) {</div>
<div class="line">            callback(ctx);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>NodeContext contains:</b></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>NodeContext {</div>
<div class="line">    <span class="keywordtype">double</span> value;           <span class="comment">// Current output value</span></div>
<div class="line">    std::string type_id;    <span class="comment">// Node type identifier</span></div>
<div class="line">    <span class="comment">// Derived classes add more info (e.g., FilterContext adds history buffers)</span></div>
<div class="line">};</div>
</div><!-- fragment --><p><b>When to use:</b> Tight coupling with node processing. Sample-accurate reactions. Rare for graphics (more common for audio analysis driving visual changes).</p>
<hr  />
<p><b>Comparison:</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method   </th><th class="markdownTableHeadNone">Timing Precision   </th><th class="markdownTableHeadNone">Complexity   </th><th class="markdownTableHeadNone">Use Case    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>schedule_metro</code>   </td><td class="markdownTableBodyNone">Sample-accurate (~1ms @ 48kHz)   </td><td class="markdownTableBodyNone">Low   </td><td class="markdownTableBodyNone">Periodic updates    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>EventChain</code>   </td><td class="markdownTableBodyNone">Sample-accurate   </td><td class="markdownTableBodyNone">Medium   </td><td class="markdownTableBodyNone">Multi-step sequences    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>on_tick</code>   </td><td class="markdownTableBodyNone">Per-process call   </td><td class="markdownTableBodyNone">Low   </td><td class="markdownTableBodyNone">Node-coupled logic   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md565"></a>
Expansion 4: Clearing vs. Replacing vs. Updating</h2>
<details >
<summary >
Click to expand: Four Update Patterns</summary>
<p></p>
<p></p>
</details>
<h3><a class="anchor" id="autotoc_md566"></a>
Pattern 1: Additive Growth (Original Example)</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.016, [points]() {</div>
<div class="line">    points-&gt;add_point({<span class="comment">/* new point */</span>});  <span class="comment">// Grows indefinitely</span></div>
<div class="line">});</div>
</div><!-- fragment --><p>Points accumulate until cleared. Trail effects, particle emissions, growing forms.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md568"></a>
Pattern 2: Full Replacement</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.016, [points]() {</div>
<div class="line">    std::vector&lt;Nodes::PointVertex&gt; new_points;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Generate entirely new point set</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; i++) {</div>
<div class="line">        new_points.push_back({<span class="comment">/* compute position */</span>});</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    points-&gt;set_points(new_points);  <span class="comment">// Replace all</span></div>
<div class="line">});</div>
</div><!-- fragment --><p><b>Internally:</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> PointCollectionNode::set_points(<span class="keyword">const</span> std::vector&lt;PointVertex&gt;&amp; points) {</div>
<div class="line">    m_points.clear();</div>
<div class="line">    m_points = points;</div>
<div class="line">    m_vertex_data_dirty = <span class="keyword">true</span>;  <span class="comment">// Triggers upload next frame</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Entire buffer replaced. Simulations that recompute all positions (physics, flocking).</p>
<hr  />
<h3><a class="anchor" id="autotoc_md570"></a>
Pattern 3: Selective Updates</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.016, [points]() {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; points-&gt;get_point_count(); i++) {</div>
<div class="line">        <span class="keyword">auto</span> p = points-&gt;get_point(i);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Modify position</span></div>
<div class="line">        p.position.x += std::sin(i * 0.1f) * 0.01f;</div>
<div class="line">        p.position.y += std::cos(i * 0.1f) * 0.01f;</div>
<div class="line"> </div>
<div class="line">        points-&gt;update_point(i, p);  <span class="comment">// Updates single point</span></div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>Modifies existing points in place. Mesh deformations, vertex animations.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md572"></a>
Pattern 4: Conditional Clearing</h3>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">float</span> radius = 0.0f;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.016, [points]() {</div>
<div class="line">    radius += 0.01f;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (radius &gt; 1.5f) {</div>
<div class="line">        points-&gt;clear_points();  <span class="comment">// Reset</span></div>
<div class="line">        radius = 0.0f;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    points-&gt;add_point({<span class="comment">/* ... */</span>});</div>
<div class="line">});</div>
</div><!-- fragment --><p>Growth with periodic reset. Cyclical animations.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md574"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Pendulum with physics</span></div>
<div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> window = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Pendulum Trail&quot;</span>, 800, 800 });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> trail = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a49d6164d64ce72ec73c335156ee42c6a.html#a49d6164d64ce72ec73c335156ee42c6a">PointCollectionNode</a>() | Graphics;</div>
<div class="line">    <span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aa7e28aa8d9ac8e457ca89e2d82a98dc1.html#aa7e28aa8d9ac8e457ca89e2d82a98dc1">GeometryBuffer</a>(trail) | Graphics;</div>
<div class="line">    buffer-&gt;setup_rendering({ .target_window = window });</div>
<div class="line">    window-&gt;show();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">float</span> angle = 1.5f;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">float</span> velocity = 0.0f;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> length = 0.7f;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> gravity = 9.81f;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dt = 0.016f;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(dt, [trail]() {</div>
<div class="line">        <span class="comment">// Physics</span></div>
<div class="line">        <span class="keywordtype">float</span> acceleration = -(gravity / length) * std::sin(angle);</div>
<div class="line">        velocity += acceleration * dt;</div>
<div class="line">        angle += velocity * dt;</div>
<div class="line">        velocity *= 0.999f;  <span class="comment">// Damping</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Position</span></div>
<div class="line">        <span class="keywordtype">float</span> x = std::sin(angle) * length;</div>
<div class="line">        <span class="keywordtype">float</span> y = -std::cos(angle) * length;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Add to trail</span></div>
<div class="line">        <span class="keywordtype">float</span> hue = (angle + 3.14f) / 6.28f;</div>
<div class="line">        trail-&gt;add_point({</div>
<div class="line">            glm::vec3(x, y, 0.0f),</div>
<div class="line">            glm::vec3(</div>
<div class="line">                std::sin(hue * 6.28f) * 0.5f + 0.5f,</div>
<div class="line">                std::sin(hue * 6.28f + 2.09f) * 0.5f + 0.5f,</div>
<div class="line">                std::sin(hue * 6.28f + 4.19f) * 0.5f + 0.5f</div>
<div class="line">            ),</div>
<div class="line">            8.0f</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Keep last 500</span></div>
<div class="line">        <span class="keywordflow">if</span> (trail-&gt;get_point_count() &gt; 500) {</div>
<div class="line">            <span class="keyword">auto</span> points = trail-&gt;get_points();</div>
<div class="line">            points.erase(points.begin());</div>
<div class="line">            trail-&gt;set_points(points);</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md576"></a>
What You've Learned</h2>
<p>**<code>compose()</code> runs once:** Setup, not a loop <br  />
 **<code>schedule_metro</code>:** Periodic callbacks via task scheduler <br  />
 <b>EventChain:</b> Sequential timed events with coroutines <br  />
 **<code>on_tick</code>:** Node-coupled callbacks fired per-process <br  />
 <b>Update patterns:</b> Additive, replacement, selective, conditional <br  />
 <b>Multiple windows:</b> Separate content, separate targets, no offsets <br  />
 <b>Dirty flags:</b> Geometry uploads only when changed</p>
<p><b>Next:</b> Section 4 crosses domains. Audio nodes drive point positions, i.e live audio analysis controlling visual data. Numbers driving numbers, no artificial boundaries.</p>
<h1><a class="anchor" id="autotoc_md577"></a>
&lt;strong&gt;Tutorial: Audio → Geometry&lt;/strong&gt;</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> settings() {</div>
<div class="line">    <span class="keyword">auto</span>&amp; stream = <a class="code hl_function" href="namespaceMayaFlux_1_1Config_add02a960f8fdc0d03e7d4c0aa3c2b518.html#add02a960f8fdc0d03e7d4c0aa3c2b518">MayaFlux::Config::get_global_stream_info</a>();</div>
<div class="line">    stream.input.enabled = <span class="keyword">true</span>;</div>
<div class="line">    stream.input.channels = 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> window = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Reactive&quot;</span>, 1920, 1080 });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Audio source: modulated drone</span></div>
<div class="line">    <span class="keyword">auto</span> carrier = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(220.0) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> modulator = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(0.3) | Audio; <span class="comment">// Slow amplitude modulation</span></div>
<div class="line">    <span class="keyword">auto</span> envelope = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> (x + 1.0) * 0.5; }) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> modded = modulator &gt;&gt; envelope; <span class="comment">// Convert -1..1 to 0..1</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Play the modulated audio</span></div>
<div class="line">    <span class="keyword">auto</span> audio_out = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([modded](<span class="keywordtype">double</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x * modded-&gt;get_last_output();</div>
<div class="line">    }) | Audio;</div>
<div class="line">    carrier &gt;&gt; audio_out;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Particles</span></div>
<div class="line">    <span class="keyword">auto</span> particles = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a469d04ca6a873d72708b9f7e8f73f4b8.html#a469d04ca6a873d72708b9f7e8f73f4b8">ParticleNetwork</a>(</div>
<div class="line">                         500,</div>
<div class="line">                         glm::vec3(-1.5f, -1.0f, -0.5f),</div>
<div class="line">                         glm::vec3(1.5f, 1.0f, 0.5f),</div>
<div class="line">                         ParticleNetwork::InitializationMode::RANDOM_VOLUME)</div>
<div class="line">        | Graphics;</div>
<div class="line"> </div>
<div class="line">    particles-&gt;set_gravity(glm::vec3(0.0f, -2.0f, 0.0f));</div>
<div class="line">    particles-&gt;set_drag(0.02f);</div>
<div class="line">    particles-&gt;set_bounds_mode(ParticleNetwork::BoundsMode::BOUNCE);</div>
<div class="line">    particles-&gt;set_output_mode(NodeNetwork::OutputMode::GRAPHICS_BIND);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The crossing: envelope node controls gravity</span></div>
<div class="line">    particles-&gt;map_parameter(<span class="stringliteral">&quot;gravity&quot;</span>, envelope, NodeNetwork::MappingMode::BROADCAST);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> buffer = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa270d4ac9bb6b0cdf15d1cb3f330cd6.html#aaa270d4ac9bb6b0cdf15d1cb3f330cd6">NetworkGeometryBuffer</a>(particles) | Graphics;</div>
<div class="line">    buffer-&gt;setup_rendering({ .target_window = window });</div>
<div class="line"> </div>
<div class="line">    window-&gt;show();</div>
<div class="line">}</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7_html_a433b0c2da4871dc08e049d5ac64041b7"><div class="ttname"><a href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">MayaFlux::Creator::Polynomial</a></div><div class="ttdeci">auto Polynomial(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Polynomial &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a469d04ca6a873d72708b9f7e8f73f4b8_html_a469d04ca6a873d72708b9f7e8f73f4b8"><div class="ttname"><a href="classMayaFlux_1_1Creator_a469d04ca6a873d72708b9f7e8f73f4b8.html#a469d04ca6a873d72708b9f7e8f73f4b8">MayaFlux::Creator::ParticleNetwork</a></div><div class="ttdeci">auto ParticleNetwork(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Network::ParticleNetwork &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00200">Creator.hpp:200</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_aaa270d4ac9bb6b0cdf15d1cb3f330cd6_html_aaa270d4ac9bb6b0cdf15d1cb3f330cd6"><div class="ttname"><a href="classMayaFlux_1_1Creator_aaa270d4ac9bb6b0cdf15d1cb3f330cd6.html#aaa270d4ac9bb6b0cdf15d1cb3f330cd6">MayaFlux::Creator::NetworkGeometryBuffer</a></div><div class="ttdeci">auto NetworkGeometryBuffer(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Buffers::NetworkGeometryBuffer &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00210">Creator.hpp:210</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687_html_ae9b21dfc8a04dd2826b63cda4dae4687"><div class="ttname"><a href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">MayaFlux::Creator::Sine</a></div><div class="ttdeci">auto Sine(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Sine &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_1_1Config_add02a960f8fdc0d03e7d4c0aa3c2b518_html_add02a960f8fdc0d03e7d4c0aa3c2b518"><div class="ttname"><a href="namespaceMayaFlux_1_1Config_add02a960f8fdc0d03e7d4c0aa3c2b518.html#add02a960f8fdc0d03e7d4c0aa3c2b518">MayaFlux::Config::get_global_stream_info</a></div><div class="ttdeci">Core::GlobalStreamInfo &amp; get_global_stream_info()</div><div class="ttdoc">Gets the stream configuration from the default engine.</div><div class="ttdef"><b>Definition</b> <a href="Config_8cpp_source.html#l00019">Config.cpp:19</a></div></div>
</div><!-- fragment --><p>Run this. You hear a slowly pulsing drone. Particles fall heavily when the sound swells, float when it recedes. The same envelope shapes both audio amplitude and gravitational force.</p>
<p>That's the paradigm shift. One node (one stream of numbers) simultaneously controls audio loudness and particle physics. Not because we "routed" audio to visuals. Because they were never separate.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md579"></a>
Expansion 1: What Are NodeNetworks?</h2>
<details >
<summary >
Click to expand: Many Nodes, One Structure</summary>
<p></p>
<p>You've worked with individual <b>Nodes</b> i.e sample-by-sample processors. <b>NodeNetworks</b> coordinate <em>many</em> nodes with relationships between them.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Aspect   </th><th class="markdownTableHeadNone">Node   </th><th class="markdownTableHeadNone">NodeNetwork    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scale   </td><td class="markdownTableBodyNone">Single unit   </td><td class="markdownTableBodyNone">100–1000+ internal nodes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Relationships   </td><td class="markdownTableBodyNone">None (pure function)   </td><td class="markdownTableBodyNone">Topology-defined (spatial, chain, ring)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Output   </td><td class="markdownTableBodyNone">One value per sample   </td><td class="markdownTableBodyNone">Aggregated or per-node    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Use case   </td><td class="markdownTableBodyNone">Signal processing   </td><td class="markdownTableBodyNone">Emergent behavior, simulations   </td></tr>
</table>
<p><b>Available networks:</b></p>
<ul>
<li><code>ParticleNetwork</code>: N-body physics simulation (particles with forces, velocities, collisions)</li>
<li><code>ModalNetwork</code>: Physical modeling (resonant modes, coupled oscillators)</li>
</ul>
<p><b>ParticleNetwork</b> treats each particle as a <code>PointNode</code> (geometry) with physics state:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Particle {</div>
<div class="line">    std::shared_ptr&lt;PointNode&gt; point;  <span class="comment">// Position, color, size</span></div>
<div class="line">    glm::vec3 velocity;</div>
<div class="line">    glm::vec3 force;</div>
<div class="line">    <span class="keywordtype">float</span> mass;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Every frame, physics integrates: forces → velocities → positions. The <code>PointNode</code> positions update. GPU receives new vertex data.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md581"></a>
Expansion 2: Parameter Mapping from Buffers</h2>
<details >
<summary >
Click to expand: How Buffer Data Reaches Particle Physics</summary>
<p></p>
<p>When you write:</p>
<div class="fragment"><div class="line">particles-&gt;map_parameter(<span class="stringliteral">&quot;gravity&quot;</span>, envelope, NodeNetwork::MappingMode::BROADCAST);</div>
</div><!-- fragment --><p><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> stores the mapping. Each physics step, <code>ParticleNetwork::update_mapped_parameters()</code> reads from the node:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ParticleNetwork::update_mapped_parameters() {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; mapping : m_parameter_mappings) {</div>
<div class="line">        <span class="keywordflow">if</span> (mapping.mode == MappingMode::BROADCAST &amp;&amp; mapping.broadcast_source) {</div>
<div class="line">            <span class="keywordtype">double</span> value = mapping.broadcast_source-&gt;get_last_output();</div>
<div class="line">            apply_broadcast_parameter(mapping.param_name, value);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>The key</b>: Nodes have <code>get_last_output()</code>, a single queryable value from their most recent sample. The particle network runs at visual rate (60Hz), the node runs at audio rate (48kHz). The network simply reads whatever value the node last computed.</p>
<p><b>No conversion, no special routing</b>. The node doesn't know it's controlling particles. The particles don't know the value came from audio synthesis. Numbers flow through the same substrate.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md583"></a>
Expansion 3: NetworkGeometryBuffer Aggregates for GPU</h2>
<details >
<summary >
Click to expand: 500 Particles, One Draw Call</summary>
<p></p>
<p><code>NetworkGeometryBuffer</code> does for particle networks what <code>PointCollectionNode</code> did for manual points: aggregate many vertices into one GPU upload.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> buffer = std::make_shared&lt;NetworkGeometryBuffer&gt;(particles);</div>
<div class="line">buffer-&gt;setup_processors(ProcessingToken::GRAPHICS_BACKEND);</div>
<div class="line">buffer-&gt;setup_rendering({ .target_window = window });</div>
</div><!-- fragment --><p><b>Each frame:</b></p>
<ol type="1">
<li><code>NodeGraphManager</code> calls <code>particles-&gt;process_batch(1)</code> (physics step)</li>
<li>Physics updates: forces → velocities → positions</li>
<li><code>NetworkGeometryProcessor</code> extracts all 500 <code>PointNode</code> positions</li>
<li>Uploads to GPU as single contiguous vertex buffer</li>
<li>One draw call renders everything</li>
</ol>
<p>Without aggregation, 500 particles would mean 500 buffers, 500 uploads, 500 draw calls. That's GPU-hostile. <code>NetworkGeometryBuffer</code> batches automatically.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md585"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Inverse relationship: quiet = chaos, loud = order</span></div>
<div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> window = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Inverse&quot;</span>, 1920, 1080 });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Chaotic source: noise filtered into slow undulation</span></div>
<div class="line">    <span class="keyword">auto</span> noise = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">Random</a>() | Audio;</div>
<div class="line">    <span class="keyword">auto</span> smooth = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8.html#a4d7d43fd4040c892d45d17d29fbe1de8">IIR</a>(std::vector { 0.001 }, std::vector { 1.0, -0.999 }) | Audio; <span class="comment">// Very slow smoothing</span></div>
<div class="line">    noise &gt;&gt; smooth;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Invert: high values → low output, low values → high output</span></div>
<div class="line">    <span class="keyword">auto</span> inverter = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> 1.0 - std::clamp((x + 1.0) * 0.5, 0.0, 1.0); <span class="comment">// Flip and normalize</span></div>
<div class="line">    }) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> mod = smooth &gt;&gt; inverter;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Audio: the raw smoothed noise as drone</span></div>
<div class="line">    <span class="keyword">auto</span> drone = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(80.0) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> amp = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([mod](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> x * mod-&gt;get_last_output() * 0.3; }) | Audio;</div>
<div class="line">    drone &gt;&gt; amp;</div>
<div class="line">    smooth &gt;&gt; amp;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> particles = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a469d04ca6a873d72708b9f7e8f73f4b8.html#a469d04ca6a873d72708b9f7e8f73f4b8">ParticleNetwork</a>(</div>
<div class="line">                         400,</div>
<div class="line">                         glm::vec3(-1.5f, -1.5f, -0.5f),</div>
<div class="line">                         glm::vec3(1.5f, 1.5f, 0.5f))</div>
<div class="line">        | Graphics;</div>
<div class="line">    particles-&gt;set_topology(Topology::SPATIAL);</div>
<div class="line">    particles-&gt;set_interaction_radius(0.6f);</div>
<div class="line">    particles-&gt;set_spring_stiffness(0.3f);</div>
<div class="line">    particles-&gt;set_gravity(glm::vec3(0.0f, 0.0f, 0.0f));</div>
<div class="line">    particles-&gt;set_drag(0.05f);</div>
<div class="line">    particles-&gt;set_output_mode(OutputMode::GRAPHICS_BIND);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Inverted signal → turbulence: when audio swells, particles calm; when audio recedes, chaos</span></div>
<div class="line">    particles-&gt;map_parameter(<span class="stringliteral">&quot;turbulence&quot;</span>, inverter, NodeNetwork::MappingMode::BROADCAST);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> buffer = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa270d4ac9bb6b0cdf15d1cb3f330cd6.html#aaa270d4ac9bb6b0cdf15d1cb3f330cd6">NetworkGeometryBuffer</a>(particles) | Graphics;</div>
<div class="line">    buffer-&gt;setup_rendering({ .target_window = window });</div>
<div class="line"> </div>
<div class="line">    window-&gt;show();</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8_html_a4d7d43fd4040c892d45d17d29fbe1de8"><div class="ttname"><a href="classMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8.html#a4d7d43fd4040c892d45d17d29fbe1de8">MayaFlux::Creator::IIR</a></div><div class="ttdeci">auto IIR(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Filters::IIR &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7_html_a8a8d81842f8f6d77789cd3cd199c12e7"><div class="ttname"><a href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">MayaFlux::Creator::Random</a></div><div class="ttdeci">auto Random(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Random &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
</div><!-- fragment --><p>Sound and stillness invert. The drone grows loud, particles settle into structure. The drone fades, particles scatter into turbulence.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md587"></a>
&lt;strong&gt;Tutorial: Logic Events → Visual Impulse&lt;/strong&gt;</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> window = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Event Reactive&quot;</span>, 1920, 1080 });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Irregular pulse source: noise → threshold creates stochastic triggers</span></div>
<div class="line">    <span class="keyword">auto</span> noise = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">Random</a>();</div>
<div class="line">    noise-&gt;set_amplitude(0.3f);</div>
<div class="line">    <span class="keyword">auto</span> slow_filter = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8.html#a4d7d43fd4040c892d45d17d29fbe1de8">IIR</a>(std::vector { 0.01 }, std::vector { 1.0, -0.99 }) | Audio;</div>
<div class="line">    noise &gt;&gt; slow_filter;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Derivative approximation (emphasizes change, not level)</span></div>
<div class="line">    <span class="keyword">auto</span> diff = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8.html#a4d7d43fd4040c892d45d17d29fbe1de8">IIR</a>(std::vector { 1.0, -1.0 }, std::vector { 1.0 }) | Audio;</div>
<div class="line">    slow_filter &gt;&gt; diff;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Rectify and smooth</span></div>
<div class="line">    <span class="keyword">auto</span> rect = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> std::abs(x); }) | Audio;</div>
<div class="line">    diff &gt;&gt; rect;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> smooth = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8.html#a4d7d43fd4040c892d45d17d29fbe1de8">IIR</a>(std::vector { 0.1 }, std::vector { 1.0, -0.9 }) | Audio;</div>
<div class="line">    rect &gt;&gt; smooth;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Threshold into logic: fires when change exceeds threshold</span></div>
<div class="line">    <span class="keyword">auto</span> event_logic = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.008) | Audio;</div>
<div class="line">    smooth &gt;&gt; event_logic;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Particles in spherical formation</span></div>
<div class="line">    <span class="keyword">auto</span> particles = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a469d04ca6a873d72708b9f7e8f73f4b8.html#a469d04ca6a873d72708b9f7e8f73f4b8">ParticleNetwork</a>(</div>
<div class="line">                         300,</div>
<div class="line">                         glm::vec3(-1.0f, -1.0f, -1.0f),</div>
<div class="line">                         glm::vec3(1.0f, 1.0f, 1.0f),</div>
<div class="line">                         ParticleNetwork::InitializationMode::SPHERE_SURFACE)</div>
<div class="line">        | Graphics;</div>
<div class="line"> </div>
<div class="line">    particles-&gt;set_gravity(glm::vec3(0.0f, 0.0f, 0.0f));</div>
<div class="line">    particles-&gt;set_drag(0.04f);</div>
<div class="line">    particles-&gt;set_bounds_mode(ParticleNetwork::BoundsMode::NONE);</div>
<div class="line">    particles-&gt;set_attraction_point(glm::vec3(0.0f, 0.0f, 0.0f));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> buffer = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa270d4ac9bb6b0cdf15d1cb3f330cd6.html#aaa270d4ac9bb6b0cdf15d1cb3f330cd6">NetworkGeometryBuffer</a>(particles) | Graphics;</div>
<div class="line">    buffer-&gt;setup_rendering({ .target_window = window });</div>
<div class="line"> </div>
<div class="line">    window-&gt;show();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// On logic rising edge: breathing impulse</span></div>
<div class="line">    event_logic-&gt;on_change_to(<span class="keyword">true</span>, [particles](<span class="keyword">const</span> Nodes::NodeContext&amp; ctx) {</div>
<div class="line">        <span class="comment">// Radial expansion from center</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; particle : particles-&gt;get_particles()) {</div>
<div class="line">            glm::vec3 pos = particle.point-&gt;get_position();</div>
<div class="line">            glm::vec3 outward = glm::normalize(pos) * 3.0f;</div>
<div class="line">            particle.velocity += outward;</div>
<div class="line">        }</div>
<div class="line">    }); <span class="comment">// true = rising edge (false→true)</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef_html_ad172557289ef9c249a3cb0a3935bd1ef"><div class="ttname"><a href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">MayaFlux::Creator::Logic</a></div><div class="ttdeci">auto Logic(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Logic &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
</div><!-- fragment --><p>Run this. Stochastic events emerge from filtered noise which is unpredictable but fully random. Each event triggers a click and a radial breath. The sphere pulses with emergent rhythm, not metronomic time.</p>
<p>The chain detects change in the noise contour, not amplitude. Slow drifts pass silently. Sharp inflections trigger events. The same logic detection pattern from the original, but driven by generative source rather than external input.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md589"></a>
Expansion 1: Logic Processor Callbacks</h2>
<details >
<summary >
Click to expand: Edge Detection for Discrete Events</summary>
<p></p>
<p>Logic processors output binary values (0.0 or 1.0). For visual events, you want <em>transitions</em>, not continuous states:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Callback   </th><th class="markdownTableHeadNone">When It Fires    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>on_rising_edge(callback)</code>   </td><td class="markdownTableBodyNone">Once per false→true transition    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>on_falling_edge(callback)</code>   </td><td class="markdownTableBodyNone">Once per true→false transition    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>on_any_edge(callback)</code>   </td><td class="markdownTableBodyNone">Any transition    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>while_true(callback)</code>   </td><td class="markdownTableBodyNone">Continuously while state is true   </td></tr>
</table>
<p><b>For transient detection, you want the rising edge:</b></p>
<div class="fragment"><div class="line">logic_proc-&gt;on_rising_edge([particles]() {</div>
<div class="line">    <span class="comment">// Fires ONCE per detected transient</span></div>
<div class="line">    particles-&gt;apply_global_impulse(<span class="comment">/* ... */</span>);</div>
<div class="line">});</div>
</div><!-- fragment --><p>If you used <code>while_true()</code>, you'd fire continuously while the transient is detected (potentially many frames). <code>on_rising_edge()</code> fires once, precisely at the moment of detection.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md591"></a>
Expansion 2: Transient Detection Chain</h2>
<details >
<summary >
Click to expand: Derivative → Rectify → Smooth → Threshold</summary>
<p></p>
<p>The transient detection chain:</p>
<div class="fragment"><div class="line">mic → diff → rect → smooth → threshold</div>
</div><!-- fragment --><p><b>Step 1: Derivative (emphasize change)</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> diff = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8.html#a4d7d43fd4040c892d45d17d29fbe1de8">IIR</a>({1.0, -1.0}, {1.0});</div>
</div><!-- fragment --><p>Output is approximately <code>current - previous</code>. Sustained tones produce near-zero. Sharp attacks produce spikes.</p>
<p><b>Step 2: Rectify (absolute value)</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> rect = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> std::abs(x); });</div>
</div><!-- fragment --><p>Both positive and negative spikes become positive. We care about <em>magnitude</em> of change, not direction.</p>
<p><b>Step 3: Smooth (envelope follower)</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> smooth = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8.html#a4d7d43fd4040c892d45d17d29fbe1de8">IIR</a>({0.1}, {1.0, -0.9});</div>
</div><!-- fragment --><p>Lowpass on the rectified derivative. Converts rapid spikes into slower contour. The <code>0.9</code> feedback creates ~10ms decay.</p>
<p><b>Step 4: Threshold</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> transient_logic = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.15);</div>
</div><!-- fragment --><p>When smoothed derivative exceeds 0.15, output is 1.0. Below, output is 0.0. Tune this to your input sensitivity.</p>
<p><b>This chain detects <em>change</em>, not loudness.</b> A sustained loud tone won't trigger. A quiet click will.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md593"></a>
Expansion 3: Per-Particle Impulse vs Global Impulse</h2>
<details >
<summary >
Click to expand: Directional vs Uniform Force Application</summary>
<p></p>
<p>Two approaches to impulse:</p>
<p><b>Global impulse (uniform direction):</b></p>
<div class="fragment"><div class="line">particles-&gt;apply_global_impulse(glm::vec3(0.0f, 5.0f, 0.0f));</div>
</div><!-- fragment --><p>Every particle gets the same velocity added. Good for waves, directional pushes.</p>
<p><b>Per-particle impulse (radial breathing):</b></p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; particle : particles-&gt;get_particles()) {</div>
<div class="line">    glm::vec3 pos = particle.point-&gt;get_position();</div>
<div class="line">    glm::vec3 outward = glm::normalize(pos) * 3.0f;</div>
<div class="line">    particle.velocity += outward;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Each particle moves outward from center. Good for expansion/contraction, breathing forms.</p>
<p><b>Combine with audio intensity:</b></p>
<div class="fragment"><div class="line">logic_proc-&gt;on_rising_edge([particles, mic]() {</div>
<div class="line">    <span class="keywordtype">double</span> intensity = extract_buffer_rms(mic);</div>
<div class="line">    <span class="keywordtype">float</span> scale = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(intensity) * 10.0f;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; particle : particles-&gt;get_particles()) {</div>
<div class="line">        glm::vec3 pos = particle.point-&gt;get_position();</div>
<div class="line">        glm::vec3 outward = glm::normalize(pos) * scale;</div>
<div class="line">        particle.velocity += outward;</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>Louder transients → bigger breaths.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md595"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Spectral splitting: low frequencies → horizontal, high frequencies → vertical</span></div>
<div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> window = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Spectral Spatial&quot;</span>, 1920, 1080 });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Two independent LFOs at different rates</span></div>
<div class="line">    <span class="keyword">auto</span> low_lfo = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(0.1); <span class="comment">// Slow oscillation</span></div>
<div class="line">    <span class="keyword">auto</span> high_lfo = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(0.7); <span class="comment">// Faster oscillation</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Normalize to 0..1</span></div>
<div class="line">    <span class="keyword">auto</span> low_norm = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> (x + 1.0) * 0.5; }) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> high_norm = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> (x + 1.0) * 0.5; }) | Audio;</div>
<div class="line">    low_norm-&gt;set_input_node(low_lfo);</div>
<div class="line">    high_norm-&gt;set_input_node(high_lfo);</div>
<div class="line"> </div>
<div class="line">    low_norm-&gt;enable_mock_process(<span class="keyword">true</span>);</div>
<div class="line">    high_norm-&gt;enable_mock_process(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Audio output: layered tones</span></div>
<div class="line">    <span class="keyword">auto</span> bass = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(55.0) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> treble = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(880.0) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> bass_amp = bass * low_norm;</div>
<div class="line">    <span class="keyword">auto</span> treble_amp = treble * high_norm;</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_function" href="namespaceMayaFlux_aeeb5db3214dcd90b0778eea361e62276.html#aeeb5db3214dcd90b0778eea361e62276">mix</a> = bass_amp + treble_amp;</div>
<div class="line">    <a class="code hl_function" href="namespaceMayaFlux_aeeb5db3214dcd90b0778eea361e62276.html#aeeb5db3214dcd90b0778eea361e62276">mix</a> * 0.3;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> particles = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a469d04ca6a873d72708b9f7e8f73f4b8.html#a469d04ca6a873d72708b9f7e8f73f4b8">ParticleNetwork</a>(</div>
<div class="line">                         600,</div>
<div class="line">                         glm::vec3(-2.0f, -1.5f, -0.5f),</div>
<div class="line">                         glm::vec3(2.0f, 1.5f, 0.5f),</div>
<div class="line">                         ParticleNetwork::InitializationMode::GRID)</div>
<div class="line">        | Graphics;</div>
<div class="line"> </div>
<div class="line">    particles-&gt;set_gravity(glm::vec3(0.0f, 0.0f, 0.0f));</div>
<div class="line">    particles-&gt;set_drag(0.08f);</div>
<div class="line">    particles-&gt;set_bounds_mode(ParticleNetwork::BoundsMode::BOUNCE);</div>
<div class="line">    particles-&gt;set_topology(Topology::GRID_2D);</div>
<div class="line"> </div>
<div class="line">    particles-&gt;map_parameter(<span class="stringliteral">&quot;turbulence&quot;</span>, low_norm, NodeNetwork::MappingMode::BROADCAST);</div>
<div class="line"> </div>
<div class="line">    particles-&gt;map_parameter(<span class="stringliteral">&quot;drag&quot;</span>, high_norm, NodeNetwork::MappingMode::BROADCAST);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> buffer = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa270d4ac9bb6b0cdf15d1cb3f330cd6.html#aaa270d4ac9bb6b0cdf15d1cb3f330cd6">NetworkGeometryBuffer</a>(particles) | Graphics;</div>
<div class="line">    buffer-&gt;setup_rendering({ .target_window = window });</div>
<div class="line"> </div>
<div class="line">    window-&gt;show();</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceMayaFlux_aeeb5db3214dcd90b0778eea361e62276_html_aeeb5db3214dcd90b0778eea361e62276"><div class="ttname"><a href="namespaceMayaFlux_aeeb5db3214dcd90b0778eea361e62276.html#aeeb5db3214dcd90b0778eea361e62276">MayaFlux::mix</a></div><div class="ttdeci">std::vector&lt; double &gt; mix(const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;streams)</div><div class="ttdoc">Mix multiple data streams with equal weighting.</div><div class="ttdef"><b>Definition</b> <a href="Yantra_8cpp_source.html#l01019">Yantra.cpp:1019</a></div></div>
</div><!-- fragment --><p>Bass makes the form sway side to side. Treble makes it bounce up and down. Spectral content becomes spatial dimension.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md597"></a>
&lt;strong&gt;Tutorial: Topology and Emergent Form&lt;/strong&gt;</h1>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> window = <a class="code hl_function" href="namespaceMayaFlux_a76496539df28697c745cc22b37edcade.html#a76496539df28697c745cc22b37edcade">MayaFlux::create_window</a>({ <span class="stringliteral">&quot;Emergent&quot;</span>, 1920, 1080 });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Control signal: slow triangle wave</span></div>
<div class="line">    <span class="keyword">auto</span> control = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a712ebff89ba142161eb68bb2e9a07b52.html#a712ebff89ba142161eb68bb2e9a07b52">Phasor</a>(0.15) | Audio;  <span class="comment">// 0..1 ramp, ~7 second cycle</span></div>
<div class="line">    <span class="keyword">auto</span> shaped = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x &lt; 0.5 ? x * 2.0 : 2.0 - x * 2.0;  <span class="comment">// Triangle</span></div>
<div class="line">    }) | Audio;</div>
<div class="line">    control &gt;&gt; shaped;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Audio: resonant ping modulated by control</span></div>
<div class="line">    <span class="keyword">auto</span> resonator = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(330.0) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> env = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> std::exp(-x * 5.0);</div>
<div class="line">    }) | Audio;</div>
<div class="line">    shaped &gt;&gt; env;</div>
<div class="line">    <span class="keyword">auto</span> audio_out = resonator * env | Audio;</div>
<div class="line">    audio_out * 0.3;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Particles with spatial interaction</span></div>
<div class="line">    <span class="keyword">auto</span> particles = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a469d04ca6a873d72708b9f7e8f73f4b8.html#a469d04ca6a873d72708b9f7e8f73f4b8">ParticleNetwork</a>(</div>
<div class="line">        400,</div>
<div class="line">        glm::vec3(-1.5f, -1.5f, -0.5f),</div>
<div class="line">        glm::vec3(1.5f, 1.5f, 0.5f),</div>
<div class="line">        ParticleNetwork::InitializationMode::GRID</div>
<div class="line">    ) | Graphics;</div>
<div class="line"> </div>
<div class="line">    particles-&gt;set_topology(Topology::SPATIAL);</div>
<div class="line">    particles-&gt;set_interaction_radius(0.5f);</div>
<div class="line">    particles-&gt;set_spring_stiffness(0.2f);</div>
<div class="line">    particles-&gt;set_repulsion_strength(1.0f);</div>
<div class="line">    particles-&gt;set_gravity(glm::vec3(0.0f, 0.0f, 0.0f));</div>
<div class="line">    particles-&gt;set_drag(0.03f);</div>
<div class="line">    particles-&gt;set_bounds_mode(ParticleNetwork::BoundsMode::BOUNCE);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Control signal → spring stiffness: rising = rigidifying, falling = softening</span></div>
<div class="line">    particles-&gt;map_parameter(<span class="stringliteral">&quot;spring_stiffness&quot;</span>, shaped, NodeNetwork::MappingMode::BROADCAST);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> buffer = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_aaa270d4ac9bb6b0cdf15d1cb3f330cd6.html#aaa270d4ac9bb6b0cdf15d1cb3f330cd6">NetworkGeometryBuffer</a>(particles) | Graphics;</div>
<div class="line">    buffer-&gt;setup_rendering({ .target_window = window });</div>
<div class="line"> </div>
<div class="line">    window-&gt;show();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Periodic disturbance to reveal stiffness changes</span></div>
<div class="line">    <a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.5, [particles]() {</div>
<div class="line">        particles-&gt;apply_global_impulse(glm::vec3(</div>
<div class="line">            <a class="code hl_function" href="namespaceMayaFlux_a8969856c48c84fe3db8145c202328672.html#a8969856c48c84fe3db8145c202328672">MayaFlux::get_uniform_random</a>(-0.5f, 0.5f),</div>
<div class="line">            <a class="code hl_function" href="namespaceMayaFlux_a8969856c48c84fe3db8145c202328672.html#a8969856c48c84fe3db8145c202328672">MayaFlux::get_uniform_random</a>(-0.5f, 0.5f),</div>
<div class="line">            <a class="code hl_function" href="namespaceMayaFlux_a8969856c48c84fe3db8145c202328672.html#a8969856c48c84fe3db8145c202328672">MayaFlux::get_uniform_random</a>(-0.2f, 0.2f)</div>
<div class="line">        ));</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a712ebff89ba142161eb68bb2e9a07b52_html_a712ebff89ba142161eb68bb2e9a07b52"><div class="ttname"><a href="classMayaFlux_1_1Creator_a712ebff89ba142161eb68bb2e9a07b52.html#a712ebff89ba142161eb68bb2e9a07b52">MayaFlux::Creator::Phasor</a></div><div class="ttdeci">auto Phasor(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Phasor &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
</div><!-- fragment --><p>Run this. The grid receives periodic disturbances. When you're silent, particles flow fluidly, springs are weak. When you speak, the structure rigidifies, springs tighten. Sound becomes material property.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md599"></a>
Expansion 1: Topology Types</h2>
<details >
<summary >
Click to expand: How Particles Relate</summary>
<p></p>
<p><code>set_topology()</code> determines which particles interact:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Topology   </th><th class="markdownTableHeadNone">Behavior   </th><th class="markdownTableHeadNone">Use Case    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>INDEPENDENT</code>   </td><td class="markdownTableBodyNone">No inter-particle forces   </td><td class="markdownTableBodyNone">Particle storms, rain    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SPATIAL</code>   </td><td class="markdownTableBodyNone">Neighbors within radius interact   </td><td class="markdownTableBodyNone">Organic clustering, flocking    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>RING</code>   </td><td class="markdownTableBodyNone">Each connects to prev/next   </td><td class="markdownTableBodyNone">Chains, ropes, tentacles    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>GRID_2D</code>   </td><td class="markdownTableBodyNone">2D lattice connections   </td><td class="markdownTableBodyNone">Cloth, membranes   </td></tr>
</table>
<p><b>SPATIAL</b> is the most general. Particles find neighbors within <code>interaction_radius</code>. Springs pull distant neighbors closer. Repulsion pushes overlapping particles apart.</p>
<p><b>The metaphor:</b> Sound doesn't just <em>push</em> particles. It changes <em>how they relate to each other</em>. The form itself responds to audio, not just its position.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md601"></a>
Expansion 2: Material Properties as Audio Targets</h2>
<details >
<summary >
Click to expand: Beyond Position: Mapping to Structure</summary>
<p></p>
<p>Most audio-reactive systems map amplitude → position/size/color. That's valid but limited. <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> lets you map to <em>material properties</em>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Property   </th><th class="markdownTableHeadNone">Effect   </th><th class="markdownTableHeadNone">Metaphor    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>spring_stiffness</code>   </td><td class="markdownTableBodyNone">How rigid connections are   </td><td class="markdownTableBodyNone">Sound as material phase (liquid↔solid)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>interaction_radius</code>   </td><td class="markdownTableBodyNone">How far influence extends   </td><td class="markdownTableBodyNone">Sound as social distance    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>repulsion_strength</code>   </td><td class="markdownTableBodyNone">How strongly particles avoid overlap   </td><td class="markdownTableBodyNone">Sound as personal space    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>drag</code>   </td><td class="markdownTableBodyNone">How quickly motion decays   </td><td class="markdownTableBodyNone">Sound as viscosity   </td></tr>
</table>
<p><b>Example: Sound as temperature</b></p>
<p>High temperature = particles move freely, weak bonds. Low temperature = rigid structure.</p>
<div class="fragment"><div class="line"><span class="comment">// Invert audio: silence = cold/rigid, loud = hot/fluid</span></div>
<div class="line"><span class="keyword">auto</span> inverter = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> 1.0 - std::clamp(x * 2.0, 0.0, 1.0); });</div>
<div class="line">MayaFlux::create_processor&lt;PolynomialProcessor&gt;(mic, inverter);</div>
<div class="line"> </div>
<div class="line">particles-&gt;map_buffer_parameter(<span class="stringliteral">&quot;spring_stiffness&quot;</span>, mic, MappingMode::BROADCAST);</div>
<div class="line">particles-&gt;map_buffer_parameter(<span class="stringliteral">&quot;drag&quot;</span>, mic, MappingMode::BROADCAST);</div>
</div><!-- fragment --><p>Now silence freezes the form. Sound melts it.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md603"></a>
What You've Learned</h2>
<p><b>NodeNetworks:</b> Collections of nodes with relationships (physics, topology) <br  />
 <b>ParticleNetwork:</b> N-body simulation with configurable interaction <br  />
 <b>NetworkGeometryBuffer:</b> Aggregates particle positions → single GPU upload <br  />
 <b>Buffer-to-parameter mapping:</b> Audio buffers control physics properties <br  />
 <b>Logic processor callbacks:</b> Edge detection for discrete visual events <br  />
 <b>Topology:</b> How particles relate—independent, spatial, ring, grid <br  />
 <b>Material property mapping:</b> Audio controls structure, not just position</p>
<p><b>Pattern:</b></p>
<div class="fragment"><div class="line"><span class="comment">// 1. Create audio analysis buffer</span></div>
<div class="line"><span class="keyword">auto</span> mic = <a class="code hl_function" href="namespaceMayaFlux_a156aa5a54a2a941e0eb8f9618d601be1.html#a156aa5a54a2a941e0eb8f9618d601be1">MayaFlux::create_input_listener_buffer</a>(0, <span class="keyword">false</span>);</div>
<div class="line"><span class="comment">// Add processors: envelope, filter, logic, etc.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Create particle network</span></div>
<div class="line"><span class="keyword">auto</span> particles = std::make_shared&lt;ParticleNetwork&gt;(<a class="code hl_variable" href="MotionCurves_8cpp_a6d2b76e9cc3987bea1a21257c836cf9e.html#a6d2b76e9cc3987bea1a21257c836cf9e">count</a>, bounds_min, bounds_max);</div>
<div class="line">particles-&gt;set_topology(<span class="comment">/* ... */</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Map audio to physics parameters</span></div>
<div class="line">particles-&gt;map_buffer_parameter(<span class="stringliteral">&quot;spring_stiffness&quot;</span>, mic, MappingMode::BROADCAST);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 4. Setup rendering</span></div>
<div class="line"><span class="keyword">auto</span> buffer = std::make_shared&lt;NetworkGeometryBuffer&gt;(particles);</div>
<div class="line">buffer-&gt;setup_rendering({ .target_window = window });</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a7439636286675f6d800b1f399d562887.html#a7439636286675f6d800b1f399d562887">MayaFlux::register_node_network</a>(particles, ProcessingToken::GRAPHICS_BACKEND);</div>
<div class="ttc" id="aMotionCurves_8cpp_a6d2b76e9cc3987bea1a21257c836cf9e_html_a6d2b76e9cc3987bea1a21257c836cf9e"><div class="ttname"><a href="MotionCurves_8cpp_a6d2b76e9cc3987bea1a21257c836cf9e.html#a6d2b76e9cc3987bea1a21257c836cf9e">count</a></div><div class="ttdeci">Eigen::Index count</div><div class="ttdef"><b>Definition</b> <a href="MotionCurves_8cpp_source.html#l00070">MotionCurves.cpp:70</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a156aa5a54a2a941e0eb8f9618d601be1_html_a156aa5a54a2a941e0eb8f9618d601be1"><div class="ttname"><a href="namespaceMayaFlux_a156aa5a54a2a941e0eb8f9618d601be1.html#a156aa5a54a2a941e0eb8f9618d601be1">MayaFlux::create_input_listener_buffer</a></div><div class="ttdeci">std::shared_ptr&lt; Buffers::AudioBuffer &gt; create_input_listener_buffer(uint32_t channel, bool add_to_output)</div><div class="ttdoc">Creates a new AudioBuffer for input listening.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00243">Graph.cpp:243</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a7439636286675f6d800b1f399d562887_html_a7439636286675f6d800b1f399d562887"><div class="ttname"><a href="namespaceMayaFlux_a7439636286675f6d800b1f399d562887.html#a7439636286675f6d800b1f399d562887">MayaFlux::register_node_network</a></div><div class="ttdeci">void register_node_network(const std::shared_ptr&lt; Nodes::Network::NodeNetwork &gt; &amp;network, const Nodes::ProcessingToken &amp;token)</div><div class="ttdoc">Registers a node network with the default engine's node graph manager.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00176">Graph.cpp:176</a></div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md605"></a>
Conclusion</h1>
<h2><a class="anchor" id="autotoc_md606"></a>
The Deeper Point</h2>
<p>You've crossed the boundary that most frameworks enforce: audio and visuals as separate pipelines, separate mental models, separate codebases.</p>
<p>In <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>, there is no boundary. A node that shapes amplitude can shape gravity. A logic gate that triggers a click can trigger a breath. The same polynomial that distorts audio can warp spatial relationships.</p>
<p>This isn't a "feature." It's the consequence of treating all creative data as what it actually is: numbers flowing through transformations.</p>
<p>The particle systems you've built here demonstrate the principle cross-domain data flow, but they're still working with pre-built physics simulations. The GPU does what <code>ParticleNetwork</code> tells it to do.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md608"></a>
What Comes Next</h2>
<p><b>Visual Materiality Part II</b> moves deeper into the GPU itself.</p>
<p>Instead of mapping audio to physics parameters, you'll bind nodes directly to shader programs. <code>NodeBindingsProcessor</code> writes node outputs to push constants, i.e small, fast values updated every frame. <code>DescriptorBindingsProcessor</code> writes larger data (vectors, matrices, spectra) to UBOs and SSBOs.</p>
<p>You'll learn:</p>
<ul>
<li><b>Compute shaders</b>: Massively parallel data transformation on GPU</li>
<li><b>Push constant bindings</b>: Node values injected directly into shader execution</li>
<li><b>Descriptor bindings</b>: Spectrum data, matrices, structured arrays flowing to GPU</li>
<li><b>Custom vertex transformations</b>: Audio-driven geometry deformation</li>
<li><b>Fragment manipulation</b>: Color, texture, and pixel-level audio response</li>
</ul>
<p>The architecture you've learned: nodes, buffers, processors, tokens; remains identical. But instead of <code>map_parameter("gravity", envelope)</code>, you'll write:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> processor = std::make_shared&lt;NodeBindingsProcessor&gt;(<span class="stringliteral">&quot;displacement.comp&quot;</span>);</div>
<div class="line">processor-&gt;bind_node(<span class="stringliteral">&quot;amplitude&quot;</span>, envelope, offsetof(PushConstants, amplitude));</div>
</div><!-- fragment --><p>And inside your GLSL:</p>
<div class="fragment"><div class="line">layout(push_constant) uniform PushConstants {</div>
<div class="line">    float amplitude;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    vec3 displaced = position + normal * amplitude * 0.5;</div>
<div class="line">    // ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Same <code>get_last_output()</code>. Same data flow. But now you control every vertex, every fragment, every compute thread.</p>
<p><b>The substrate doesn't change. Your access to it deepens.</b> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
