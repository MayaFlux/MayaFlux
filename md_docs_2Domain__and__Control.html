<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MayaFlux: Domains and Control: Computational Contexts in Digital Creation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MayaFlux<span id="projectnumber">&#160;0.2.0</span>
   </div>
   <div id="projectbrief">Digital-First Multimedia Processing Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2Domain__and__Control.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Domains and Control: Computational Contexts in Digital Creation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md221"></a></p><ul>
<li>Domains and Control: Computational Contexts in Digital Creation</li>
<li>Processing Tokens: Computational Identity<ul>
<li>Nodes::ProcessingTokens</li>
<li>Buffers::ProcessingTokens</li>
<li>Vruta::ProcessingTokens</li>
<li>Domain Composition: Unified Computational Environments</li>
</ul>
</li>
<li>Engine Control vs User Control: Computational Autonomy<ul>
<li>Nodes<ul>
<li>NodeGraphManager<ul>
<li>Explicit user control</li>
</ul>
</li>
<li>RootNode</li>
<li>Direct Node Management<ul>
<li>Chaining</li>
</ul>
</li>
</ul>
</li>
<li>Buffers<ul>
<li>BufferManager</li>
<li>RootBuffer</li>
<li>Direct buffer management and processing</li>
</ul>
</li>
<li>Coroutines<ul>
<li>TaskScheduler</li>
<li>Kriya</li>
<li>Clock Systems</li>
<li>Direct Coroutine Management<ul>
<li>Self-managed SoundRoutine Creation</li>
<li>API-based Awaiter Patterns</li>
</ul>
</li>
<li>Direct Routine Control and State Management</li>
<li>Multi-domain Coroutine Coordination%</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Digital creative systems require more than individual transformation unitsâ€”they need <em>computational contexts</em> that coordinate timing, resource allocation, and execution strategies across different processing requirements. <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> introduces <code>Domains</code> as unified computational environments where Nodes, Buffers, and Coroutines operate with shared understanding of temporal precision, execution location, and coordination patterns.</p>
<p>Rather than forcing all processes into a single temporal framework, Domains enable <em>multi-modal computational thinking</em> where audio-rate precision, visual-frame coordination, and custom temporal patterns coexist and interact naturally. Each Domain represents a complete processing configuration that spans all three subsystems, creating coherent computational environments for different creative requirements.</p>
<h1><a class="anchor" id="autotoc_md222"></a>
Processing Tokens: Computational Identity</h1>
<p>Each subsystem defines its processing characteristics through <code>ProcessingTokens</code>: computational identities that specify how information should be handled within that domain:</p>
<h2><a class="anchor" id="autotoc_md223"></a>
Nodes::ProcessingTokens</h2>
<p>Considering the unit by unit processing nature of Nodes, the domains pertain to the rate at which each unit is processed. Hence, Nodes support the following <code>ProcessingTokens</code></p>
<ul>
<li><b>AUDIO_RATE:</b> processes information at sample-level precision, making unit-by-unit transformations synchronized with audio timing.</li>
<li><b>VISUAL_RATE:</b> operates at frame-level coordination, enabling visual transformations that align with display refresh patterns.</li>
<li><b>CUSTOM_RATE:</b> provides user-defined temporal precision for computational patterns that transcend traditional audio or visual constraints.</li>
</ul>
<h2><a class="anchor" id="autotoc_md224"></a>
Buffers::ProcessingTokens</h2>
<p>As the processors attached to buffers operate on the entire data collection, the domain system for Buffers require different methodologies and accommodate new features. It is simply not limited to rate of processing but also the device onto which the processing frame can be offloaded to. Batch processing also affords features such as sequential vs parallel processing. <code>Buffers::ProcessingToken</code> contain following set of bitfield composition to specify execution characteristics:</p>
<ul>
<li><b>SAMPLE_RATE:</b> evaluates buffer-sized chunks at audio rate, and <b>FRAME_RATE:</b> processes frame-based data blocks. They are mutually exclusive</li>
<li><b>CPU_PROCESS</b> and <b>GPU_PROCESS</b> define execution location, and are mutually exclusive</li>
<li><b>SEQUENTIAL</b> and <b>PARALLEL</b> control concurrency patterns, and are mutually exclusive.</li>
</ul>
<p>There are following combined tokens:</p>
<ul>
<li><b>AUDIO_BACKEND</b> = <code>SAMPLE_RATE</code> + <code>CPU_PROCESS</code> + <code>SEQUENTIAL</code></li>
<li><b>GRAPHICS_BACKEND</b> = <code>FRAME_RATE</code> + <code>GPU_PROCESS</code> + <code>PARALLEL</code></li>
<li><b>AUDIO_PARALLEL</b> = <code>SAMPLE_RATE</code> + <code>GPU_PROCESS</code> + <code>PARALLEL</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md225"></a>
Vruta::ProcessingTokens</h2>
<p>Coroutines need similar processing tokens as Nodes, i.e tick rate accuracy. Coroutines also benefit from being available to <code>suspend</code>, <code>resume</code> or <code>restart</code> on demand.</p>
<p>Routines configured via <code>Vruta</code> (and <code>Scheduler</code>) can be configured to use the following tokens:</p>
<ul>
<li><b>SAMPLE_ACCURATE</b> provides sample-level temporal precision for audio-synchronized coroutines.</li>
<li><b>FRAME_ACCURATE</b> aligns with visual frame timing.</li>
<li><b>MULTI_RATE</b> adapts dynamically between different temporal patterns.</li>
<li><b>ON_DEMAND</b> enables event-driven execution.</li>
<li><b>CUSTOM</b> supports user-defined coordination patterns.</li>
</ul>
<h2><a class="anchor" id="autotoc_md226"></a>
Domain Composition: Unified Computational Environments</h2>
<p>Domains combine these tokens into coherent computational contexts using bitfield composition. Each Domain represents a complete processing configuration:</p>
<div class="fragment"><div class="line"><span class="comment">// Audio processing with sample-accurate coordination</span></div>
<div class="line">Domain::AUDIO = Nodes::ProcessingToken::AUDIO_RATE + Buffers::ProcessingToken::AUDIO_BACKEND + Vruta::ProcessingToken::SAMPLE_ACCURATE</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Graphics with frame-accurate synchronization</span></div>
<div class="line">Domain::GRAPHICS = Nodes::ProcessingToken::VISUAL_RATE + Buffers::ProcessingToken::GRAPHICS_BACKEND + Vruta::ProcessingToken::FRAME_ACCURATE</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Parallel audio processing with GPU acceleration</span></div>
<div class="line">Domain::AUDIO_GPU = Nodes::ProcessingToken::AUDIO_RATE + Buffers::ProcessingToken::GPU_PROCESS + Vruta::ProcessingToken::MULTI_RATE</div>
</div><!-- fragment --><p>This composition enables <b>domain decomposition</b> where complex computational requirements can be broken into constituent processing characteristics and recombined as needed:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_variable" href="Chain_8cpp_a017db8a39783aa759534b986bb5b775f.html#a017db8a39783aa759534b986bb5b775f">node_token</a> = get_node_token(Domain::AUDIO_GPU);</div>
<div class="line"><span class="keyword">auto</span> buffer_token = get_buffer_token(Domain::AUDIO_GPU);</div>
<div class="line"><span class="keyword">auto</span> task_token = get_task_token(Domain::AUDIO_GPU);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create custom domain from individual tokens</span></div>
<div class="line"><span class="keyword">auto</span> custom_domain = compose_domain(</div>
<div class="line">    Nodes::CUSTOM_RATE,</div>
<div class="line">    Buffers::FRAME_RATE | Buffers::CPU_PROCESS | Buffers::PARALLEL,</div>
<div class="line">    Vruta::ON_DEMAND</div>
<div class="line">);</div>
<div class="ttc" id="aChain_8cpp_a017db8a39783aa759534b986bb5b775f_html_a017db8a39783aa759534b986bb5b775f"><div class="ttname"><a href="Chain_8cpp_a017db8a39783aa759534b986bb5b775f.html#a017db8a39783aa759534b986bb5b775f">node_token</a></div><div class="ttdeci">static const auto node_token</div><div class="ttdef"><b>Definition</b> <a href="Chain_8cpp_source.html#l00009">Chain.cpp:9</a></div></div>
</div><!-- fragment --><p>Domains enable <b>cross-modal coordination</b> where different temporal patterns interact naturally:</p>
<div class="fragment"><div class="line"><span class="comment">// Audio-visual synchronization</span></div>
<div class="line"><span class="keyword">auto</span> sync_domain = Domain::AUDIO_VISUAL_SYNC;</div>
<div class="line"><span class="keyword">auto</span> spectral_node = vega.fft() | sync_domain;</div>
<div class="line"><span class="keyword">auto</span> visual_buffer = graphics_buffer | sync_domain;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Data flows between temporal contexts while maintaining coordination</span></div>
<div class="line">spectral_node &gt;&gt; visual_buffer;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md227"></a>
Engine Control vs User Control: Computational Autonomy</h1>
<p><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> operates on a <b>default automation with expressive override</b> philosophy. The engine provides intelligent automation for common creative workflows while enabling precise user control when specific computational patterns are required. This is also tightly coupled with the philosophy that every practical aspect of the API should yield itself to overrides, substitution or disabling.</p>
<p>By default, operations use the engine's managed systems for optimal performance and coordination: This pertains to <code>Nodes</code>, <code>Buffers</code> and <code>Coroutines</code>. Containers, due to their non cyclical nature do not have enforced engine defaults, but can.</p>
<p>Engine management happens through multiple systems and managers for each paradigm, and at every step they require explicit domain specification (often automated to defaults via API wrappers).</p>
<p>Here is a breakdown of each component flow in engine management and examples for overriding with user control.</p>
<h2><a class="anchor" id="autotoc_md228"></a>
Nodes</h2>
<p>The <code>Engine</code> class that functions as the default coordinator and lifecyle manager for <em>Backends</em> and <em>Subsystems</em> also manages the central node coordinator called <code>NodeGraphManager</code>.</p>
<p>While the aforementioned backends, subsystems and Engine itself can be untangled from central management and replaced with different systems, that is a conversation for a different time.</p>
<h3><a class="anchor" id="autotoc_md229"></a>
NodeGraphManager</h3>
<div class="fragment"><div class="line"><span class="comment">// Fluent API - Engine handles domain assignment and registration</span></div>
<div class="line"><span class="keyword">auto</span> sine_node = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(440.0f) | Audio;     <span class="comment">// Automatic AUDIO_RATE domain</span></div>
<div class="line"><span class="keyword">auto</span> noise_gen = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">Random</a>(GAUSSIAN)[1];  <span class="comment">// Automatic channel 1 assignment</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// API Wrappers - Engine manages registration and token assignment</span></div>
<div class="line"><span class="keyword">auto</span> envelope = MayaFlux::create_node&lt;Shape&gt;(0.0f, 1.0f, 2.5f);  <span class="comment">// Auto-registered to default channel</span></div>
<div class="line"><span class="keyword">auto</span> filter = MayaFlux::create_node&lt;IIR&gt;(lowpass_coeffs);        <span class="comment">// Auto-assigned AUDIO_RATE token</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Engine handles node graph coordination</span></div>
<div class="line">sine_node &gt;&gt; filter &gt;&gt; envelope;  <span class="comment">// Automatic connection and flow management</span></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7_html_a8a8d81842f8f6d77789cd3cd199c12e7"><div class="ttname"><a href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">MayaFlux::Creator::Random</a></div><div class="ttdeci">auto Random(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Random &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687_html_ae9b21dfc8a04dd2826b63cda4dae4687"><div class="ttname"><a href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">MayaFlux::Creator::Sine</a></div><div class="ttdeci">auto Sine(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Sine &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
</div><!-- fragment --><p>The engine's NodeGraphManager automatically:</p>
<ul>
<li>Assigns processing tokens based on domain specifications</li>
<li>Registers nodes with appropriate channel routing</li>
<li>Manages root node hierarchies across different processing tokens</li>
<li>Coordinates timing and execution across multiple domains</li>
</ul>
<p>When initializing using vega, <code>vega.Sine()[0] | Audio</code>, the instruction is to create node -&gt; get default NodeGraphManger from engine -&gt; register it for Channel 0's root -&gt; at <code>Domain::Audio</code>, which resolves to <code>Nodes::ProcessingToken::AUDIO_RATE</code></p>
<h4><a class="anchor" id="autotoc_md230"></a>
Explicit user control</h4>
<p>The same node can be registered directly with <code>NodeGraphManager::add_to_root(shared_ptr(node), ProcessingToken, channel)</code></p>
<p>Calling <code><a class="el" href="namespaceMayaFlux_aaed41e3f8ff8e36b6e2df90aa68a1e24.html#aaed41e3f8ff8e36b6e2df90aa68a1e24">MayaFlux::create_node</a></code> is functionally identical to <code>vega</code>, except the <em>Domain</em> is implicitly initialized to <code>Audio</code> by default.</p>
<p>Every aspect of Node management can be controlled explicitly for precise computational patterns:</p>
<div class="fragment"><div class="line"><span class="comment">// Direct token processing registration</span></div>
<div class="line">node_manager-&gt;register_token_processor(</div>
<div class="line">    Nodes::ProcessingToken::CUSTOM_RATE,</div>
<div class="line">    [](std::span&lt;RootNode*&gt; roots) {</div>
<div class="line">        <span class="comment">// Custom processing logic for all CUSTOM_RATE nodes</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>* root : roots) {</div>
<div class="line">            root-&gt;process_custom_algorithm();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Manual channel mask management</span></div>
<div class="line">node_manager-&gt;set_channel_mask(custom_node, 0b0110);  <span class="comment">// Channels 1 and 2</span></div>
<div class="line">node_manager-&gt;unset_channel_mask(custom_node, 0b0010); <span class="comment">// Remove channel 1</span></div>
</div><!-- fragment --><p>The control is not just limited <code>NodeGraphManager</code> internals. It is possible to replace the Engine's default node graph manager. <code>get_context()-&gt;get_node_graph_manger() = std::make_shared&lt;Nodes::NodeGraphManager&gt;(args)</code></p>
<h3><a class="anchor" id="autotoc_md231"></a>
RootNode</h3>
<p>When a node is registered to a channel in NodeGraphManger, it is being added to a <code>RootNode</code>. There is only one root node per processing token per channel as it acts as the central registry and lock-free processing stage manager for nodes.</p>
<p>RootNode exposes <code>process_sample()</code> and <code>process_batch(num_samples)</code> which can be called externally. The process callback checks channel registration-processing state of each node, handles processing of each node, requests node state reset for the channel RootNode is operating on and sums all samples.</p>
<p><code>RootNode</code> itself does not operate based on <code>ProcessingTokens</code>, but one is required at construction to facilitate Engine integration. When <code>NodeGraphManager</code> is initialized by the Engine, it automatically sets up RootNodes based on Token and number of channels.</p>
<p>Root Nodes can be used outside of the channel context (or outside of NodeGraphManger context -&gt; Engine Context), as RootNode still provides the most optimal and lock-free way of coordinating process() of multiple nodes.</p>
<p>Use <code>RootNode::register_node(shared_ptr node)</code> to add a node to Root. The registration triggers a guarded atomic operation that checks for current processing state, and adds the node only when it is safe. <code>RootNode::unregister_node</code> behaves the same for removing a node.</p>
<p><em>Note:</em> As <code>RootNode</code> only handles its own graph, it is unaware of registration across channels beyond processing state check. So, adding or removing from root does not update the channel registration status (bitmask) of the node.</p>
<h3><a class="anchor" id="autotoc_md232"></a>
Direct Node Management</h3>
<p>Nodes need not be added to <code>RootNode</code> or <code>NodeGraphManager</code> to enable processing. Calling <code>node-&gt;process_sample()</code> or <code>node-&gt;process_batch(num_samples)</code> evaluates the same as any automated procedure.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> pulse = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a505c21d622a701dd6f2bc18962e8e45b.html#a505c21d622a701dd6f2bc18962e8e45b">Impulse</a>(200.f);</div>
<div class="line"><span class="comment">// Process a node once every 2 seconds</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(2, [pulse](){</div>
<div class="line">    pulse-&gt;process_sample();</div>
<div class="line">});</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a505c21d622a701dd6f2bc18962e8e45b_html_a505c21d622a701dd6f2bc18962e8e45b"><div class="ttname"><a href="classMayaFlux_1_1Creator_a505c21d622a701dd6f2bc18962e8e45b.html#a505c21d622a701dd6f2bc18962e8e45b">MayaFlux::Creator::Impulse</a></div><div class="ttdeci">auto Impulse(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Impulse &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a0b2f122006fb411804adab9baa87647d_html_a0b2f122006fb411804adab9baa87647d"><div class="ttname"><a href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a></div><div class="ttdeci">void schedule_metro(double interval_seconds, std::function&lt; void()&gt; callback, std::string name)</div><div class="ttdoc">Creates a metronome task and addes it to the default scheduler list for evaluation.</div><div class="ttdef"><b>Definition</b> <a href="Chronie_8cpp_source.html#l00041">Chronie.cpp:41</a></div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md233"></a>
Chaining</h4>
<p>The examples shown previously <code>node1 &gt;&gt; node2</code> or <code>node1 * node2</code> are fluent methods for chaining, and Engine registration occurs implicitly.</p>
<p>The first example is facilitated using a type of node called <code>ChainNode</code>. When using <code>&gt;&gt;</code> overload, <code>ChainNode::initialize()</code> is called which registers the nodes with Engine methods.</p>
<p>The second example creates a type of node called <code>BinaryOpNode</code> that handles a binary operation on the node's output as registered by a callback handle. And like <code>ChainNode</code>, the fluent <code>* or +</code> calls <code>BinaryOpNode::initialize()</code> for engine registration</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> pulse = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a505c21d622a701dd6f2bc18962e8e45b.html#a505c21d622a701dd6f2bc18962e8e45b">Impulse</a>(20.f);</div>
<div class="line"><span class="keyword">auto</span> wave = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(880.f);</div>
<div class="line"><span class="comment">// No engine registration</span></div>
<div class="line"><span class="keyword">auto</span> chain_node = std::make_shared&lt;Nodes::ChainNode&gt;(pulse, wave);</div>
<div class="line"><span class="comment">// Processes both nodes using sequence combination logic</span></div>
<div class="line">chain_node-&gt;process_sample();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Self initialized binary operation node with custom operation logic</span></div>
<div class="line"><span class="comment">// No engine registration</span></div>
<div class="line"><span class="keyword">auto</span> bin_op_node = std::make_shared&lt;Nodes::BinaryOpNode&gt;(pulse, wave, [&amp;](<span class="keywordtype">double</span> v1, <span class="keywordtype">double</span> v2){</div>
<div class="line">    v1 *= v2;</div>
<div class="line">    <span class="keywordflow">return</span> sqrt(v1 + v2);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// processes both nodes and applies operation</span></div>
<div class="line">bin_op_node-&gt;process_sample()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md234"></a>
Buffers</h2>
<p>Similar to <code>NodeGraphManager</code>, <em>Engine</em> also handles lifecyle and visibility management of buffers via <code>BufferManager</code>. The role of the buffer manger is to:</p>
<ul>
<li>register buffers to specific tokens and channels</li>
<li>handle input buffers from hardware backend</li>
<li>handle processing sync, chaining and concurrency</li>
<li>Handle data exchange between channels</li>
<li>Handle normalization and final processes</li>
</ul>
<h3><a class="anchor" id="autotoc_md235"></a>
BufferManager</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> temporal_buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c.html#a9fa2fd237baef3835e5d987262293c2c">AudioBuffer</a>()[0] | Parallel;        <span class="comment">// Automatic AUDIO_PARALLEL configuration</span></div>
<div class="line"><span class="keyword">auto</span> feedback_buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe.html#ab85cfd01b90a6a4684925d773afaf2fe">FeedbackBuffer</a>(0.7f).domain(Audio).channel(0);   <span class="comment">// Auto-assigned processing characteristics</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> wave = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>();</div>
<div class="line"><span class="keyword">auto</span> Node_buffer = MayaFlux::create_buffer&lt;Buffers::NodeBuffer&gt;(0, 512, wave); <span class="comment">// Implicitly added to engine audio domain</span></div>
<div class="line"><span class="keyword">auto</span> proc = MayaFlux::create_processor&lt;Buffers::SoundStreamWriter&gt;(temporal_buffer); <span class="comment">// Automatic process registration</span></div>
<div class="line">get_buffer_manger()-&gt;supply_buffer_to(temporal_buffer, 1); <span class="comment">// Automatically send buffer output to channel 1 of audio domain</span></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c_html_a9fa2fd237baef3835e5d987262293c2c"><div class="ttname"><a href="classMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c.html#a9fa2fd237baef3835e5d987262293c2c">MayaFlux::Creator::AudioBuffer</a></div><div class="ttdeci">auto AudioBuffer(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Buffers::AudioBuffer &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00210">Creator.hpp:210</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe_html_ab85cfd01b90a6a4684925d773afaf2fe"><div class="ttname"><a href="classMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe.html#ab85cfd01b90a6a4684925d773afaf2fe">MayaFlux::Creator::FeedbackBuffer</a></div><div class="ttdeci">auto FeedbackBuffer(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Buffers::FeedbackBuffer &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00210">Creator.hpp:210</a></div></div>
</div><!-- fragment --><p>When using fluent structure <code>vega.AudioBuffer[0] | Parallel</code>, the instruction is to create <code>AudioBuffer</code> -&gt; set it to channel 0, get default buffer manager from engine -&gt; register to <code>AUDIO_PARALLEL</code> token.</p>
<p>Using <code><a class="el" href="namespaceMayaFlux_ac734347fdb4e8e30e91ba79308e18d21.html#ac734347fdb4e8e30e91ba79308e18d21" title="creates a new buffer of the specified type and registers it">MayaFlux::create_buffer</a></code> or <code>::create</code>_any_buffer_namespace_method, it internally evaluates to creating the specified entity and handling default registration procedure with <code>Engine</code> controlled <code>BufferManager</code>.</p>
<p>Direct creation methods for the above:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> manager = <a class="code hl_function" href="namespaceMayaFlux_ab62f030499d58eb3e1d5c43ca3bc230e.html#ab62f030499d58eb3e1d5c43ca3bc230e">MayaFlux::get_buffer_manager</a>();</div>
<div class="line">manager-&gt;add_audio_buffer(buffer, ProcessingToken::CUSTOM, 0);</div>
<div class="line">manager-&gt;create_buffer&lt;NodeBuffer&gt;(ProcessingToken::AUDIO_BACKEND, 1, 512, wave);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> proc = std::make_shared&lt;StreamProcessor&gt;(temporal_buffer);</div>
<div class="line">manager-&gt;add_processor(proc, temporal_buffer);</div>
<div class="line">manager-&gt;supply_buffer_to(temporal_buffer, ProcessingToken::GPU_BACKEND, 1);</div>
<div class="ttc" id="anamespaceMayaFlux_ab62f030499d58eb3e1d5c43ca3bc230e_html_ab62f030499d58eb3e1d5c43ca3bc230e"><div class="ttname"><a href="namespaceMayaFlux_ab62f030499d58eb3e1d5c43ca3bc230e.html#ab62f030499d58eb3e1d5c43ca3bc230e">MayaFlux::get_buffer_manager</a></div><div class="ttdeci">std::shared_ptr&lt; Buffers::BufferManager &gt; get_buffer_manager()</div><div class="ttdoc">Gets the buffer manager from the default engine.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00131">Graph.cpp:131</a></div></div>
</div><!-- fragment --><p>Much like <code>NodeGraphManager</code>, it is possible to create custom processing functions</p>
<div class="fragment"><div class="line">manager-&gt;register_token_processor(ProcessingToken::CUSTOM, (std::vector&lt;std::shared_ptr&lt;RootAudioBuffer&gt;&gt; buffers){</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; buffer: buffers) {</div>
<div class="line">        buffer-&gt;process_default();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; child : buffer-&gt;get_child_buffers()) {</div>
<div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> processing_chain = child-&gt;get_processing_chain()) {</div>
<div class="line">                <span class="keywordflow">if</span> (child-&gt;has_data_for_cycle()) {</div>
<div class="line">                    processing_chain-&gt;process(child);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md236"></a>
RootBuffer</h3>
<p>Similar to <code>RootNode</code> in nodes, when adding a buffer to a channel in <code>BufferManager</code>, it is added to that channel's <code>RootBuffer</code>. As this document focuses on audio, <code>RootAudioBuffer</code> will be used as the exploration point.</p>
<p>When <code>BufferManager</code> is initialized, it automatically creates one <code>RootAudioBuffer</code> per audio channel per token. <code>RootAudioBuffer</code> works much the same way as <code>RootNode</code> where:</p>
<ul>
<li>It serves as the central registry of buffers, their processors and their chained processors, per channel.</li>
<li>It is responsible for processing the default processors of all registered buffers and their processing chains</li>
<li>It handles accumulation of the processed output of all registered buffers</li>
<li>It mixes any node output registered to that specific channel</li>
<li>It handles normalization, applying limiter algorithm and clipping bounds of the final output</li>
</ul>
<p>Buffers can be directly added to a <code>RoodAudioBuffer</code> via <code>manager-&gt;get_root_audio_buffer(token, channel)-&gt;add_child_buffer(buffer)</code>. Similar to <code>RootNode</code>, a buffer is registered only when it is safe.</p>
<p>The default processor of the <code>RootAudioBuffer</code> handles most of the features listed above, whereas the <code>FinalProcessor</code> of handles limiting and normalizing.</p>
<h3><a class="anchor" id="autotoc_md237"></a>
Direct buffer management and processing</h3>
<p>Buffers and Processors can exist outside of the <code>BufferManager</code> context. <code>Buffer</code> is an interface class that <code>AudioBuffer</code> inherits from. <code>auto buffer = std::make_shared&lt;AudioBuffer&gt;(0, 512);</code></p>
<p>The only default property of concern is <code>default_processor</code>, which was introduced in the previous document. But that can be overridden with <code>AudioBuffer::set_default_processor()</code></p>
<p>Buffers also accept a <code>BufferProcessingChain</code> that allows attaching a series of <code>BufferProcessors</code> that evaluate in order of processor registration;</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> proc = std::make_shared&lt;FeedbackProcessor&gt;)();</div>
<div class="line">buffer-&gt;set_default_processor(proc);</div>
<div class="line"><span class="comment">// Same processor for multiple buffers</span></div>
<div class="line">buf2-&gt;set_default_processor(proc);</div>
<div class="line">buffer-&gt;set_processing_chain(processing_chain);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Process default and after 2 seconds process chain</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a44556db6c9a1fd8493244b1e6b30e443.html#a44556db6c9a1fd8493244b1e6b30e443">MayaFlux::schedule_sequence</a>({</div>
<div class="line">    {2, [buffer](){</div>
<div class="line">       buffer-&gt;process_default();</div>
<div class="line">    }},</div>
<div class="line">    {3, [buffer, processing_chain](){</div>
<div class="line">       processing_chain-&gt;process(buffer);</div>
<div class="line">    }},</div>
<div class="line">    {1, [buf2, processing_chain](){</div>
<div class="line">       <span class="comment">// Same processing chain can process multiple buffers in any order</span></div>
<div class="line">       processing_chain-&gt;process(buf2);</div>
<div class="line">    }}</div>
<div class="line">});</div>
<div class="ttc" id="anamespaceMayaFlux_a44556db6c9a1fd8493244b1e6b30e443_html_a44556db6c9a1fd8493244b1e6b30e443"><div class="ttname"><a href="namespaceMayaFlux_a44556db6c9a1fd8493244b1e6b30e443.html#a44556db6c9a1fd8493244b1e6b30e443">MayaFlux::schedule_sequence</a></div><div class="ttdeci">void schedule_sequence(std::vector&lt; std::pair&lt; double, std::function&lt; void()&gt; &gt; &gt; seq, std::string name)</div><div class="ttdoc">Creates a sequence task that calls functions at specified times and addes it to the default scheduler...</div><div class="ttdef"><b>Definition</b> <a href="Chronie_8cpp_source.html#l00057">Chronie.cpp:57</a></div></div>
</div><!-- fragment --><p>Sharing data between buffers can still be accommodated outside of <code>BufferManager</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> feed_buf = std::make_shared&lt;FeedbackBuffer&gt;(0, 512);</div>
<div class="line"><span class="comment">// Creates a clone of the current buffer with different channel ID.</span></div>
<div class="line"><span class="comment">// shares the default processor and the processing chain (evaluated independently without interference)</span></div>
<div class="line"><span class="keyword">auto</span> new_buf = feed_buf-&gt;clone_to(1);</div>
<div class="line"><span class="comment">// Share data between buffers;</span></div>
<div class="line">new_buf-&gt;read_once(feed_buf);</div>
</div><!-- fragment --><p>The methods for extending processors themselves was introduced in the previous document, so its skipped here.</p>
<h2><a class="anchor" id="autotoc_md238"></a>
Coroutines</h2>
<p>Temporal coordination in <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> operates through two interconnected namespaces: <code>Vruta</code> (scheduling infrastructure) and <code>Kriya</code> (creative temporal patterns). <code>Engine</code> manages coroutine coordination through <code>TaskScheduler</code>, similar to how it handles nodes and buffers.</p>
<h3><a class="anchor" id="autotoc_md239"></a>
TaskScheduler</h3>
<p>The Engine provides central lifecycle management for coroutines via <code>TaskScheduler</code>, which coordinates temporal processing across different domains</p>
<div class="fragment"><div class="line"><span class="comment">// Fluent API - Engine handles domain assignment and task registration</span></div>
<div class="line"><span class="keyword">auto</span> shape_node = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>({0.1, 0.5, 2.f});</div>
<div class="line"><span class="keyword">auto</span> coordination_routine = shape_node &gt;&gt; Time(2.f) | Domain::AUDIO;  <span class="comment">// Automatic temporal domain assignment</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// API Wrappers - Engine manages task registration and token assignment</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(2.0, []() {</div>
<div class="line">    modulate_filter_cutoff();</div>
<div class="line">}, <span class="stringliteral">&quot;main_clock&quot;</span>);  <span class="comment">// Auto-registered to default SAMPLE_ACCURATE token</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a870a8536c64a612c813800c78068a986.html#a870a8536c64a612c813800c78068a986">MayaFlux::schedule_pattern</a>([](uint64_t beat) {</div>
<div class="line">    <span class="keywordflow">return</span> beat % 8 == 0;  <span class="comment">// Every 8th beat</span></div>
<div class="line">}, []() {</div>
<div class="line">    change_distribution();</div>
<div class="line">}, 1.0, <span class="stringliteral">&quot;pattern_trigger&quot;</span>);  <span class="comment">// Auto-assigned timing characteristics</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Engine handles cross-domain coordination</span></div>
<div class="line"><span class="keyword">auto</span> event_chain = MayaFlux::create_event_chain()</div>
<div class="line">    .then([]() { start_clock(); }, 0.0)</div>
<div class="line">    .then([]() { trigger_buffer_copy(); }, 0.1)</div>
<div class="line">    .then([]() { start_input_capture(); }, 0.5);</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7_html_a433b0c2da4871dc08e049d5ac64041b7"><div class="ttname"><a href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">MayaFlux::Creator::Polynomial</a></div><div class="ttdeci">auto Polynomial(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Polynomial &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a870a8536c64a612c813800c78068a986_html_a870a8536c64a612c813800c78068a986"><div class="ttname"><a href="namespaceMayaFlux_a870a8536c64a612c813800c78068a986.html#a870a8536c64a612c813800c78068a986">MayaFlux::schedule_pattern</a></div><div class="ttdeci">void schedule_pattern(std::function&lt; std::any(uint64_t)&gt; pattern_func, std::function&lt; void(std::any)&gt; callback, double interval_seconds, std::string name)</div><div class="ttdoc">Schedules a pattern generator that produces values based on a pattern function and addes it to the de...</div><div class="ttdef"><b>Definition</b> <a href="Chronie_8cpp_source.html#l00077">Chronie.cpp:77</a></div></div>
</div><!-- fragment --><p><code>TaskScheduler</code>'s responsibilities:</p>
<ul>
<li>Assigns processing tokens based on temporal precision requirements</li>
<li>Registers coroutines with appropriate domain clocks (SampleClock, FrameClock, etc.)</li>
<li>Manages task hierarchies across different processing tokens</li>
<li>Coordinates timing and synchronization across multiple temporal domains</li>
<li>Allows safe access to data stored in coroutine frame</li>
<li>Exposes control over coroutine state schedule.</li>
</ul>
<p>When using <code><a class="el" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d" title="Creates a metronome task and addes it to the default scheduler list for evaluation.">MayaFlux::schedule_metro</a></code>, using internal awaiter <code>SampleDelay</code> it constructs a <code>Vruta::SoundRoutine</code> frame -&gt; store it in a shared_ptr, calls <code>TaskScheduler::add_task</code> which extracts token based on awaiter and adds it to the graph.</p>
<p>When using temporal fluent operations like <code>node &gt;&gt; Time(2.f) | Audio</code>, the instruction creates a coroutine -&gt; gets default <code>TaskScheduler</code> from engine -&gt; registers it for the appropriate domain -&gt; implicitly creates <code>Kriya::NodeTimer</code> and registers one-shot time operation;</p>
<h3><a class="anchor" id="autotoc_md240"></a>
Kriya</h3>
<p><code>Kriya</code> namespaces contains a variety of coroutine designs for fluent and expressive usage of coroutines, beyond simple timing orchestration.</p>
<p><code>Kriya::metro</code>, <code>Kriya::schedule</code>, <code>Kriya::pattern</code> and <code>Kriya::line</code> have already been introduced previously, which need not be created using API wrappers such as <code><a class="el" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d" title="Creates a metronome task and addes it to the default scheduler list for evaluation.">MayaFlux::schedule_metro</a></code>.</p>
<p>However, unlike <code>Nodes</code> and <code>Buffers</code> they have no <code>process</code> callback, their procedure and state management are orchestrated by internal clock mechanism (Read, for more information).</p>
<p><code>Kriya</code> also exposes one-shot timers, timed events, timed data capture mechanisms</p>
<div class="fragment"><div class="line"><span class="comment">// Create a timer</span></div>
<div class="line">Timer timer(*scheduler);</div>
<div class="line"><span class="comment">// Schedule a callback to execute after 2 seconds</span></div>
<div class="line">timer.schedule(2.0, []() {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Two seconds have passed!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a timed action</span></div>
<div class="line">TimedAction action(*scheduler);</div>
<div class="line"><span class="comment">// Execute an action that lasts for 3 seconds</span></div>
<div class="line">action.execute(</div>
<div class="line">    []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Starting action&quot;</span> &lt;&lt; std::endl; },</div>
<div class="line">    []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Ending action&quot;</span> &lt;&lt; std::endl; },</div>
<div class="line">    3.0</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a node timer</span></div>
<div class="line">NodeTimer timer(*scheduler, *graph_manager);</div>
<div class="line">timer.play_for(process_node, 2.0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Automate buffer operations by capturing data</span></div>
<div class="line"><span class="keyword">auto</span> capture_op = CaptureBuilder(audio_buffer)</div>
<div class="line">    .for_cycles(10)</div>
<div class="line">    .with_window(512, 0.5f)</div>
<div class="line">    .on_data_ready([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; data, uint32_t cycle) {</div>
<div class="line">        process_windowed_data(data, cycle);</div>
<div class="line">    })</div>
<div class="line">    .with_tag(<span class="stringliteral">&quot;spectral_analysis&quot;</span>);</div>
<div class="line"> </div>
<div class="line">pipeline &gt;&gt; capture_op &gt;&gt; route_to_container(output_stream);</div>
</div><!-- fragment --><p>Each of these operations allow expressive routing of not just data but also procedure. And the nature <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>'s coroutine frame allows wrapping any coroutine inside recursive coroutines. Each of the methods already wrap different coroutines based on the chained operation</p>
<h3><a class="anchor" id="autotoc_md241"></a>
Clock Systems</h3>
<p>When a coroutine is registered to a domain in TaskScheduler, it operates within that domain's <code>Clock</code> system. The actual clock implementations are:</p>
<div class="fragment"><div class="line"><span class="comment">// TaskScheduler automatically creates clocks based on processing tokens</span></div>
<div class="line"><span class="keyword">auto</span> scheduler = <a class="code hl_function" href="namespaceMayaFlux_aebfa66114d29585723a0c38dfe4c75b9.html#aebfa66114d29585723a0c38dfe4c75b9">MayaFlux::get_scheduler</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access domain-specific clocks</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; sample_clock = scheduler-&gt;get_clock(Vruta::ProcessingToken::SAMPLE_ACCURATE);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; frame_clock = scheduler-&gt;get_clock(Vruta::ProcessingToken::FRAME_ACCURATE);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Clock operations</span></div>
<div class="line"><span class="keyword">auto</span> current_sample = sample_clock.current_position();</div>
<div class="line"><span class="keyword">auto</span> current_time = sample_clock.current_time();</div>
<div class="line"><span class="keyword">auto</span> sample_rate = sample_clock.rate();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Manual temporal advancement through scheduler</span></div>
<div class="line">scheduler-&gt;process_token(Vruta::ProcessingToken::SAMPLE_ACCURATE, 1024);</div>
<div class="ttc" id="anamespaceMayaFlux_aebfa66114d29585723a0c38dfe4c75b9_html_aebfa66114d29585723a0c38dfe4c75b9"><div class="ttname"><a href="namespaceMayaFlux_aebfa66114d29585723a0c38dfe4c75b9.html#aebfa66114d29585723a0c38dfe4c75b9">MayaFlux::get_scheduler</a></div><div class="ttdeci">std::shared_ptr&lt; Vruta::TaskScheduler &gt; get_scheduler()</div><div class="ttdoc">Gets the task scheduler from the default engine.</div><div class="ttdef"><b>Definition</b> <a href="Chronie_8cpp_source.html#l00020">Chronie.cpp:20</a></div></div>
</div><!-- fragment --><p>Clock systems expose <code>tick(units)</code>, <code>current_position()</code>, <code>current_time()</code>, <code>rate()</code>, and <code>reset()</code>. The TaskScheduler's <code>process_token()</code> method handles temporal state advancement, processing unit calculation, and coroutine suspension/resumption coordination.</p>
<p>Clocks are automatically created when a processing token is first used through the <code>ensure_domain()</code> method:</p>
<div class="fragment"><div class="line"><span class="comment">// Custom scheduler with explicit rates</span></div>
<div class="line"><span class="keyword">auto</span> scheduler = std::make_shared&lt;Vruta::TaskScheduler&gt;(48000, 60);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Clocks created automatically when tokens are used</span></div>
<div class="line">scheduler-&gt;process_token(Vruta::ProcessingToken::SAMPLE_ACCURATE, 1024);</div>
<div class="line">scheduler-&gt;process_token(Vruta::ProcessingToken::FRAME_ACCURATE, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access timing information</span></div>
<div class="line"><span class="keyword">auto</span> sample_units = scheduler-&gt;seconds_to_samples(2.0);  <span class="comment">// Convert to samples</span></div>
<div class="line"><span class="keyword">auto</span> current_units = scheduler-&gt;current_units(Vruta::ProcessingToken::SAMPLE_ACCURATE);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md242"></a>
Direct Coroutine Management</h3>
<h4><a class="anchor" id="autotoc_md243"></a>
Self-managed SoundRoutine Creation</h4>
<p>Coroutines can be created directly using the <code>SoundRoutine</code> API and managed through the TaskScheduler:</p>
<div class="fragment"><div class="line"><span class="comment">// Create SoundRoutine using API-based awaiters</span></div>
<div class="line"><span class="keyword">auto</span> temporal_pattern = [](Vruta::TaskScheduler&amp; scheduler) -&gt; Vruta::SoundRoutine {</div>
<div class="line">    <span class="keyword">auto</span>&amp; promise = <span class="keyword">co_await</span> Kriya::GetAudioPromise{};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="comment">// Check termination flag set by external control</span></div>
<div class="line">        <span class="keywordflow">if</span> (promise.should_terminate) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Sample-accurate delay</span></div>
<div class="line">        <span class="keyword">co_await</span> Kriya::SampleDelay{scheduler.seconds_to_samples(0.5)};</div>
<div class="line">        pulse_node-&gt;process_sample();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Access and modify promise state</span></div>
<div class="line">        promise.set_state(<span class="stringliteral">&quot;frequency&quot;</span>, 440.0f);</div>
<div class="line">        <span class="keyword">auto</span> current_freq = promise.get_state&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;frequency&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create and manage routine</span></div>
<div class="line"><span class="keyword">auto</span> routine = std::make_shared&lt;Vruta::SoundRoutine&gt;(temporal_pattern(*scheduler));</div>
<div class="line">scheduler-&gt;add_task(routine, <span class="stringliteral">&quot;temporal_pattern&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Manual processing control</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.02, [=]() {</div>
<div class="line">    scheduler-&gt;process_token(Vruta::ProcessingToken::SAMPLE_ACCURATE,</div>
<div class="line">                           scheduler-&gt;seconds_to_samples(0.02));</div>
<div class="line">});</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md244"></a>
API-based Awaiter Patterns</h4>
<p>The actual awaiter implementations available for coroutine control:</p>
<div class="fragment"><div class="line"><span class="comment">// Using pre-built coroutine patterns with API awaiters</span></div>
<div class="line"><span class="keyword">auto</span> metro_routine = [](Vruta::TaskScheduler&amp; scheduler) -&gt; Vruta::SoundRoutine {</div>
<div class="line">    <span class="keyword">auto</span>&amp; promise = <span class="keyword">co_await</span> Kriya::GetAudioPromise{};</div>
<div class="line">    uint64_t interval_samples = scheduler.seconds_to_samples(2.0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="keywordflow">if</span> (promise.should_terminate) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Execute callback</span></div>
<div class="line">        modulate_filter_cutoff();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Wait for next beat</span></div>
<div class="line">        <span class="keyword">co_await</span> Kriya::SampleDelay{interval_samples};</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md245"></a>
Direct Routine Control and State Management</h3>
<div class="fragment"><div class="line"><span class="comment">// Create routine with state management</span></div>
<div class="line"><span class="keyword">auto</span> stateful_routine = [](Vruta::TaskScheduler&amp; scheduler) -&gt; Vruta::SoundRoutine {</div>
<div class="line">    <span class="keyword">auto</span>&amp; promise = <span class="keyword">co_await</span> Kriya::GetAudioPromise{};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize state</span></div>
<div class="line">    promise.set_state(<span class="stringliteral">&quot;amplitude&quot;</span>, 0.8f);</div>
<div class="line">    promise.set_state(<span class="stringliteral">&quot;frequency&quot;</span>, 440.0f);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="keywordflow">if</span> (promise.should_terminate) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Access state</span></div>
<div class="line">        <span class="keyword">auto</span> amplitude = promise.get_state&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;amplitude&quot;</span>);</div>
<div class="line">        <span class="keyword">auto</span> <a class="code hl_variable" href="ResonatorNetwork_8cpp_a4c45cdff103e6644a620ba5061509f22.html#a4c45cdff103e6644a620ba5061509f22">frequency</a> = promise.get_state&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;frequency&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Update processing based on state</span></div>
<div class="line">        sine_node-&gt;set_frequency(*<a class="code hl_variable" href="ResonatorNetwork_8cpp_a4c45cdff103e6644a620ba5061509f22.html#a4c45cdff103e6644a620ba5061509f22">frequency</a>);</div>
<div class="line">        sine_node-&gt;set_amplitude(*amplitude);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">co_await</span> Kriya::SampleDelay{scheduler.seconds_to_samples(0.01)};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// External routine control</span></div>
<div class="line"><span class="keyword">auto</span> routine = std::make_shared&lt;Vruta::SoundRoutine&gt;(stateful_routine(*scheduler));</div>
<div class="line">scheduler-&gt;add_task(routine, <span class="stringliteral">&quot;stateful_process&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update routine parameters externally</span></div>
<div class="line">routine-&gt;update_params(<span class="stringliteral">&quot;amplitude&quot;</span>, 0.5f, <span class="stringliteral">&quot;frequency&quot;</span>, 880.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Control routine lifecycle</span></div>
<div class="line">routine-&gt;set_should_terminate(<span class="keyword">true</span>);  <span class="comment">// Stop routine</span></div>
<div class="line">routine-&gt;restart();                   <span class="comment">// Restart from beginning</span></div>
<div class="ttc" id="aResonatorNetwork_8cpp_a4c45cdff103e6644a620ba5061509f22_html_a4c45cdff103e6644a620ba5061509f22"><div class="ttname"><a href="ResonatorNetwork_8cpp_a4c45cdff103e6644a620ba5061509f22.html#a4c45cdff103e6644a620ba5061509f22">frequency</a></div><div class="ttdeci">double frequency</div><div class="ttdef"><b>Definition</b> <a href="ResonatorNetwork_8cpp_source.html#l00016">ResonatorNetwork.cpp:16</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md246"></a>
Multi-domain Coroutine Coordination</h3>
<div class="fragment"><div class="line"><span class="comment">// Multi-rate coroutine for cross-domain coordination</span></div>
<div class="line"><span class="keyword">auto</span> sync_routine = [](Vruta::TaskScheduler&amp; scheduler) -&gt; Vruta::ComplexRoutine {</div>
<div class="line">    <span class="keyword">auto</span>&amp; promise = <span class="keyword">co_await</span> Kriya::GetAudioPromise{};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="keywordflow">if</span> (promise.should_terminate) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Audio-rate processing</span></div>
<div class="line">        <span class="keyword">co_await</span> Kriya::SampleDelay{scheduler.seconds_to_samples(0.02)};</div>
<div class="line">        process_audio_frame();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Frame-rate processing (when graphics system is ready)</span></div>
<div class="line">        <span class="comment">// co_await Kriya::FrameDelay{1};</span></div>
<div class="line">        <span class="comment">// update_visual_frame();</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Multi-rate delay combining both domains</span></div>
<div class="line">        <span class="keyword">co_await</span> Kriya::MultiRateDelay{</div>
<div class="line">            .samples_to_wait = scheduler.seconds_to_samples(0.1),</div>
<div class="line">            .frames_to_wait = 6  <span class="comment">// ~6 frames at 60fps</span></div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<p>This architecture enables computational thinking as creative expressionâ€”where the choice between automatic coordination and explicit control becomes part of the creative decision-making process.</p>
<p>Domain composition allows creators to think in terms of unified computational environments while maintaining the flexibility to optimize for specific creative requirements.</p>
<p>For advanced and architecture level presentation of the same topic, please refer to <a class="el" href="md_docs_2Advanced__Context__Control.html">Advanced Context Control</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
