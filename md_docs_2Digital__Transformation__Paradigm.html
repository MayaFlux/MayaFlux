<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MayaFlux: Digital Transformation Paradigms: Thinking in Data Flow</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MayaFlux<span id="projectnumber">&#160;0.2.0</span>
   </div>
   <div id="projectbrief">Digital-First Multimedia Processing Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2Digital__Transformation__Paradigm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Digital Transformation Paradigms: Thinking in Data Flow</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md195"></a></p><ul>
<li>Introduction</li>
<li>MayaFlux<ul>
<li>Nodes<ul>
<li>Definitions</li>
<li>Flow logic</li>
<li>Processing as events</li>
</ul>
</li>
<li>Buffers<ul>
<li>Definitions</li>
<li>Processing</li>
<li>Processing chain</li>
<li>Custom processing</li>
</ul>
</li>
<li>Coroutines: Time as a Creative Material<ul>
<li>The Temporal Paradigm</li>
<li>Definitions</li>
<li>Temporal Domains and Coordination</li>
<li>Kriya Temporal Patterns</li>
<li>EventChains and Temporal Composition</li>
<li>Buffer Integration and Capture</li>
</ul>
</li>
<li>Containers<ul>
<li>Data Architecture</li>
<li>Data Modalities and Detection</li>
<li>SoundFileContainer: Foundational Implementation</li>
<li>Region-Based Data Access</li>
<li>RegionGroups and Metadata</li>
</ul>
</li>
</ul>
</li>
<li>Digital Data Flow Architecture%</li>
</ul>
<h1><a class="anchor" id="autotoc_md196"></a>
Introduction</h1>
<p><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> represents a fundamental rethinking of creative computation—moving beyond analog-inspired metaphors and file-based workflows into true digital-first paradigms. Rather than simulating hardware or accommodating legacy constraints, <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> treats data transformation as the primary creative medium.</p>
<p>This shift requires new ways of thinking about creative processes. Instead of "programming" versus "composing," <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> recognizes that data transformation is creative expression. Mathematical relationships become creative decisions, temporal coordination becomes compositional structure, and multi-dimensional data access becomes creative material selection.</p>
<p>Critically, <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> moves beyond the artificial disciplinary separation of audio and visual processing that dominates contemporary creative software. Audio samples at 48 kHz, pixels at 60 Hz, and compute results all flow through identical transformation primitives—because they are all just data. The only meaningful difference is the timing context (domain) in which they're processed. A node that transforms one unit at a time operates identically whether that unit is a float sample, a pixel, or a compute result. A buffer that accumulates moments until release works identically for audio, visual, or spectral data. The paradigms that follow are domain-agnostic by design.</p>
<p>The architecture emerges from four foundational paradigms that work compositionally rather than separately:</p>
<ul>
<li>Nodes: Unit-by-unit transformation moments where information becomes something new</li>
<li>Buffers: Temporal gathering spaces where individual moments accumulate into collective expressions</li>
<li>Coroutines: Time as malleable creative material enabling complex temporal coordination</li>
<li>Containers: Multi-dimensional data structures that treat information as compositional material</li>
</ul>
<p>Each paradigm operates with computational precision while remaining expressively flexible. They compose naturally across audio, visual, and compute domains, creating complex multi-modal creative workflows from simple, well-defined transformation primitives.</p>
<p>This document explores each paradigm through practical examples that demonstrate both their individual capabilities and their compositional relationships across computational domains. The focus remains on digital thinking—embracing computational possibilities that have no analog equivalent, and treating all data (whether it sounds, displays, or computes) through unified transformation infrastructure.</p>
<h1><a class="anchor" id="autotoc_md197"></a>
MayaFlux</h1>
<h2><a class="anchor" id="autotoc_md198"></a>
Nodes</h2>
<p>Nodes represent <em>moments of transformation</em> in the digital reality—points where information becomes something new. Each node processes <em>one unit at a time</em>, creating precise, intentional change in the flow of data.</p>
<p>Think of nodes not as devices or tools, but as <em>creative decisions made manifest</em>. They can craft new information (generators) or reshape existing streams (processors). Any concept that can be expressed as unit-by-unit transformation can become a Node.</p>
<p>Nodes embody mathematical relationships through polynomials, make logical decisions through boolean operations, channel chaos through stochastic patterns, sculpt existing flows through filtering, or manifest familiar synthesis paradigms like sine waves, phasors, and impulses.</p>
<p>The rate of processing i.e how often individual units evaluate and transition to the next—is governed by the concept of <code>Domains</code>. A node can operate in the <code>Audio</code> domain (processing at sample rate), the <code>Graphics</code> domain (processing at frame rate), the <code>Compute</code> domain (processing at GPU compute rate), or <code>Custom</code> domains (user-defined rates). The fundamental transformation logic remains identical; only the timing context.</p>
<h3><a class="anchor" id="autotoc_md199"></a>
Definitions</h3>
<p>Nodes can be defined using the fluent mechanism, API level convenience wrappers or via directly creating a modern c++ shared pointers.</p>
<div class="fragment"><div class="line"><span class="comment">// Fluent</span></div>
<div class="line"><span class="keyword">auto</span> wave = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(440.0f).channel(0) | Audio;</div>
<div class="line"><span class="keyword">auto</span> noise = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">Random</a>(GUASSIAN).domain(Audio)[1];</div>
<div class="line"><span class="keyword">auto</span> texture_distort = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>({0.1, 0.8, 2.0}) | Graphics;</div>
<div class="line"><span class="keyword">auto</span> pulse = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a505c21d622a701dd6f2bc18962e8e45b.html#a505c21d622a701dd6f2bc18962e8e45b">Impulse</a>(2.0) | Audio;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// API Wrappers</span></div>
<div class="line"><span class="keyword">auto</span> envelope = MayaFlux::ceate_node&lt;Shape&gt;(0.0f, 1.0f, 2.5f);</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_aa901a4b0b9f930abe9966d0dd5e779f1.html#aa901a4b0b9f930abe9966d0dd5e779f1">MayaFlux::register_audio_node</a>(envelope, {0, 1});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> random_walk = MayaFlux::create_node&lt;Stochastic&gt;(PERLIN, 0.1f);</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_aa901a4b0b9f930abe9966d0dd5e779f1.html#aa901a4b0b9f930abe9966d0dd5e779f1">MayaFlux::register_audio_node</a>(random_walk, 1);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> logic_gate = MayaFlux::create_node&lt;Logic&gt;(([](<span class="keywordtype">double</span> input) { <span class="keywordflow">return</span> input &gt; 0.5; }));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Direct method</span></div>
<div class="line"><span class="keyword">auto</span> custom_filter = std::make_shared&lt;Nodes::Processor::IIR&gt;(</div>
<div class="line">    std::vector&lt;double&gt;{0.2, 0.4, 0.2},  <span class="comment">// feedforward coefficients</span></div>
<div class="line">    std::vector&lt;double&gt;{1.0, -0.5}       <span class="comment">// feedback coefficients</span></div>
<div class="line">);</div>
<div class="line">custom_filter-&gt;set_input(random_walk);</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a5c92c4d97ecd276a33797057eb8c5906.html#a5c92c4d97ecd276a33797057eb8c5906">get_node_graph_manager</a>()-&gt;add_node_to_root(ProcessingToken::AUDIO_RATE, 0);</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7_html_a433b0c2da4871dc08e049d5ac64041b7"><div class="ttname"><a href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">MayaFlux::Creator::Polynomial</a></div><div class="ttdeci">auto Polynomial(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Polynomial &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a505c21d622a701dd6f2bc18962e8e45b_html_a505c21d622a701dd6f2bc18962e8e45b"><div class="ttname"><a href="classMayaFlux_1_1Creator_a505c21d622a701dd6f2bc18962e8e45b.html#a505c21d622a701dd6f2bc18962e8e45b">MayaFlux::Creator::Impulse</a></div><div class="ttdeci">auto Impulse(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Impulse &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7_html_a8a8d81842f8f6d77789cd3cd199c12e7"><div class="ttname"><a href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">MayaFlux::Creator::Random</a></div><div class="ttdeci">auto Random(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Random &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687_html_ae9b21dfc8a04dd2826b63cda4dae4687"><div class="ttname"><a href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">MayaFlux::Creator::Sine</a></div><div class="ttdeci">auto Sine(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Sine &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a5c92c4d97ecd276a33797057eb8c5906_html_a5c92c4d97ecd276a33797057eb8c5906"><div class="ttname"><a href="namespaceMayaFlux_a5c92c4d97ecd276a33797057eb8c5906.html#a5c92c4d97ecd276a33797057eb8c5906">MayaFlux::get_node_graph_manager</a></div><div class="ttdeci">std::shared_ptr&lt; Nodes::NodeGraphManager &gt; get_node_graph_manager()</div><div class="ttdoc">Gets the node graph manager from the default engine.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00033">Graph.cpp:33</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_aa901a4b0b9f930abe9966d0dd5e779f1_html_aa901a4b0b9f930abe9966d0dd5e779f1"><div class="ttname"><a href="namespaceMayaFlux_aa901a4b0b9f930abe9966d0dd5e779f1.html#aa901a4b0b9f930abe9966d0dd5e779f1">MayaFlux::register_audio_node</a></div><div class="ttdeci">void register_audio_node(const std::shared_ptr&lt; Nodes::Node &gt; &amp;node, uint32_t channel)</div><div class="ttdoc">Adds a node to the root node of a specific channel.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00038">Graph.cpp:38</a></div></div>
</div><!-- fragment --><p>Each path serves different creative moments—fluid thinking, structured creation, or precise manipulation. precise manipulation. The key insight: the node definition syntax is identical across audio, visual, and compute domains; only the semantic content (what the node does) changes.</p>
<h3><a class="anchor" id="autotoc_md200"></a>
Flow logic</h3>
<p>Nodes connect through <code>&gt;&gt;</code> creating <code>streams of transformation</code>. Each connection point represents a decision about how information should evolve. Critically, these streams work across domains:</p>
<div class="fragment"><div class="line">phasor &gt;&gt; noise &gt;&gt; (IIR(sine) * 0.5) + noise | Audio;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cross-domain connection: audio drives visual parameters</span></div>
<div class="line"><span class="keyword">auto</span> audio_envelope = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(1.0f) | Audio;</div>
<div class="line"><span class="keyword">auto</span> visual_scale = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>({0.1, 1.0, 0.5});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Audio tick fires at sample rate, modulating visual node</span></div>
<div class="line">audio_envelope &gt;&gt; (visual_scale * 2.0) &gt;&gt; screen_geometry;</div>
</div><!-- fragment --><p>The flow doesn't just pass data—it creates <em>relationships</em> where each transformation influences and is influenced by its neighbors.</p>
<h3><a class="anchor" id="autotoc_md201"></a>
Processing as events</h3>
<p>Since nodes operate with unit-by-unit precision, they become <code>temporal anchors</code> places where you can attach other creative processes to the exact rhythm of transformation:</p>
<div class="fragment"><div class="line"><span class="comment">// Sync external processes to the pulse of transformation</span></div>
<div class="line"><span class="keyword">auto</span> clock = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a505c21d622a701dd6f2bc18962e8e45b.html#a505c21d622a701dd6f2bc18962e8e45b">Impulse</a>(4.0) | Audio;</div>
<div class="line">clock-&gt;on_tick([](NodeContext&amp; ctx) {</div>
<div class="line">    <span class="comment">// Trigger visual events at 4Hz rhythm</span></div>
<div class="line">    schedule_visual_pulse(ctx.value, ctx.timestamp);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// React to mathematical conditions becoming true</span></div>
<div class="line"><span class="keyword">auto</span> wave = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(0.5f) | Audio;</div>
<div class="line">wave-&gt;on_tick_if([](NodeContext&amp; ctx) {</div>
<div class="line">    <span class="keywordflow">return</span> ctx.value &gt; 0.8;</div>
<div class="line">}, [](NodeContext ctx) {</div>
<div class="line">    <span class="comment">// Musical events triggered by wave peaks</span></div>
<div class="line">    trigger_chain_event_at(ctx.timestamp);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Logic states create temporal regions for other processes</span></div>
<div class="line"><span class="keyword">auto</span> gate = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>([](<span class="keywordtype">double</span> input) { <span class="keywordflow">return</span> input &gt; 0.0; });</div>
<div class="line">gate-&gt;while_true([](NodeContext&amp; ctx) {</div>
<div class="line">    <span class="comment">// Continuous processes that exist only during &quot;true&quot; time</span></div>
<div class="line">    modulate_global_clock(ctx.value * 0.7);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Mathematical relationships become event generators</span></div>
<div class="line"><span class="keyword">auto</span> envelope = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>({1.0, -0.5, 0.1});</div>
<div class="line">envelope-&gt;on_change([](NodeContext&amp; ctx) {</div>
<div class="line">    <span class="comment">// React to any change in polynomial output</span></div>
<div class="line">    update_filter_cutoff(ctx.value * 2000.0 + 200.0);</div>
<div class="line">});</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef_html_ad172557289ef9c249a3cb0a3935bd1ef"><div class="ttname"><a href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">MayaFlux::Creator::Logic</a></div><div class="ttdeci">auto Logic(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Logic &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a206db47ce24592b667c583d0047f745b_html_a206db47ce24592b667c583d0047f745b"><div class="ttname"><a href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">MayaFlux::vega</a></div><div class="ttdeci">Creator vega</div><div class="ttdoc">Global Creator instance for creating nodes, buffers, and containers.</div><div class="ttdef"><b>Definition</b> <a href="Creator_8cpp_source.html#l00018">Creator.cpp:18</a></div></div>
</div><!-- fragment --><p>This turns <code>computational precision into creative opportunity</code> every processing moment becomes a potential point of creative intervention.</p>
<h2><a class="anchor" id="autotoc_md202"></a>
Buffers</h2>
<p>Buffers are temporal gatherers – they don't store data, they accumulate moments until they reach fullness, then release their contents and await the next collection.</p>
<p>Think of them as breathing spaces in the data flow, where individual units gather into collective expressions. Unlike nodes that transform unit-by-unit, buffers work with accumulated time – they collect until they have enough information to pass along as a temporal block.</p>
<p>A buffer's life cycle is simple: gather → release → await → gather. This cycle creates the temporal chunking that makes certain kinds of transformation possible - operations that need to see patterns across time rather than individual moments. This lifecycle is identical whether the buffer collects audio samples, pixels, or compute results.</p>
<h3><a class="anchor" id="autotoc_md203"></a>
Definitions</h3>
<p>The <em>transient collectors</em> paradigm of buffers allow them to work with more than just <code>float</code> or <code>long float</code> (double) data types. They can work with images, textures, text (string) basically any simple data type accommodated by default in C++. However, we will focus only on AudioBuffers in this document.</p>
<p>The default audio buffer simply creates a buffer that works with high precision decimals or <code>doubles</code>. <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> also provides other buffer types derived from <code>AudioBuffers</code> And much like nodes, buffers have multiple ways of creating them.</p>
<div class="fragment"><div class="line"><span class="comment">// Fluent</span></div>
<div class="line"><span class="keyword">auto</span> audio_buf = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c.html#a9fa2fd237baef3835e5d987262293c2c">AudioBuffer</a>()[1] | Audio;</div>
<div class="line"><span class="keyword">auto</span> vk_buf = vega.VKBUffer(64, ::Usage::VERTEX,</div>
<div class="line">                              ::DataModality::VERTEX_COLORS_RGBA) | Graphics;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Convenience API Sound</span></div>
<div class="line"><span class="keyword">auto</span> wave = MayaFlux::create_node&lt;Sine&gt;();</div>
<div class="line"><span class="keyword">auto</span> node_buffer = MayaFlux::create_buffer&lt;NodeBuffer&gt;(0, 512, sine);</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a93ff247bbf5208e7b89bd81b09139b5c.html#a93ff247bbf5208e7b89bd81b09139b5c">MayaFlux::register_audio_buffer</a>(node_buffer, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Convenience API Graphics</span></div>
<div class="line"><span class="keyword">auto</span> logic = MayaFlux::create_node&lt;Logic&gt;();</div>
<div class="line"><span class="keyword">auto</span> update = MayaFlux::create_processor&lt;TextureBindingsProcessor&gt;(vk_buf);</div>
<div class="line">update-&gt;bind_texture_node(<span class="stringliteral">&quot;toggle_noise_reflection&quot;</span>, update, vk_buf);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Explicit</span></div>
<div class="line"><span class="keyword">auto</span> stream_sources = std::make_shared&lt;MayaFlux::Kakshya::DynamicStreamSource&gt;(48000, 2);</div>
<div class="line"><span class="keyword">auto</span> stream_buf = std::make_shared&lt;MayaFlux::Buffers::SoundContainerBuffer&gt;(0, 512, stream_sources);</div>
<div class="line">buffer_manager-&gt;add_buffer(stream_buf, ProcessingToken::AUDIO_PARALLEL, 0);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> staging = std::make_shared&lt;MayaFlux::Buffers::VKBuffer&gt;(0, Usage::STAGING, DataModality::UNKNOWN);</div>
<div class="line">buffer_manager-&gt;add_buffer(staging, ProcessingToken::GRAPHICS_BACKEND);</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c_html_a9fa2fd237baef3835e5d987262293c2c"><div class="ttname"><a href="classMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c.html#a9fa2fd237baef3835e5d987262293c2c">MayaFlux::Creator::AudioBuffer</a></div><div class="ttdeci">auto AudioBuffer(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Buffers::AudioBuffer &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00210">Creator.hpp:210</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a93ff247bbf5208e7b89bd81b09139b5c_html_a93ff247bbf5208e7b89bd81b09139b5c"><div class="ttname"><a href="namespaceMayaFlux_a93ff247bbf5208e7b89bd81b09139b5c.html#a93ff247bbf5208e7b89bd81b09139b5c">MayaFlux::register_audio_buffer</a></div><div class="ttdeci">void register_audio_buffer(const std::shared_ptr&lt; Buffers::AudioBuffer &gt; &amp;buffer, uint32_t channel)</div><div class="ttdoc">Registers an AudioBuffer with the default engine's buffer manager.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00213">Graph.cpp:213</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md204"></a>
Processing</h3>
<p>Unlike nodes that are essentially mathematical expressions evaluated unit by unit, buffers are simply temporal accumulators. However, there is little expressive or computational value in simply <em>holding on</em> to data for a short period, do nothing, and pass it along.</p>
<p>Buffers work with <code>BufferProcessors</code> that are attached to them to handle operations on the accumulated data.</p>
<p>It might help to visualize buffers as facilitators where processing <em>happens</em> to them, in place of them handling any transformations themselves.</p>
<p>Every buffer carries a default processor—its natural way of handling accumulated data. While this is an external tool applied to the buffer; it is the buffer's inherent behavior for each cycle The <code>NodeBuffer</code> from earlier example uses <code>NodeProcessor</code> that evaluates the specified node unit by unit, until buffer size is complete. The stream buffer has a default processor <code>AccessProcessor</code> that "acquires" concurrent 512 samples from the stream source container The basic audio buffer has no default processor but it exposes methods to attach one.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c.html#a9fa2fd237baef3835e5d987262293c2c">AudioBuffer</a>();</div>
<div class="line">buffer-&gt;set_default_processor(FeedbackProcessor);</div>
</div><!-- fragment --><p>The default processor defines the buffer's natural expression—what it does with accumulated data when left to its own behavior, or how it accumulates data to begin with.</p>
<h3><a class="anchor" id="autotoc_md205"></a>
Processing chain</h3>
<p><code>BufferProcessors</code> are standalone features that require a buffer to process, but they are not specific to a single buffer. Each processor can be attached to multiple buffers, be it the same instance of the processor, or several instances of the same class to different buffers. More information on buffers and processors can be found <em>here</em></p>
<p>On the other hand, buffers themselves accommodate multiple processors using <code>BufferProcessingChain</code></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c.html#a9fa2fd237baef3835e5d987262293c2c">AudioBuffer</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> feedback = MayaFlux::create_processor&lt;FeedbackProcessor&gt;(buffer);</div>
<div class="line"><span class="keyword">auto</span> node = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keyword">auto</span> x) {<span class="keywordflow">return</span> x *= (sqrt(x));});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> poly_processor = MayaFlux::create_processor&lt;PolynomialProcessor&gt;(buffer, node);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> chain = <a class="code hl_function" href="namespaceMayaFlux_a2b1e7c1f92d6a0a70984440e9f32081c.html#a2b1e7c1f92d6a0a70984440e9f32081c">MayaFlux::create_processing_chain</a>();</div>
<div class="line"> </div>
<div class="line">chain-&gt;add_processor(poly_processor);</div>
<div class="line">chain-&gt;add_processor(feedback);</div>
<div class="line"> </div>
<div class="line">buffer-&gt;set_processing_chain(chain);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Explicit</span></div>
<div class="line"><span class="keyword">auto</span> upload = std::make_shared&lt;MayaFlux::Buffers::BufferUploadProcessor&gt;();</div>
<div class="line">upload-&gt;configure_source(staging, vk_buf);</div>
<div class="line"><span class="keyword">auto</span> g_chain = std::make_shared&lt;MayaFlux::Buffers::BufferProcessingChain&gt;();</div>
<div class="line">g_chain-&gt;add_processor(upload, vk_buf);</div>
<div class="line">vk_buf-&gt;set_processing_chain(g_chain);</div>
<div class="ttc" id="anamespaceMayaFlux_a2b1e7c1f92d6a0a70984440e9f32081c_html_a2b1e7c1f92d6a0a70984440e9f32081c"><div class="ttname"><a href="namespaceMayaFlux_a2b1e7c1f92d6a0a70984440e9f32081c.html#a2b1e7c1f92d6a0a70984440e9f32081c">MayaFlux::create_processing_chain</a></div><div class="ttdeci">std::shared_ptr&lt; Buffers::BufferProcessingChain &gt; create_processing_chain()</div><div class="ttdoc">Creates a new processing chain for the default engine.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00151">Graph.cpp:151</a></div></div>
</div><!-- fragment --><p>It is important to note that the order of execution of processing chains are sequential, determined by the order of registration.</p>
<h3><a class="anchor" id="autotoc_md206"></a>
Custom processing</h3>
<p>Apart from the available list of default processors, it is very trivial to create your own processors.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_processor : <span class="keyword">public</span> BufferProcessor {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Processing function is what gets evaluated each buffer cycle</span></div>
<div class="line">    <span class="keywordtype">void</span> processing_function(<span class="keyword">const</span> std::shared_ptr&lt;Buffer&gt;&amp; buffer)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keyword">auto</span>&amp; data = buffer-&gt;get_data();</div>
<div class="line">        <span class="comment">// do something here to data;</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// you can also override init and end behaviours</span></div>
<div class="line">    <span class="keywordtype">void</span> on_attach(std::shared_ptr&lt;Buffer&gt; buffer)<span class="keyword"> override </span>{}</div>
<div class="line">    <span class="keywordtype">void</span> on_detach(std::shared_ptr&lt;Buffer&gt; buffer)<span class="keyword"> override </span>{}</div>
<div class="line">};</div>
</div><!-- fragment --><p>If you are unfamiliar with creating C++ classes or your overall exposure to programming does not yet accommodate such explicit creation paradigm, <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> offers several convenience methods to achieve the same.</p>
<ol type="1">
<li><p class="startli">Quick processors</p>
<p class="startli">A quick process can by any function that accepts a buffer as input, and applies any desired operation on the buffer's data. These quick processes allow <em>using</em> any previously available value/data inside the function. The specifics of how they work will require an understanding of lamdas in programming, but suffice to say that […] these braces allow you to mention any data you want to use;</p>
<p class="startli">```cpp</p>
<p class="startli">auto noise = vega.Random(UNIFORM); auto my_num = 3.16f;</p>
<p class="startli"><a class="el" href="namespaceMayaFlux_a6026d46d032b38446b8c86b358b637cb.html#a6026d46d032b38446b8c86b358b637cb" title="Attaches a processing function to a specific channel.">MayaFlux::attach_quick_process</a>([noise, my_num](auto buf){ // Actual processing auto&amp; data = buffer-&gt;get_data(); for (auto&amp; sample : data) { sample *= noise-&gt;process_sample(my_num); }}; ) ```</p>
<p class="startli">Quick processes can be attached to individual buffers, to <code>RootAudioBuffer</code> i.e all buffers in a single channel, or to all channels via pre/post process globals.</p>
<p class="startli">```cpp MayaFlux::attach_quick_process(func, buffer);</p>
<p class="startli">MayaFlux::attach_quick_process_to_channel(func, channel_id);</p>
<p class="startli">MayaFlux::register_process_hook(func, PREPROCESS); ```</p>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md207"></a>
Coroutines: Time as a Creative Material</h2>
<p>Coroutines represent a fundamental shift in how we think about time in digital creation. They're not "sequencers" that trigger events, but temporal coordination primitives that let different processes develop their own relationship with time while remaining connected to the larger creative flow. Think of coroutines as living temporal expressions – each one can pause, wait, coordinate with others, and resume according to its own creative logic. They transform time from a linear constraint into a malleable creative material that you can shape, stretch, layer, and weave together. In <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>, coroutines exist in two interconnected namespaces: <code>Vruta</code> (the scheduling infrastructure) and <code>Kriya</code> (the creative temporal patterns). Together, they create a system where time becomes compositional.</p>
<h3><a class="anchor" id="autotoc_md208"></a>
The Temporal Paradigm</h3>
<p>Unlike traditional sequencing, coroutines let each process maintain its own sense of time while coordinating with others:</p>
<div class="fragment"><div class="line"><span class="comment">// Each coroutine develops its own temporal relationship</span></div>
<div class="line"><span class="keyword">auto</span> slow_drift = create_temporal_process([](<span class="keyword">auto</span> scheduler) -&gt; Vruta::SoundRoutine {</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="keyword">co_await</span> SampleDelay{48000};  <span class="comment">// Wait 1 second at 48kHz</span></div>
<div class="line">        adjust_global_latency(0.001f); <span class="comment">// Subtle drift</span></div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> rhythmic_pulse = create_temporal_process([](<span class="keyword">auto</span> scheduler) -&gt; Vruta::SoundRoutine {</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="keyword">co_await</span> SampleDelay{12000};  <span class="comment">// Wait 0.25 seconds</span></div>
<div class="line">        trigger_percussive_event();</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>Each coroutine co<sub>awaits</sub> different temporal conditions, creating multimodal time where multiple temporal flows coexist and interact.</p>
<h3><a class="anchor" id="autotoc_md209"></a>
Definitions</h3>
<p>Coroutines exist in two interconnected namespaces: <code>Vruta</code> (scheduling infrastructure) and <code>Kriya</code> (creative temporal patterns). Together they transform time from constraint into compositional material.</p>
<p>Much like Buffers and Nodes, coroutines have fluent flow methods, global convenience API and explicit definition support. The primary difference is <code>vega</code> does not have any coroutine representation as <code>vega</code> enables simple non-verbose creation and not time manipulate <b>at</b> creation.</p>
<div class="fragment"><div class="line"><span class="comment">// Fluent API</span></div>
<div class="line"><span class="keyword">auto</span> shape_node = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>({0.1, 0.5, 2.f});</div>
<div class="line">shape_node &gt;&gt; Time(2.f) | Audio;</div>
<div class="line"><span class="keyword">auto</span> wave = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a712ebff89ba142161eb68bb2e9a07b52.html#a712ebff89ba142161eb68bb2e9a07b52">Phasor</a>(shape_node, 440.f);</div>
<div class="line">NodeTimer::play_for(wave, 5.f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Convenience wrappers</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(2.0, []() {</div>
<div class="line">    modulate_filter_cutoff();</div>
<div class="line">}, <span class="stringliteral">&quot;main_clock&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a870a8536c64a612c813800c78068a986.html#a870a8536c64a612c813800c78068a986">MayaFlux::schedule_pattern</a>([](uint64_t beat) {</div>
<div class="line">    <span class="keywordflow">return</span> x % 8 == 0;  <span class="comment">// Every 8th beat</span></div>
<div class="line">}, []() {</div>
<div class="line">    change_distribution();</div>
<div class="line">}, 1.0, <span class="stringliteral">&quot;Update noise&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create coordinated temporal events</span></div>
<div class="line"><span class="keyword">auto</span> event_chain = MayaFlux::create_event_chain()</div>
<div class="line">    .then([]() { start_clock(); }, 0.0)</div>
<div class="line">    .then([]() { trigger_buffer_copy(); }, 0.1)</div>
<div class="line">    .then([]() { start_input_capture(); }, 0.5)</div>
<div class="line">    .then([]() { reset_state(); }, 2.0);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Explicit API</span></div>
<div class="line"><span class="keyword">auto</span> complex_pattern = [](Vruta::TaskScheduler&amp; scheduler) -&gt; Vruta::SoundRoutine {</div>
<div class="line">    <span class="keyword">auto</span>&amp; promise = <span class="keyword">co_await</span> Kriya::GetAudioPromise{};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="comment">// Wait for condition</span></div>
<div class="line">        <span class="keyword">co_await</span> Kriya::Gate{scheduler, []() {</div>
<div class="line">            schedule_another_clock();</div>
<div class="line">        }, logic_node, <span class="keyword">true</span>};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Dynamic timing based on musical state</span></div>
<div class="line">        <span class="keywordtype">float</span> wait_time = calculate_musical_timing();</div>
<div class="line">        <span class="keyword">co_await</span> SampleDelay{scheduler.seconds_to_samples(wait_time)};</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Coordinate with other temporal processes</span></div>
<div class="line">        <span class="keyword">co_await</span> Kriya::Trigger{scheduler, <span class="keyword">true</span>, []() {</div>
<div class="line">            sync_frame_clock();</div>
<div class="line">        }, sync_node};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a712ebff89ba142161eb68bb2e9a07b52_html_a712ebff89ba142161eb68bb2e9a07b52"><div class="ttname"><a href="classMayaFlux_1_1Creator_a712ebff89ba142161eb68bb2e9a07b52.html#a712ebff89ba142161eb68bb2e9a07b52">MayaFlux::Creator::Phasor</a></div><div class="ttdeci">auto Phasor(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Phasor &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a0b2f122006fb411804adab9baa87647d_html_a0b2f122006fb411804adab9baa87647d"><div class="ttname"><a href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a></div><div class="ttdeci">void schedule_metro(double interval_seconds, std::function&lt; void()&gt; callback, std::string name)</div><div class="ttdoc">Creates a metronome task and addes it to the default scheduler list for evaluation.</div><div class="ttdef"><b>Definition</b> <a href="Chronie_8cpp_source.html#l00041">Chronie.cpp:41</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a870a8536c64a612c813800c78068a986_html_a870a8536c64a612c813800c78068a986"><div class="ttname"><a href="namespaceMayaFlux_a870a8536c64a612c813800c78068a986.html#a870a8536c64a612c813800c78068a986">MayaFlux::schedule_pattern</a></div><div class="ttdeci">void schedule_pattern(std::function&lt; std::any(uint64_t)&gt; pattern_func, std::function&lt; void(std::any)&gt; callback, double interval_seconds, std::string name)</div><div class="ttdoc">Schedules a pattern generator that produces values based on a pattern function and addes it to the de...</div><div class="ttdef"><b>Definition</b> <a href="Chronie_8cpp_source.html#l00077">Chronie.cpp:77</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md210"></a>
Temporal Domains and Coordination</h3>
<p>Coroutines coordinate across computational domains through specialized awaiters that understand each context's timing characteristics:</p>
<div class="fragment"><div class="line"><span class="comment">// Domain-specific temporal anchors</span></div>
<div class="line"><span class="keyword">co_await</span> SampleDelay{1024};     <span class="comment">// Audio domain precision</span></div>
<div class="line"><span class="keyword">co_await</span> FrameDelay{2};         <span class="comment">// Visual domain coordination</span></div>
<div class="line"><span class="keyword">co_await</span> MultiRateDelay{samples: 512, frames: 1};  <span class="comment">// Cross-domain sync</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Temporal coordination with state memory</span></div>
<div class="line"><span class="keyword">auto</span> evolving_process = [](<span class="keyword">auto</span> scheduler) -&gt; Vruta::SoundRoutine {</div>
<div class="line">    <span class="keyword">auto</span>&amp; promise = <span class="keyword">co_await</span> Kriya::GetAudioPromise{};</div>
<div class="line">    promise.set_state(<span class="stringliteral">&quot;phase&quot;</span>, 0.0f);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (!promise.should_terminate) {</div>
<div class="line">        <span class="keywordtype">float</span>* phase = promise.get_state&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;phase&quot;</span>);</div>
<div class="line">        *phase += 0.01f;</div>
<div class="line"> </div>
<div class="line">        trigger_event_at(*phase);</div>
<div class="line">        <span class="keyword">co_await</span> SampleDelay{<span class="keyword">static_cast&lt;</span>uint64_t<span class="keyword">&gt;</span>(*phase * 1000)};</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md211"></a>
Kriya Temporal Patterns</h3>
<p>Kriya provides creative temporal primitives that capture common temporal relationships:</p>
<div class="fragment"><div class="line"><span class="comment">// Regular temporal pulse</span></div>
<div class="line"><span class="keyword">auto</span> metro = Kriya::metro(*scheduler, 0.5, pulse_callback);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Temporal event choreography</span></div>
<div class="line"><span class="keyword">auto</span> sequence = Kriya::sequence(*scheduler, {</div>
<div class="line">    {0.0, initialize_state},</div>
<div class="line">    {0.25, transform_data},</div>
<div class="line">    {0.75, complete_cycle}</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Continuous parameter interpolation</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespaceMayaFlux_1_1Kriya_a78bad297d947eafe13416beda84a3044.html#a78bad297d947eafe13416beda84a3044">line</a> = Kriya::line(*scheduler, 0.0f, 1.0f, 2.0f, 44, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access interpolated values by name</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a7d92c127beeb01028a2e57d42ee1a1ba.html#a7d92c127beeb01028a2e57d42ee1a1ba">schedule_task</a>(<span class="stringliteral">&quot;envelope&quot;</span>, std::move(line));</div>
<div class="line"><span class="keywordtype">float</span>* current_value = <a class="code hl_function" href="namespaceMayaFlux_a89874cd168dfb7e79d35b2234e49a468.html#a89874cd168dfb7e79d35b2234e49a468">get_line_value</a>(<span class="stringliteral">&quot;envelope&quot;</span>);</div>
<div class="ttc" id="anamespaceMayaFlux_1_1Kriya_a78bad297d947eafe13416beda84a3044_html_a78bad297d947eafe13416beda84a3044"><div class="ttname"><a href="namespaceMayaFlux_1_1Kriya_a78bad297d947eafe13416beda84a3044.html#a78bad297d947eafe13416beda84a3044">MayaFlux::Kriya::line</a></div><div class="ttdeci">Vruta::SoundRoutine line(Vruta::TaskScheduler &amp;scheduler, float start_value, float end_value, float duration_seconds, uint32_t step_duration, bool restartable)</div><div class="ttdoc">Creates a continuous interpolation generator between two values over time.</div><div class="ttdef"><b>Definition</b> <a href="Tasks_8cpp_source.html#l00031">Tasks.cpp:31</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a7d92c127beeb01028a2e57d42ee1a1ba_html_a7d92c127beeb01028a2e57d42ee1a1ba"><div class="ttname"><a href="namespaceMayaFlux_a7d92c127beeb01028a2e57d42ee1a1ba.html#a7d92c127beeb01028a2e57d42ee1a1ba">MayaFlux::schedule_task</a></div><div class="ttdeci">void schedule_task(const std::string &amp;name, Vruta::SoundRoutine &amp;&amp;task, bool initialize)</div><div class="ttdoc">Schedules a new sound routine task.</div><div class="ttdef"><b>Definition</b> <a href="Chronie_8cpp_source.html#l00102">Chronie.cpp:102</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a89874cd168dfb7e79d35b2234e49a468_html_a89874cd168dfb7e79d35b2234e49a468"><div class="ttname"><a href="namespaceMayaFlux_a89874cd168dfb7e79d35b2234e49a468.html#a89874cd168dfb7e79d35b2234e49a468">MayaFlux::get_line_value</a></div><div class="ttdeci">float * get_line_value(const std::string &amp;name)</div><div class="ttdoc">Gets a pointer to a task's current value.</div><div class="ttdef"><b>Definition</b> <a href="Chronie_8cpp_source.html#l00087">Chronie.cpp:87</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md212"></a>
EventChains and Temporal Composition</h3>
<p>EventChains create temporal choreography through fluent composition:</p>
<div class="fragment"><div class="line"><span class="comment">// Temporal event sequence</span></div>
<div class="line"><span class="keyword">auto</span> chain = Kriya::EventChain{}</div>
<div class="line">    .then([]() { start_process(); }, 0.0)</div>
<div class="line">    .then([]() { modulate_filter(); }, 0.125)</div>
<div class="line">    .then([]() { trigger_release(); }, 0.5);</div>
<div class="line">chain.start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Temporal operators for direct node control</span></div>
<div class="line">sine_node &gt;&gt; <a class="code hl_function" href="namespaceMayaFlux_a84716aecb146cd53acc65ad571be4b9a.html#a84716aecb146cd53acc65ad571be4b9a">Time</a>(2.0) | Audio;  <span class="comment">// Play node for 2 seconds</span></div>
<div class="ttc" id="anamespaceMayaFlux_a84716aecb146cd53acc65ad571be4b9a_html_a84716aecb146cd53acc65ad571be4b9a"><div class="ttname"><a href="namespaceMayaFlux_a84716aecb146cd53acc65ad571be4b9a.html#a84716aecb146cd53acc65ad571be4b9a">MayaFlux::Time</a></div><div class="ttdeci">TimeSpec Time(double seconds, uint32_t channel)</div><div class="ttdoc">Creates a TimeSpec with the specified duration and a single channel.</div><div class="ttdef"><b>Definition</b> <a href="Temporal_8cpp_source.html#l00009">Temporal.cpp:9</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md213"></a>
Buffer Integration and Capture</h3>
<p>Kriya coordinates with buffer processing for temporal data capture and analysis:</p>
<div class="fragment"><div class="line"><span class="comment">// Buffer capture coordination</span></div>
<div class="line"><span class="keyword">auto</span> capture = Kriya::BufferCapture{audio_buffer}</div>
<div class="line">    .for_cycle(4)</div>
<div class="line">    .with_window(1024, 0.5f)  <span class="comment">// Windowed analysis</span></div>
<div class="line">    .as_circular(2048);       <span class="comment">// Circular buffer mode</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Temporal buffer coordination</span></div>
<div class="line"><span class="keyword">auto</span> coordinator = Kriya::CycleCoordinator{*scheduler};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Synchronize multiple buffer pipelines</span></div>
<div class="line"><span class="keyword">auto</span> sync_routine = coordinator.sync_pipelines({</div>
<div class="line">    std::ref(spectral_pipeline),</div>
<div class="line">    std::ref(temporal_pipeline)</div>
<div class="line">}, 4);  <span class="comment">// Sync every 4 cycles</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Manage transient data lifecycle</span></div>
<div class="line"><span class="keyword">auto</span> data_routine = coordinator.manage_transient_data(</div>
<div class="line">    buffer,</div>
<div class="line">    [](uint32_t cycle) { process_data(cycle); },</div>
<div class="line">    [](uint32_t cycle) { cleanup_data(cycle); }</div>
<div class="line">);</div>
</div><!-- fragment --><p>This creates <em>temporal architecture</em> where time becomes malleable creative material, enabling coordination across nodes, buffers, and computational domains through sample-accurate timing and compositional temporal relationships.</p>
<h2><a class="anchor" id="autotoc_md214"></a>
Containers</h2>
<p>Containers represent a paradigm shift in creative data management—moving beyond traditional file-based workflows into dynamic, multi-dimensional data structures that treat information as compositional material. Unlike conventional audio tools that separate "files" from "processing," containers unify data storage, transformation, and access into coherent creative units.</p>
<p>This requires forethought into creative data management because existing digital tools rarely provide infrastructure for general creative data categorization. Containers in <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> recognize that creative data exists in multiple modalities (audio, visual, spectral), dimensions (time, space, frequency), and organizational structures (regions, groups, attributes) that should be accessible through unified interfaces rather than disparate format-specific tools.</p>
<p>Containers work with ****DataVariant**** (unified type storage), ****DataDimensions**** (structural descriptors), ****Regions**** (spatial/temporal selections), and ****RegionGroups**** (organized collections) to create a coherent data architecture that scales from simple audio files to complex multi-modal creative datasets.</p>
<h3><a class="anchor" id="autotoc_md215"></a>
Data Architecture</h3>
<p>Containers organize data through dimensional thinking rather than format constraints:</p>
<div class="fragment"><div class="line"><span class="comment">// DataVariant: Unified type storage for different precision needs</span></div>
<div class="line">DataVariant audio_data = std::vector&lt;double&gt;{...};        <span class="comment">// High precision</span></div>
<div class="line">DataVariant image_data = std::vector&lt;uint8_t&gt;{...};       <span class="comment">// 8-bit image</span></div>
<div class="line"><a class="code hl_typedef" href="namespaceMayaFlux_1_1Kakshya_a574eb486997ef1794fb8ea3ee75d106c.html#a574eb486997ef1794fb8ea3ee75d106c">DataVariant</a> spectral_data = std::vector&lt;std::complex&lt;float&gt;&gt;{...}; <span class="comment">// Complex FFT</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// DataDimensions: Structural descriptors</span></div>
<div class="line"><span class="keyword">auto</span> time_dim = DataDimension::time(48000, <span class="stringliteral">&quot;samples&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> channel_dim = DataDimension::channel(2, 1);</div>
<div class="line"><span class="keyword">auto</span> spatial_dim = DataDimension::spatial(1024, <span class="charliteral">&#39;x&#39;</span>, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Regions: N-dimensional selections</span></div>
<div class="line">Region intro_section = Region::audio_span(0, 12000, 0, 1);  <span class="comment">// First 0.25 seconds, both channels</span></div>
<div class="line">Region frequency_band = Region::spectral_band(440, 880);     <span class="comment">// Specific frequency range</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// RegionGroups: Organized collections with metadata</span></div>
<div class="line">RegionGroup song_structure;</div>
<div class="line">song_structure.add_region(<span class="stringliteral">&quot;spectra&quot;</span>, spectral_peak_region, {{<span class="stringliteral">&quot;noisyness&quot;</span>, <span class="stringliteral">&quot;moderate&quot;</span>}, {<span class="stringliteral">&quot;tempo&quot;</span>, 120}});</div>
<div class="line">song_structure.add_region(<span class="stringliteral">&quot;end&quot;</span>, end_region, {{<span class="stringliteral">&quot;zero_crossings&quot;</span>, <span class="stringliteral">&quot;high&quot;</span>}, {<span class="stringliteral">&quot;tempo&quot;</span>, 125}});</div>
<div class="ttc" id="anamespaceMayaFlux_1_1Kakshya_a574eb486997ef1794fb8ea3ee75d106c_html_a574eb486997ef1794fb8ea3ee75d106c"><div class="ttname"><a href="namespaceMayaFlux_1_1Kakshya_a574eb486997ef1794fb8ea3ee75d106c.html#a574eb486997ef1794fb8ea3ee75d106c">MayaFlux::Kakshya::DataVariant</a></div><div class="ttdeci">std::variant&lt; std::vector&lt; double &gt;, std::vector&lt; float &gt;, std::vector&lt; uint8_t &gt;, std::vector&lt; uint16_t &gt;, std::vector&lt; uint32_t &gt;, std::vector&lt; std::complex&lt; float &gt; &gt;, std::vector&lt; std::complex&lt; double &gt; &gt;, std::vector&lt; glm::vec2 &gt;, std::vector&lt; glm::vec3 &gt;, std::vector&lt; glm::vec4 &gt;, std::vector&lt; glm::mat4 &gt; &gt; DataVariant</div><div class="ttdoc">Multi-type data storage for different precision needs.</div><div class="ttdef"><b>Definition</b> <a href="NDData_8hpp_source.html#l00061">NDData.hpp:73</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md216"></a>
Data Modalities and Detection</h3>
<p>Containers automatically detect and adapt to different data modalities based on dimensional structure:</p>
<div class="fragment"><div class="line"><span class="comment">// Automatic modality detection from dimensions</span></div>
<div class="line">std::vector&lt;DataDimension&gt; audio_dims = {</div>
<div class="line">    DataDimension::time(48000),</div>
<div class="line">    DataDimension::channel(2)</div>
<div class="line">};</div>
<div class="line">DataModality modality = detect_data_modality(audio_dims);  <span class="comment">// Returns AUDIO_MULTICHANNEL</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Supported modalities</span></div>
<div class="line"><span class="keyword">enum class</span> DataModality {</div>
<div class="line">    AUDIO_1D,           <span class="comment">// 1D audio signal</span></div>
<div class="line">    AUDIO_MULTICHANNEL, <span class="comment">// Multi-channel audio</span></div>
<div class="line">    IMAGE_2D,           <span class="comment">// 2D grayscale image</span></div>
<div class="line">    IMAGE_COLOR,        <span class="comment">// 2D color image</span></div>
<div class="line">    VIDEO_GRAYSCALE,    <span class="comment">// 3D video (time + 2D)</span></div>
<div class="line">    SPECTRAL_2D,        <span class="comment">// 2D spectral data</span></div>
<div class="line">    TENSOR_ND,          <span class="comment">// N-dimensional tensor</span></div>
<div class="line">    VOLUMETRIC_3D       <span class="comment">// 3D volumetric data</span></div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md217"></a>
SoundFileContainer: Foundational Implementation</h3>
<p>SoundFileContainer demonstrates the container paradigm through practical audio file handling:</p>
<div class="fragment"><div class="line"><span class="comment">// Fluent creation</span></div>
<div class="line"><span class="keyword">auto</span> sound_file = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0.html#a8437a7d641c0011d359c38f13881adc0">read_audio</a>(<span class="stringliteral">&quot;sample.wav&quot;</span>).channels({0, 1});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Convenience API</span></div>
<div class="line"><span class="keyword">auto</span> container = MayaFlux::load_sound_file(<span class="stringliteral">&quot;sample.wav&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> duration = container-&gt;get_duration_seconds();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Explicit construction</span></div>
<div class="line"><span class="keyword">auto</span> file_container = std::make_shared&lt;SoundFileContainer&gt;(48000, 2);</div>
<div class="line">file_container-&gt;setup(96000, 48000, 2);  <span class="comment">// 2 seconds, 48kHz, stereo</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Region-based access</span></div>
<div class="line">Region loop_region = Region::audio_span(24000, 72000, 0, 1);  <span class="comment">// 0.5s to 1.5s</span></div>
<div class="line">DataVariant loop_data = container-&gt;get_region_data(loop_region);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Memory layout control</span></div>
<div class="line">container-&gt;set_memory_layout(MemoryLayout::COLUMN_MAJOR);  <span class="comment">// Optimize for channel processing</span></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0_html_a8437a7d641c0011d359c38f13881adc0"><div class="ttname"><a href="classMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0.html#a8437a7d641c0011d359c38f13881adc0">MayaFlux::Creator::read_audio</a></div><div class="ttdeci">auto read_audio(const std::string &amp;filepath) -&gt; CreationHandle&lt; Kakshya::SoundFileContainer &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00213">Creator.hpp:213</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md218"></a>
Region-Based Data Access</h3>
<p>Regions provide precise, multi-dimensional data selection without copying entire datasets:</p>
<div class="fragment"><div class="line"><span class="comment">// Temporal regions</span></div>
<div class="line">Region intro = Region::audio_span(0, 12000, 0, 1);        <span class="comment">// First 0.25 seconds</span></div>
<div class="line">Region outro = Region::audio_span(84000, 96000, 0, 1);    <span class="comment">// Last 0.25 seconds</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Channel-specific regions</span></div>
<div class="line">Region left_channel = Region::audio_span(0, 96000, 0, 0); <span class="comment">// Left channel only</span></div>
<div class="line">Region stereo_mix = Region::audio_span(12000, 84000, 0, 1); <span class="comment">// Middle section, both channels</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract and process regions</span></div>
<div class="line">DataVariant intro_data = container-&gt;get_region_data(intro);</div>
<div class="line"><span class="keyword">auto</span> intro_samples = std::get&lt;std::vector&lt;double&gt;&gt;(intro_data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Modify regions in place</span></div>
<div class="line">DataVariant silence = create_silence(6000);  <span class="comment">// 0.125 seconds of silence</span></div>
<div class="line">container-&gt;set_region_data(intro, silence);  <span class="comment">// Replace intro with silence</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md219"></a>
RegionGroups and Metadata</h3>
<p>RegionGroups organize multiple regions with rich metadata for creative workflow management:</p>
<div class="fragment"><div class="line"><span class="comment">// Create organized region collection</span></div>
<div class="line">RegionGroup compositional_structure(<span class="stringliteral">&quot;Composition Structure&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add regions with creative metadata</span></div>
<div class="line">compositional_structure.add_region(<span class="stringliteral">&quot;intro&quot;</span>, intro_region, {</div>
<div class="line">    {<span class="stringliteral">&quot;energy_level&quot;</span>, <span class="stringliteral">&quot;low&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;harmonic_content&quot;</span>, <span class="stringliteral">&quot;sparse&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;tempo&quot;</span>, 85}</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">compositional_structure.add_region(<span class="stringliteral">&quot;variation 1&quot;</span>, var1_region, {</div>
<div class="line">    {<span class="stringliteral">&quot;energy_level&quot;</span>, <span class="stringliteral">&quot;moderate&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;noise_density&quot;</span>, <span class="stringliteral">&quot;high&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;tempo&quot;</span>, 120}</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Query regions by creative attributes</span></div>
<div class="line"><span class="keyword">auto</span> high_energy_regions = <a class="code hl_function" href="namespaceMayaFlux_1_1Kakshya_ab5807ad27a7ccc13d39d900489722a5c.html#ab5807ad27a7ccc13d39d900489722a5c">find_regions_with_attribute</a>(compositional_structure, <span class="stringliteral">&quot;energy_level&quot;</span>, <span class="stringliteral">&quot;high&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> moderate_tempo_regions = <a class="code hl_function" href="namespaceMayaFlux_1_1Kakshya_ab5807ad27a7ccc13d39d900489722a5c.html#ab5807ad27a7ccc13d39d900489722a5c">find_regions_with_attribute</a>(compositional_structure, <span class="stringliteral">&quot;tempo&quot;</span>, 120);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attach region groups to containers</span></div>
<div class="line">container-&gt;add_region_group(song_structure);</div>
<div class="ttc" id="anamespaceMayaFlux_1_1Kakshya_ab5807ad27a7ccc13d39d900489722a5c_html_ab5807ad27a7ccc13d39d900489722a5c"><div class="ttname"><a href="namespaceMayaFlux_1_1Kakshya_ab5807ad27a7ccc13d39d900489722a5c.html#ab5807ad27a7ccc13d39d900489722a5c">MayaFlux::Kakshya::find_regions_with_attribute</a></div><div class="ttdeci">std::vector&lt; Region &gt; find_regions_with_attribute(const RegionGroup &amp;group, const std::string &amp;key, const std::any &amp;value)</div><div class="ttdoc">Find all regions in a RegionGroup with a specific attribute value.</div><div class="ttdef"><b>Definition</b> <a href="RegionUtils_8cpp_source.html#l00031">RegionUtils.cpp:31</a></div></div>
</div><!-- fragment --><p>This creates <em>creative data architecture</em> where information becomes compositional material that can be selected, transformed, and organized through precise multi-dimensional access patterns, enabling workflows that treat data as a creative medium rather than static files.</p>
<h1><a class="anchor" id="autotoc_md220"></a>
Digital Data Flow Architecture</h1>
<p>These four paradigms—Nodes, Buffers, Coroutines, and Containers—form the foundational data transformation architecture of <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>. Together, they create a unified computational environment where information flows through precise transformations rather than being constrained by analog metaphors or format boundaries.</p>
<p>****Nodes**** provide unit-by-unit transformation precision, turning mathematical relationships into creative decisions. ****Buffers**** create temporal gathering spaces where individual moments accumulate into collective expressions. ****Coroutines**** transform time itself into compositional material, enabling complex temporal coordination across multiple processing domains. ****Containers**** organize multi-dimensional data as creative material, supporting everything from simple audio files to complex cross-modal datasets.</p>
<p>The power emerges from their compositional relationships:</p>
<div class="fragment"><div class="line"><span class="comment">// Data flows through unified transformation architecture</span></div>
<div class="line"><span class="keyword">auto</span> spectral_node = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>({0.1, 0.8, 2.0});</div>
<div class="line"><span class="keyword">auto</span> temporal_buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c.html#a9fa2fd237baef3835e5d987262293c2c">AudioBuffer</a>()[0] | Audio;</div>
<div class="line"><span class="keyword">auto</span> coordination_routine = Kriya::metro(*scheduler, 0.25, [&amp;]() {</div>
<div class="line">    <span class="keyword">auto</span> region = container-&gt;get_region_data(analysis_region);</div>
<div class="line">    temporal_buffer-&gt;apply_processor(spectral_node);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cross-domain coordination through shared timing</span></div>
<div class="line">spectral_node &gt;&gt; temporal_buffer &gt;&gt; container_analysis;</div>
<div class="line">coordination_routine.start();</div>
</div><!-- fragment --><p>This architecture enables <em>digital-first creative thinking</em> where computational precision becomes creative opportunity. Unit-by-unit transformations coordinate with temporal accumulation, while coroutines orchestrate complex timing relationships across multi-dimensional data structures.</p>
<p>Rather than separating "programming" from "composing," <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> treats data transformation as the fundamental creative act. Mathematical relationships, temporal coordination, and dimensional data access become unified aspects of a single creative expression.</p>
<p>The next stage of this digital paradigm involves <a class="el" href="md_docs_2Domain__and__Control.html">Domains and Control</a> — how these transformation primitives coordinate across different computational contexts and how creative control emerges from the interaction between precise computational timing and expressive creative intent. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
