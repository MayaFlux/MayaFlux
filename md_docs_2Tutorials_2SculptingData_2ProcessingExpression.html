<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MayaFlux: ProcessingExpression</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MayaFlux<span id="projectnumber">&#160;0.2.0</span>
   </div>
   <div id="projectbrief">Digital-First Multimedia Processing Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2Tutorials_2SculptingData_2ProcessingExpression.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ProcessingExpression</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Up to this point, you’ve learned how audio flows:</p>
<ul>
<li>containers feed buffers</li>
<li>buffers run processors</li>
<li>processors shape data.</li>
</ul>
<p>Now we expand the vocabulary of processors themselves. In <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>, mathematics, logic, feedback, and generation are not side features, they are first-class sculpting tools. This tutorial explores how computational expressions become sound-shaping primitives.</p>
<p><em>In <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>, polynomials don't calculate—they sculpt. Logic doesn't branch—it decides. This tutorial shows you how mathematical expressions become sonic transformations.</em></p>
<hr  />
<ul>
<li>Tutorial: Polynomial Waveshaping{#toc-tutorial-polynomial-waveshaping}<ul>
<li>The Simplest Path{#toc-the-simplest-path}</li>
<li>Expansion 1: Why Polynomials Shape Sound{#toc-expansion-1-why-polynomials-shape-sound}</li>
<li>Expansion 2: What `vega.Polynomial()` Creates{#toc-expansion-2-what-vega.polynomial-creates}</li>
<li>Expansion 3: PolynomialMode::DIRECT{#toc-expansion-3-polynomialmodedirect}</li>
<li>Expansion 4: What `create_processor()` Does{#toc-expansion-4-what-create_processor-does}</li>
<li>Try It{#toc-try-it}</li>
<li>Tutorial: Recursive Polynomials (Filters and Feedback){#toc-tutorial-recursive-polynomials-filters-and-feedback}<ul>
<li>The Next Step{#toc-the-next-step}</li>
</ul>
</li>
<li>Expansion 1: Why This Is a Filter{#toc-expansion-1-why-this-is-a-filter}</li>
<li>Expansion 2: The History Buffer{#toc-expansion-2-the-history-buffer}</li>
<li>Expansion 3: Stability Warning{#toc-expansion-3-stability-warning}</li>
<li>Expansion 4: Initial Conditions{#toc-expansion-4-initial-conditions}</li>
<li>Try It{#toc-try-it-1}</li>
</ul>
</li>
<li>Tutorial: Logic as Decision Maker{#toc-tutorial-logic-as-decision-maker}<ul>
<li>The Simplest Path{#toc-the-simplest-path-1}</li>
<li>Expansion 1: What Logic Does{#toc-expansion-1-what-logic-does}</li>
<li>Expansion 2: Logic node needs an input{#toc-expansion-2-logic-node-needs-an-input}</li>
<li>Expansion 3: LogicOperator Types{#toc-expansion-3-logicoperator-types}</li>
<li>Expansion 4: ModulationType - Readymade Transformations{#toc-expansion-4-modulationtype&mdash;readymade-transformations}</li>
<li>Try It{#toc-try-it-2}</li>
</ul>
</li>
<li>Tutorial: Combining Polynomial + Logic{#toc-tutorial-combining-polynomial-logic}<ul>
<li>The Pattern{#toc-the-pattern}</li>
<li>Expansion 1: Decision Trees in Audio{#toc-expansion-1-decision-trees-in-audio}</li>
<li>Expansion 2: Chain Order Matters{#toc-expansion-2-chain-order-matters}</li>
<li>Try It{#toc-try-it-3}</li>
</ul>
</li>
<li>Tutorial: Processing Chains and Buffer Architecture{#toc-tutorial-processing-chains-and-buffer-architecture}<ul>
<li>Tutorial: Explicit Chain Building{#toc-tutorial-explicit-chain-building}<ul>
<li>The Simplest Path{#toc-the-simplest-path-2}</li>
</ul>
</li>
<li>Expansion 1: What `create_processor()` Was Doing{#toc-expansion-1-what-create_processor-was-doing}</li>
<li>Expansion 2: Chain Execution Order{#toc-expansion-2-chain-execution-order}</li>
<li>Expansion 3: Default Processors vs. Chain Processors{#toc-expansion-3-default-processors-vs.-chain-processors}</li>
<li>Try It{#toc-try-it-4}</li>
</ul>
</li>
<li>Tutorial: Various Buffer Types{#toc-tutorial-various-buffer-types}<ul>
<li>Generating from Nodes (NodeBuffer){#toc-generating-from-nodes-nodebuffer}<ul>
<li>The Next Pattern{#toc-the-next-pattern}</li>
<li>Expansion 1: What NodeBuffer Does{#toc-expansion-1-what-nodebuffer-does}</li>
<li>Expansion 2: The `clear_before_process` Parameter{#toc-expansion-2-the-clear_before_process-parameter}</li>
<li>Expansion 3: NodeSourceProcessor Mix Parameter{#toc-expansion-3-nodesourceprocessor-mix-parameter}</li>
<li>Try It{#toc-try-it-5}</li>
</ul>
</li>
<li>FeedbackBuffer (Recursive Audio){#toc-feedbackbuffer-recursive-audio}<ul>
<li>The Pattern{#toc-the-pattern-1}</li>
<li>Expansion 1: What FeedbackBuffer Does{#toc-expansion-1-what-feedbackbuffer-does}</li>
<li>Expansion 2: FeedbackBuffer Limitations{#toc-expansion-2-feedbackbuffer-limitations}</li>
<li>Expansion 3: When to Use FeedbackBuffer{#toc-expansion-3-when-to-use-feedbackbuffer}</li>
<li>Try It{#toc-try-it-6}</li>
</ul>
</li>
<li>SoundStreamWriter (Capturing Audio){#toc-streamwriteprocessor-capturing-audio}<ul>
<li>The Pattern{#toc-the-pattern-2}</li>
<li>Expansion 1: What SoundStreamWriter Does{#toc-expansion-1-what-streamwriteprocessor-does}</li>
<li>Expansion 2: Channel-Aware Writing{#toc-expansion-2-channel-aware-writing}</li>
<li>Expansion 3: Position Management{#toc-expansion-3-position-management}</li>
<li>Expansion 4: Circular Mode{#toc-expansion-4-circular-mode}</li>
<li>Try It{#toc-try-it-7}</li>
</ul>
</li>
<li>Closing: The Buffer Ecosystem{#toc-closing-the-buffer-ecosystem}</li>
</ul>
</li>
<li>Tutorial: Audio Input, Routing, and Multi-Channel Distribution{#toc-tutorial-audio-input-routing-and-multi-channel-distribution}<ul>
<li>Tutorial: Capturing Audio Input{#toc-tutorial-capturing-audio-input}<ul>
<li>The Simplest Path{#toc-the-simplest-path-3}</li>
</ul>
</li>
<li>Expansion 1: What `create_input_listener_buffer()` Does{#toc-expansion-1-what-create_input_listener_buffer-does}</li>
<li>Expansion 2: Manual Input Registration{#toc-expansion-2-manual-input-registration}</li>
<li>Expansion 3: Input Without Playback{#toc-expansion-3-input-without-playback}</li>
<li>Try It{#toc-try-it-8}</li>
<li>Tutorial: Buffer Supply (Routing to Multiple Channels){#toc-tutorial-buffer-supply-routing-to-multiple-channels}<ul>
<li>The Pattern{#toc-the-pattern-3}</li>
</ul>
</li>
<li>Expansion 1: What &quot;Supply&quot; Means{#toc-expansion-1-what-supply-means}</li>
<li>Expansion 2: Mix Levels{#toc-expansion-2-mix-levels}</li>
<li>Expansion 3: Removing Supply{#toc-expansion-3-removing-supply}</li>
<li>Try It{#toc-try-it-9}</li>
<li>Tutorial: Buffer Cloning{#toc-tutorial-buffer-cloning}<ul>
<li>The Pattern{#toc-the-pattern-4}</li>
</ul>
</li>
<li>Expansion 1: Clone vs. Supply{#toc-expansion-1-clone-vs.-supply}</li>
<li>Expansion 2: Cloning Preserves Structure{#toc-expansion-2-cloning-preserves-structure}</li>
<li>Expansion 3: Post-Clone Modification{#toc-expansion-3-post-clone-modification}</li>
<li>Try It{#toc-try-it-10}</li>
<li>Closing: The Routing Ecosystem{#toc-closing-the-routing-ecosystem}</li>
</ul>
</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md360"></a>
Tutorial: Polynomial Waveshaping</h1>
<h2><a class="anchor" id="autotoc_md361"></a>
The Simplest Path</h2>
<p>Run this code. Your file plays with harmonic distortion.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> sound = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0.html#a8437a7d641c0011d359c38f13881adc0">read_audio</a>(<span class="stringliteral">&quot;path/to/file.wav&quot;</span>) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> buffers = <a class="code hl_function" href="namespaceMayaFlux_a16a769fcbec756197086526ac9297aa8.html#a16a769fcbec756197086526ac9297aa8">MayaFlux::get_last_created_container_buffers</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Polynomial: x² generates harmonics</span></div>
<div class="line">    <span class="keyword">auto</span> poly = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> x * x; });</div>
<div class="line">    <span class="keyword">auto</span> processor = MayaFlux::create_processor&lt;PolynomialProcessor&gt;(buffers[0], poly);</div>
<div class="line">}</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7_html_a433b0c2da4871dc08e049d5ac64041b7"><div class="ttname"><a href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">MayaFlux::Creator::Polynomial</a></div><div class="ttdeci">auto Polynomial(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Polynomial &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0_html_a8437a7d641c0011d359c38f13881adc0"><div class="ttname"><a href="classMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0.html#a8437a7d641c0011d359c38f13881adc0">MayaFlux::Creator::read_audio</a></div><div class="ttdeci">auto read_audio(const std::string &amp;filepath) -&gt; CreationHandle&lt; Kakshya::SoundFileContainer &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00213">Creator.hpp:213</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a16a769fcbec756197086526ac9297aa8_html_a16a769fcbec756197086526ac9297aa8"><div class="ttname"><a href="namespaceMayaFlux_a16a769fcbec756197086526ac9297aa8.html#a16a769fcbec756197086526ac9297aa8">MayaFlux::get_last_created_container_buffers</a></div><div class="ttdeci">std::vector&lt; std::shared_ptr&lt; Buffers::SoundContainerBuffer &gt; &gt; get_last_created_container_buffers()</div><div class="ttdoc">Retrieves the last created container buffers from the Creator.</div><div class="ttdef"><b>Definition</b> <a href="Creator_8cpp_source.html#l00105">Creator.cpp:105</a></div></div>
</div><!-- fragment --><p>Replace <code>"path/to/file.wav"</code> with an actual path.</p>
<p>The audio sounds richer, warmer—subtle saturation. That's harmonic content added by the squaring function.</p>
<h2><a class="anchor" id="autotoc_md362"></a>
Expansion 1: Why Polynomials Shape Sound</h2>
<details >
<summary >
Click to expand: Transfer Functions as Geometry</summary>
<p></p>
<p>When you write <code>x * x</code>, you're not "squaring numbers." You're defining a <b>transfer curve</b>:</p>
<ul>
<li>Input -1.0 → Output 1.0</li>
<li>Input 0.5 → Output 0.25 (quieter)</li>
<li>Input 1.0 → Output 1.0 (same)</li>
</ul>
<p>This asymmetry adds harmonics. The waveform's shape **bends**—its geometry changes.</p>
<p>Analog distortion (tubes, tape) works this way: input voltage doesn't map linearly to output. The circuit's response curve adds character.</p>
<p>Polynomials let you design that curve digitally. <code>x * x</code> is gentle. <code>x * x * x</code> adds different harmonics (odd instead of even). <code>std::tanh(x)</code> mimics tube saturation.</p>
<p>You're sculpting frequency response through function shape.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md363"></a>
Expansion 2: What &lt;tt&gt;vega.Polynomial()&lt;/tt&gt; Creates</h2>
<details >
<summary >
Click to expand: Nodes vs. Processors</summary>
<p></p>
<p><code>vega.Polynomial([](double x) { return x * x; })</code> creates a **Polynomial node**—a mathematical expression that processes one sample at a time.</p>
<p>By itself, the node doesn't touch your audio. You wrap it in a <b>PolynomialProcessor</b>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> processor = MayaFlux::create_processor&lt;PolynomialProcessor&gt;(buffers[0], poly);</div>
</div><!-- fragment --><p><b>Why this separation?</b></p>
<ul>
<li><b>Node</b>: The math itself—reusable, chainable, inspectable</li>
<li><b>Processor</b>: The attachment mechanism—knows <em>how</em> to apply the node to a buffer</li>
</ul>
<p>Same node, different processors → different results. You'll see this pattern everywhere in <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>.</p>
<p>The node is the <em>idea</em>. The processor is the <em>application</em>.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md364"></a>
Expansion 3: PolynomialMode::DIRECT</h2>
<details >
<summary >
Click to expand: Three Processing Modes</summary>
<p></p>
<p>Polynomials have three modes:</p>
<ul>
<li><b>DIRECT</b>: <code>f(x)</code> where x is the current sample (what you just used)</li>
<li><b>RECURSIVE</b>: <code>f(y[n-1], y[n-2], ...)</code> where output depends on previous outputs</li>
<li><b>FEEDFORWARD</b>: <code>f(x[n], x[n-1], ...)</code> where output depends on input history</li>
</ul>
<p>Right now you're using DIRECT mode—each sample transformed independently. This is <b>memoryless</b> waveshaping.</p>
<p>Later sections explore time-aware modes. RECURSIVE creates filters and feedback. FEEDFORWARD creates delay-based effects.</p>
<p>For now: DIRECT mode = instant transformation. No memory. No delay.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md365"></a>
Expansion 4: What &lt;tt&gt;create_processor()&lt;/tt&gt; Does</h2>
<details >
<summary >
Click to expand: Attaching to Buffers</summary>
<p></p>
<p>When you call:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> processor = MayaFlux::create_processor&lt;PolynomialProcessor&gt;(buffers[0], poly);</div>
</div><!-- fragment --><p><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> does this:</p>
<ol type="1">
<li>Creates a <code>PolynomialProcessor</code> wrapping your polynomial node</li>
<li>Gets <code>buffers[0]</code>'s processing chain (every buffer has one)</li>
<li>Adds the processor to that chain</li>
<li>Returns the processor handle</li>
</ol>
<p>The buffer now runs your polynomial on every cycle:</p>
<ul>
<li>512 samples arrive from the Container</li>
<li>Your polynomial processes each sample: <code>y = x * x</code></li>
<li>Transformed samples continue to speakers</li>
</ul>
<p>The processor is now part of the buffer's flow. It runs automatically every cycle until removed.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md367"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Cubic distortion (more aggressive, odd harmonics)</span></div>
<div class="line"><span class="keyword">auto</span> poly = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> x * x * x; });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Chebyshev waveshaping (precise harmonic control)</span></div>
<div class="line"><span class="keyword">auto</span> poly = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> 2*x*x - 1; });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Soft clipping (analog-style limiting)</span></div>
<div class="line"><span class="keyword">auto</span> poly = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x / (1.0 + std::abs(x));</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extreme fold-back distortion</span></div>
<div class="line"><span class="keyword">auto</span> poly = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> std::sin(x * 5.0);</div>
<div class="line">});</div>
<div class="ttc" id="anamespaceMayaFlux_a206db47ce24592b667c583d0047f745b_html_a206db47ce24592b667c583d0047f745b"><div class="ttname"><a href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">MayaFlux::vega</a></div><div class="ttdeci">Creator vega</div><div class="ttdoc">Global Creator instance for creating nodes, buffers, and containers.</div><div class="ttdef"><b>Definition</b> <a href="Creator_8cpp_source.html#l00018">Creator.cpp:18</a></div></div>
</div><!-- fragment --><p>Listen to each. Same structure, different curves. Each curve generates different harmonic content.</p>
<p>You're not "processing audio"—you're <b>sculpting the transfer function</b>.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md369"></a>
Tutorial: Recursive Polynomials (Filters and Feedback)</h1>
<h2><a class="anchor" id="autotoc_md370"></a>
The Next Step</h2>
<p>You have memoryless waveshaping. Now add memory.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> sound = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0.html#a8437a7d641c0011d359c38f13881adc0">read_audio</a>(<span class="stringliteral">&quot;path/to/file.wav&quot;</span>) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> buffers = <a class="code hl_function" href="namespaceMayaFlux_a16a769fcbec756197086526ac9297aa8.html#a16a769fcbec756197086526ac9297aa8">MayaFlux::get_last_created_container_buffers</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Recursive: output depends on previous outputs</span></div>
<div class="line">    <span class="keyword">auto</span> recursive = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>(</div>
<div class="line">        [](std::span&lt;double&gt; history) {</div>
<div class="line">            <span class="comment">// history[0] = previous output, history[1] = two samples ago</span></div>
<div class="line">            <span class="keywordflow">return</span> 0.5 * history[0] + 0.3 * history[1];</div>
<div class="line">        },</div>
<div class="line">        PolynomialMode::RECURSIVE,</div>
<div class="line">        2  <span class="comment">// remember 2 previous outputs</span></div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> processor = MayaFlux::create_processor&lt;PolynomialProcessor&gt;(buffers[0], recursive);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Run this. You hear echo/resonance—the signal feeds back into itself.</p>
<h2><a class="anchor" id="autotoc_md371"></a>
Expansion 1: Why This Is a Filter</h2>
<details >
<summary >
Click to expand: IIR Filters Are Recursive Polynomials</summary>
<p></p>
<p>Classic IIR filter equation:</p>
<div class="fragment"><div class="line">y[n] = b0*x[n] + a1*y[n-1] + a2*y[n-2]</div>
</div><!-- fragment --><p>Your recursive polynomial <b>is</b> that filter—just written as a lambda:</p>
<div class="fragment"><div class="line">[](std::span&lt;double&gt; history) {</div>
<div class="line">    <span class="keywordflow">return</span> 0.5 * history[0] + 0.3 * history[1];</div>
<div class="line">}</div>
</div><!-- fragment --><p>Difference: You can write <b>nonlinear</b> feedback:</p>
<div class="fragment"><div class="line">[](std::span&lt;double&gt; history) {</div>
<div class="line">    <span class="keywordflow">return</span> history[0] * std::sin(history[1]);  <span class="comment">// nonlinear!</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Traditional DSP libraries can't do this. Fixed coefficients only.</p>
<p>Polynomials let you design arbitrary recursive functions—not just linear filters.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md372"></a>
Expansion 2: The History Buffer</h2>
<details >
<summary >
Click to expand: How RECURSIVE Mode Works</summary>
<p></p>
<p>When you write:</p>
<div class="fragment"><div class="line">PolynomialMode::RECURSIVE, 2</div>
</div><!-- fragment --><p>The polynomial maintains a buffer of <b>previous outputs</b>:</p>
<div class="fragment"><div class="line">history[0] = y[n-1]  (last output)</div>
<div class="line">history[1] = y[n-2]  (two samples ago)</div>
</div><!-- fragment --><p>Each cycle:</p>
<ol type="1">
<li>Your lambda reads from <code>history</code></li>
<li>Computes new output</li>
<li>Polynomial pushes output into <code>history</code> (shifts everything down)</li>
<li>Loop repeats</li>
</ol>
<p>The buffer size determines how far back you can look. Larger buffers = longer memory.</p>
<p>For a 100-sample buffer at 48 kHz:</p>
<div class="fragment"><div class="line">100 samples ÷ 48000 Hz ≈ 2 ms of history</div>
</div><!-- fragment --><p>This is how you build delays, reverbs, resonant filters—anything that needs temporal memory.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md373"></a>
Expansion 3: Stability Warning</h2>
<details >
<summary >
Click to expand: Recursive Systems Can Explode</summary>
<p></p>
<p><b>Critical rule</b>: Keep feedback coefficients summing to &lt; 1.0 for guaranteed stability.</p>
<p><b>Safe:</b></p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> 0.6*history[0] + 0.3*history[1];  <span class="comment">// sum = 0.9 &lt; 1.0</span></div>
</div><!-- fragment --><p><b>Dangerous:</b></p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> 1.2*history[0];  <span class="comment">// WILL EXPLODE (unbounded growth)</span></div>
</div><!-- fragment --><p>Why? Each cycle multiplies previous output by 1.2. Exponential growth. Your speakers won't thank you.</p>
<p><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> won't stop you—this is a creative tool, not a safety guard. Instability can be interesting (briefly). Controlled feedback explosion creates chaotic textures.</p>
<p>But for stable filters: keep gain &lt; 1.0.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md374"></a>
Expansion 4: Initial Conditions</h2>
<details >
<summary >
Click to expand: Seeding the History Buffer</summary>
<p></p>
<p>Recursive polynomials need starting values. Default: <code>[0.0, 0.0, ...]</code></p>
<p>You can seed them:</p>
<div class="fragment"><div class="line">recursive-&gt;set_initial_conditions({0.5, -0.3, 0.1});</div>
</div><!-- fragment --><p><b>Why?</b></p>
<ol type="1">
<li><b>Impulse responses</b>: Inject energy without external input. The filter "pings" on its own.</li>
<li><b>Self-oscillation</b>: Non-zero initial conditions + feedback gain ≥ 1.0 = continuous tone.</li>
<li><b>Warm start</b>: Resume from previous state instead of cold-starting at zero.</li>
</ol>
<p>Example (resonant ping):</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> resonator = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>(</div>
<div class="line">    [](std::span&lt;double&gt; history) {</div>
<div class="line">        <span class="keywordflow">return</span> 0.99 * history[0] - 0.5 * history[1];</div>
<div class="line">    },</div>
<div class="line">    PolynomialMode::RECURSIVE,</div>
<div class="line">    2</div>
<div class="line">);</div>
<div class="line">resonator-&gt;set_initial_conditions({1.0, 0.0});  <span class="comment">// kick-start the resonance</span></div>
</div><!-- fragment --><p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md376"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Karplus-Strong string synthesis (plucked string)</span></div>
<div class="line"><span class="keyword">auto</span> <span class="keywordtype">string</span> = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>(</div>
<div class="line">    [](std::span&lt;double&gt; history) {</div>
<div class="line">        <span class="keywordflow">return</span> 0.996 * (history[0] + history[1]) / 2.0;  <span class="comment">// lowpass + feedback</span></div>
<div class="line">    },</div>
<div class="line">    PolynomialMode::RECURSIVE,</div>
<div class="line">    100  <span class="comment">// ~480 Hz at 48kHz</span></div>
<div class="line">);</div>
<div class="line"><span class="keywordtype">string</span>-&gt;set_initial_conditions(std::vector&lt;double&gt;(100, vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">Random</a>(-1.0, 1.0)));  <span class="comment">// noise burst</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nonlinear resonator (saturating feedback)</span></div>
<div class="line"><span class="keyword">auto</span> nonlinear = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>(</div>
<div class="line">    [](std::span&lt;double&gt; history) {</div>
<div class="line">        <span class="keywordtype">double</span> fb = 0.8 * history[0];</div>
<div class="line">        <span class="keywordflow">return</span> std::tanh(fb * 3.0);  <span class="comment">// soft saturation in loop</span></div>
<div class="line">    },</div>
<div class="line">    PolynomialMode::RECURSIVE,</div>
<div class="line">    1</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Comb filter (delay-based coloration)</span></div>
<div class="line"><span class="keyword">auto</span> comb = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>(</div>
<div class="line">    [](std::span&lt;double&gt; history) {</div>
<div class="line">        <span class="keywordflow">return</span> history[0] + 0.5 * history[50];  <span class="comment">// 50-sample delay</span></div>
<div class="line">    },</div>
<div class="line">    PolynomialMode::RECURSIVE,</div>
<div class="line">    50</div>
<div class="line">);</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7_html_a8a8d81842f8f6d77789cd3cd199c12e7"><div class="ttname"><a href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">MayaFlux::Creator::Random</a></div><div class="ttdeci">auto Random(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Random &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md378"></a>
Tutorial: Logic as Decision Maker</h1>
<h2><a class="anchor" id="autotoc_md379"></a>
The Simplest Path</h2>
<p>Run this code. You'll hear rhythmic pulses.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c.html#a9fa2fd237baef3835e5d987262293c2c">AudioBuffer</a>()[0] | Audio;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Logic node: threshold detection</span></div>
<div class="line">    <span class="keyword">auto</span> logic = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.0);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> processor = MayaFlux::create_processor&lt;LogicProcessor&gt;(</div>
<div class="line">        buffer,</div>
<div class="line">        logic</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    processor-&gt;set_modulation_type(LogicProcessor::ModulationType::REPLACE);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Feed a sine wave into the logic node</span></div>
<div class="line">    <span class="keyword">auto</span> sine = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(2.0);</div>
<div class="line">    logic-&gt;set_input_node(sine);</div>
<div class="line">}</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c_html_a9fa2fd237baef3835e5d987262293c2c"><div class="ttname"><a href="classMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c.html#a9fa2fd237baef3835e5d987262293c2c">MayaFlux::Creator::AudioBuffer</a></div><div class="ttdeci">auto AudioBuffer(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Buffers::AudioBuffer &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00210">Creator.hpp:210</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef_html_ad172557289ef9c249a3cb0a3935bd1ef"><div class="ttname"><a href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">MayaFlux::Creator::Logic</a></div><div class="ttdeci">auto Logic(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Logic &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687_html_ae9b21dfc8a04dd2826b63cda4dae4687"><div class="ttname"><a href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">MayaFlux::Creator::Sine</a></div><div class="ttdeci">auto Sine(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Sine &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
</div><!-- fragment --><p>What you hear: 2 Hz pulse train—beeps every half second.</p>
<p>The sine wave crosses zero twice per cycle. Logic detects the crossings. Output becomes binary: 1.0 (high) or 0.0 (low).</p>
<h2><a class="anchor" id="autotoc_md380"></a>
Expansion 1: What Logic Does</h2>
<details >
<summary >
Click to expand: Continuous → Discrete Conversion</summary>
<p></p>
<p><code>LogicProcessor</code> makes <b>binary decisions</b> about audio.</p>
<p>Every sample asks: _"Is this value TRUE or FALSE?"_ (based on threshold)</p>
<p>Output: 0.0 or 1.0.</p>
<p><b>Uses:</b></p>
<ul>
<li><b>Gate</b>: Silence audio below threshold (noise reduction)</li>
<li><b>Trigger</b>: Fire events when signal crosses boundary (drums, envelopes)</li>
<li><b>Rhythm</b>: Convert continuous modulation into discrete beats</li>
</ul>
<p>Example: Feed a slow LFO (0.5 Hz sine) into logic → square wave clock.</p>
<p>Digital doesn't care what the input "means"—just whether it passes the test.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md381"></a>
Expansion 2: Logic node needs an input</h2>
<details >
<summary >
Click to expand: Continuous → input signal</summary>
<p></p>
<p><code>Logic</code> nodes need an input signal to evaluate. This is also true for other nodes like <code>Polynomial</code>. So far, you did not have to manually set inputs because you used <code>SoundContainerBuffer</code> which automatically feeds audio into processors.</p>
<p>So, instead of creating an <code>AudioBuffer</code>, you can load a file:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sound = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0.html#a8437a7d641c0011d359c38f13881adc0">read_audio</a>(<span class="stringliteral">&quot;path/to/file.wav&quot;</span>) | Audio;</div>
<div class="line"><span class="keyword">auto</span> buffers = <a class="code hl_function" href="namespaceMayaFlux_a16a769fcbec756197086526ac9297aa8.html#a16a769fcbec756197086526ac9297aa8">MayaFlux::get_last_created_container_buffers</a>();</div>
<div class="line"><span class="keyword">auto</span> logic = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.0);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> processor = MayaFlux::create_processor&lt;LogicProcessor&gt;(</div>
<div class="line">    buffer[0],</div>
<div class="line">    logic</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">processor-&gt;set_modulation_type(LogicProcessor::ModulationType::REPLACE);</div>
</div><!-- fragment --><p>The audio from the file is automatically fed into the logic node. Considering how all previous examples relied on file contents, and the natutre of rhythmic pulses not exploiting the intricacies or richness of audio files, we are using a sine wave as inputs of the logic node in the main example.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md382"></a>
Expansion 3: LogicOperator Types</h2>
<details >
<summary >
Click to expand: Binary Operations</summary>
<p></p>
<p><code>LogicOperator</code> defines the test:</p>
<ul>
<li><b>THRESHOLD</b>: <code>x &gt; threshold</code> → 1.0, else 0.0</li>
<li><b>HYSTERESIS</b>: Two thresholds (open/close) to avoid flutter</li>
<li><b>EDGE</b>: Trigger on transitions (0→1 or 1→0)</li>
<li><b>AND/OR/XOR/NOT</b>: Boolean algebra on current vs. previous sample</li>
<li><b>CUSTOM</b>: Your function</li>
</ul>
<p>Right now you're using THRESHOLD—the simplest test.</p>
<p>Example (hysteresis gate for noisy signals):</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> gate = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::HYSTERESIS);</div>
<div class="line">gate-&gt;set_hysteresis_thresholds(0.1, 0.3);  <span class="comment">// open at 0.3, close at 0.1</span></div>
</div><!-- fragment --><p>Signal must exceed 0.3 to open, then drops below 0.1 to close. Prevents rapid on/off flickering.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md383"></a>
Expansion 4: ModulationType - Readymade Transformations</h2>
<details >
<summary >
Click to expand: Creative Logic Applications</summary>
<p></p>
<p><code>ModulationType</code> provides readymade ways to apply binary logic to audio:</p>
<p><b>Basic Operations:</b></p>
<ul>
<li><b>REPLACE</b>: Audio becomes 0.0 or 1.0 (bit reduction)</li>
<li><b>MULTIPLY</b>: Audio × logic (standard gate - preserves timbre)</li>
<li><b>ADD</b>: Audio + logic (adds impulse on logic high)</li>
</ul>
<p><b>Creative Operations:</b></p>
<ul>
<li><b>INVERT_ON_TRUE</b>: Phase flip when logic high (ring mod effect)</li>
<li><b>HOLD_ON_FALSE</b>: Freeze audio when logic low (granular stutter)</li>
<li><b>ZERO_ON_FALSE</b>: Hard silence when logic low (noise gate)</li>
<li><b>CROSSFADE</b>: Smooth fade based on logic (dynamic blending)</li>
<li><b>THRESHOLD_REMAP</b>: Binary amplitude switch (tremolo from logic)</li>
<li><b>SAMPLE_AND_HOLD</b>: Freeze on logic changes (glitch/stutter)</li>
<li><b>CUSTOM</b>: Your function</li>
</ul>
<p>Example (granular freeze effect):</p>
<div class="fragment"><div class="line">processor-&gt;set_modulation_type(LogicProcessor::ModulationType::HOLD_ON_FALSE);</div>
<div class="line"><span class="comment">// Audio freezes whenever logic goes low - creates stuttering repeats</span></div>
</div><!-- fragment --><p>Example (amplitude tremolo):</p>
<div class="fragment"><div class="line">processor-&gt;set_modulation_type(LogicProcessor::ModulationType::THRESHOLD_REMAP);</div>
<div class="line">processor-&gt;set_threshold_remap_values(1.0, 0.2); <span class="comment">// High = full volume, Low = quiet</span></div>
<div class="line"><span class="comment">// Creates rhythmic volume changes based on logic pattern</span></div>
</div><!-- fragment --><p>Logic becomes a <b>compositional control</b> for transforming audio in musical ways.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md385"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Hard gate (silence below threshold)</span></div>
<div class="line"><span class="keyword">auto</span> gate = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.2);</div>
<div class="line"><span class="keyword">auto</span> proc = MayaFlux::create_processor&lt;LogicProcessor&gt;(buffer, gate);</div>
<div class="line">proc-&gt;set_modulation_type(LogicProcessor::ModulationType::ZERO_ON_FALSE);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Granular stutter (freeze on quiet passages)</span></div>
<div class="line"><span class="keyword">auto</span> freeze = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.3);</div>
<div class="line"><span class="keyword">auto</span> proc = MayaFlux::create_processor&lt;LogicProcessor&gt;(buffer, freeze);</div>
<div class="line">proc-&gt;set_modulation_type(LogicProcessor::ModulationType::HOLD_ON_FALSE);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bit crusher (reduce to 1-bit audio)</span></div>
<div class="line"><span class="keyword">auto</span> crusher = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.0);</div>
<div class="line"><span class="keyword">auto</span> proc = MayaFlux::create_processor&lt;LogicProcessor&gt;(buffer, crusher);</div>
<div class="line">proc-&gt;set_modulation_type(LogicProcessor::ModulationType::REPLACE);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Rhythmic tremolo from LFO</span></div>
<div class="line"><span class="keyword">auto</span> lfo = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(4.0);  <span class="comment">// 4 Hz</span></div>
<div class="line"><span class="keyword">auto</span> trem_logic = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.0);</div>
<div class="line">trem_logic-&gt;set_input_node(lfo);</div>
<div class="line"><span class="keyword">auto</span> proc = MayaFlux::create_processor&lt;LogicProcessor&gt;(buffer, trem_logic);</div>
<div class="line">proc-&gt;set_modulation_type(LogicProcessor::ModulationType::THRESHOLD_REMAP);</div>
<div class="line">proc-&gt;set_threshold_remap_values(1.0, 0.3);  <span class="comment">// Pumping rhythm</span></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md387"></a>
Tutorial: Combining Polynomial + Logic</h1>
<h2><a class="anchor" id="autotoc_md388"></a>
The Pattern</h2>
<p>Load a file. Detect transients with logic. Apply polynomial only when transient detected.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> sound = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0.html#a8437a7d641c0011d359c38f13881adc0">read_audio</a>(<span class="stringliteral">&quot;drums.wav&quot;</span>) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> buffers = <a class="code hl_function" href="namespaceMayaFlux_a16a769fcbec756197086526ac9297aa8.html#a16a769fcbec756197086526ac9297aa8">MayaFlux::get_last_created_container_buffers</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 1: Detect transients (drum hits)</span></div>
<div class="line">    <span class="keyword">auto</span> chain = <a class="code hl_function" href="namespaceMayaFlux_a2b1e7c1f92d6a0a70984440e9f32081c.html#a2b1e7c1f92d6a0a70984440e9f32081c">MayaFlux::create_processing_chain</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 1: Brutal bitcrushing - reduce to 1-bit</span></div>
<div class="line">    <span class="keyword">auto</span> bitcrush = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.0);</div>
<div class="line">    <span class="keyword">auto</span> crush_proc = std::make_shared&lt;LogicProcessor&gt;(bitcrush);</div>
<div class="line">    crush_proc-&gt;set_modulation_type(LogicProcessor::ModulationType::REPLACE);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 2: Freeze audio in chunks - granular stutter</span></div>
<div class="line">    <span class="keyword">auto</span> clock = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(4.0); <span class="comment">// 4 Hz freeze rate</span></div>
<div class="line">    <span class="keyword">auto</span> freeze_logic = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.0);</div>
<div class="line">    freeze_logic-&gt;set_input_node(clock);</div>
<div class="line">    <span class="keyword">auto</span> freeze_proc = std::make_shared&lt;LogicProcessor&gt;(freeze_logic);</div>
<div class="line">    freeze_proc-&gt;set_modulation_type(LogicProcessor::ModulationType::HOLD_ON_FALSE);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 3: Extreme waveshaping distortion</span></div>
<div class="line">    <span class="keyword">auto</span> destroyer = std::make_shared&lt;Polynomial&gt;([](<span class="keywordtype">double</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> std::copysign(1.0, x) * std::pow(std::abs(x), 0.3); <span class="comment">// Extreme compression</span></div>
<div class="line">    });</div>
<div class="line">    <span class="keyword">auto</span> poly_proc = std::make_shared&lt;PolynomialProcessor&gt;(destroyer);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Build chain: bitcrush → freeze → destroy</span></div>
<div class="line">    chain-&gt;add_processor(crush_proc, buffers[0]);</div>
<div class="line">    chain-&gt;add_processor(freeze_proc, buffers[0]);</div>
<div class="line">    chain-&gt;add_processor(poly_proc, buffers[0]);</div>
<div class="line"> </div>
<div class="line">    buffers[0]-&gt;set_processing_chain(chain);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceMayaFlux_a2b1e7c1f92d6a0a70984440e9f32081c_html_a2b1e7c1f92d6a0a70984440e9f32081c"><div class="ttname"><a href="namespaceMayaFlux_a2b1e7c1f92d6a0a70984440e9f32081c.html#a2b1e7c1f92d6a0a70984440e9f32081c">MayaFlux::create_processing_chain</a></div><div class="ttdeci">std::shared_ptr&lt; Buffers::BufferProcessingChain &gt; create_processing_chain()</div><div class="ttdoc">Creates a new processing chain for the default engine.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00151">Graph.cpp:151</a></div></div>
</div><!-- fragment --><p>Or if you want direct control without manual processor creation, you can use the fluent API</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sound = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0.html#a8437a7d641c0011d359c38f13881adc0">read_audio</a>(<span class="stringliteral">&quot;drums.wav&quot;</span>) | Audio;</div>
<div class="line"><span class="keyword">auto</span> buffers = <a class="code hl_function" href="namespaceMayaFlux_a16a769fcbec756197086526ac9297aa8.html#a16a769fcbec756197086526ac9297aa8">MayaFlux::get_last_created_container_buffers</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> bitcrush = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.0);</div>
<div class="line"><span class="keyword">auto</span> crush_proc = MayaFlux::create_processor&lt;LogicProcessor&gt;(buffers[0], bitcrush);</div>
<div class="line">crush_proc-&gt;set_modulation_type(LogicProcessor::ModulationType::REPLACE);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 2: Freeze audio in chunks - granular stutter</span></div>
<div class="line"><span class="keyword">auto</span> clock = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(4.0); <span class="comment">// 4 Hz freeze rate</span></div>
<div class="line"><span class="keyword">auto</span> freeze_logic = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.0);</div>
<div class="line">freeze_logic-&gt;set_input_node(clock);</div>
<div class="line"><span class="keyword">auto</span> freeze_proc = MayaFlux::create_processor&lt;LogicProcessor&gt;(buffers[0], freeze_logic);</div>
<div class="line">freeze_proc-&gt;set_modulation_type(LogicProcessor::ModulationType::HOLD_ON_FALSE);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Step 3: Extreme waveshaping distortion</span></div>
<div class="line"><span class="keyword">auto</span> destroyer = std::make_shared&lt;Polynomial&gt;([](<span class="keywordtype">double</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> std::copysign(1.0, x) * std::pow(std::abs(x), 0.3); <span class="comment">// Extreme compression</span></div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> poly_proc = MayaFlux::create_processor&lt;PolynomialProcessor&gt;(buffers[0], destroyer);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md389"></a>
Expansion 1: Processing Chains as Transformation Pipelines</h2>
<details >
<summary >
Click to expand: Sequential Audio Surgery</summary>
<p></p>
<p>You just built a <b>transformation pipeline</b>:</p>
<div class="fragment"><div class="line">bitcrush → freeze → destroy</div>
</div><!-- fragment --><p>Each processor transforms the output of the previous one. This is **compositional signal processing**—you build complex effects by chaining simple operations.</p>
<p>The power comes from <b>order dependency</b>:</p>
<div class="fragment"><div class="line">gate → distort    // Clean transients, heavy saturation</div>
<div class="line">distort → gate    // Distorted everything, then choppy</div>
</div><!-- fragment --><p>Swap the order = completely different sound.</p>
<p>Extend it:</p>
<div class="fragment"><div class="line">detect transients → sample-and-hold → bitcrush → wavefold → compress</div>
</div><!-- fragment --><p>Traditional plugins give you "distortion with 3 knobs." You compose the distortion algorithm itself.</p>
<p><b>Every processor is a building block.</b> Chain them to create effects that don't exist as plugins:</p>
<ul>
<li>Bitcrush → Freeze → Invert = Glitch stutterer</li>
<li>Remap → Fold → Gate = Rhythmic harmonizer</li>
<li>Threshold → Hold → Distort = Transient emphasizer</li>
</ul>
<p>Logic + Polynomial + Chains = <b>programmable audio transformation system</b>.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md390"></a>
Expansion 2: Chain Order Matters</h2>
<details >
<summary >
Click to expand: Non-Commutative Processing</summary>
<p></p>
<p>Swap the order of logic and polynomial → different result:</p>
<div class="fragment"><div class="line">Logic → Polynomial  // Detect, then distort</div>
<div class="line">Polynomial → Logic  // Distort, then detect</div>
</div><!-- fragment --><p>Processors are <b>non-commutative</b>. Audio math doesn't follow algebra rules.</p>
<p>Order determines signal flow. You're building a graph, not an equation.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md392"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Adaptive dynamics (compress quiet, expand loud)</span></div>
<div class="line"><span class="keyword">auto</span> logic = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.3);</div>
<div class="line"><span class="keyword">auto</span> poly_compress = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> x * 2.0; });</div>
<div class="line"><span class="keyword">auto</span> poly_expand = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> x * 0.5; });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Route based on logic state (requires custom modulation)</span></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md394"></a>
Tutorial: Processing Chains and Buffer Architecture</h1>
<h2><a class="anchor" id="autotoc_md395"></a>
Tutorial: Explicit Chain Building</h2>
<h3><a class="anchor" id="autotoc_md396"></a>
The Simplest Path</h3>
<p>You've been adding processors one at a time. Now control their order explicitly.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> sound = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0.html#a8437a7d641c0011d359c38f13881adc0">read_audio</a>(<span class="stringliteral">&quot;path/to/file.wav&quot;</span>) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> buffer = <a class="code hl_function" href="namespaceMayaFlux_a16a769fcbec756197086526ac9297aa8.html#a16a769fcbec756197086526ac9297aa8">MayaFlux::get_last_created_container_buffers</a>()[0];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create an empty chain</span></div>
<div class="line">    <span class="keyword">auto</span> chain = <a class="code hl_function" href="namespaceMayaFlux_a2b1e7c1f92d6a0a70984440e9f32081c.html#a2b1e7c1f92d6a0a70984440e9f32081c">MayaFlux::create_processing_chain</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Build the chain: Distortion → Gate → Compression</span></div>
<div class="line">    <span class="keyword">auto</span> distortion = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> std::tanh(x * 2.0); });</div>
<div class="line">    <span class="keyword">auto</span> gate = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.1);</div>
<div class="line">    <span class="keyword">auto</span> compression = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> x / (1.0 + std::abs(x)); });</div>
<div class="line"> </div>
<div class="line">    chain-&gt;add_processor(std::make_shared&lt;PolynomialProcessor&gt;(distortion), buffer);</div>
<div class="line">    chain-&gt;add_processor(std::make_shared&lt;LogicProcessor&gt;(gate), buffer);</div>
<div class="line">    chain-&gt;add_processor(std::make_shared&lt;PolynomialProcessor&gt;(compression), buffer);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Attach the chain to the buffer</span></div>
<div class="line">    buffer-&gt;set_processing_chain(chain);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Run this. You hear: clean audio → saturated → gated (silence below threshold) → compressed (controlled peaks).</p>
<p><b>Swap the order:</b></p>
<div class="fragment"><div class="line">chain-&gt;add_processor(gate_processor);      <span class="comment">// Gate first</span></div>
<div class="line">chain-&gt;add_processor(distortion_processor); <span class="comment">// Then distort</span></div>
<div class="line">chain-&gt;add_processor(compression_processor);</div>
</div><!-- fragment --><p>Different sound. Order matters.</p>
<h2><a class="anchor" id="autotoc_md397"></a>
Expansion 1: What &lt;tt&gt;create_processor()&lt;/tt&gt; Was Doing</h2>
<details >
<summary >
Click to expand: Implicit vs. Explicit Chain Management</summary>
<p></p>
<p>Previously, when you wrote:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> processor = MayaFlux::create_processor&lt;PolynomialProcessor&gt;(buffer, poly);</div>
</div><!-- fragment --><p><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> did this behind the scenes:</p>
<ol type="1">
<li>Created the processor</li>
<li>Got the buffer's existing processing chain</li>
<li><b>Automatically added the processor to that chain</b></li>
<li>Returned the processor</li>
</ol>
<p>You didn't see this because it was implicit. The processor was silently appended to whatever chain existed.</p>
<p><b>Now you're building chains explicitly:</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> chain = <a class="code hl_function" href="namespaceMayaFlux_a2b1e7c1f92d6a0a70984440e9f32081c.html#a2b1e7c1f92d6a0a70984440e9f32081c">MayaFlux::create_processing_chain</a>();  <span class="comment">// Empty chain</span></div>
<div class="line">chain-&gt;add_processor(proc1);  <span class="comment">// Manual control</span></div>
<div class="line">chain-&gt;add_processor(proc2);</div>
<div class="line">buffer-&gt;set_processing_chain(chain);  <span class="comment">// Replace buffer&#39;s chain</span></div>
</div><!-- fragment --><p><b>When to use explicit chains:</b></p>
<ul>
<li>You need precise order control</li>
<li>You're building reusable processor "presets"</li>
<li>You want to swap entire chains dynamically (e.g., switch between clean/distorted modes)</li>
<li>You're debugging processor interactions</li>
</ul>
<p><b>When implicit is fine:</b></p>
<ul>
<li>Simple cases (1-2 processors)</li>
<li>Order doesn't matter (parallel-like effects)</li>
<li>Rapid prototyping</li>
</ul>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md398"></a>
Expansion 2: Chain Execution Order</h2>
<details >
<summary >
Click to expand: Sequential Data Flow</summary>
<p></p>
<p>Chains execute like a for-loop over processors:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; processor : chain-&gt;get_processors()) {</div>
<div class="line">    processor-&gt;process(buffer);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Data flows sequentially:</p>
<div class="fragment"><div class="line">Container → Buffer (512 samples)</div>
<div class="line">    ↓</div>
<div class="line">Processor₁: Distortion (modifies samples in-place)</div>
<div class="line">    ↓</div>
<div class="line">Processor₂: Gate (zeroes out quiet samples)</div>
<div class="line">    ↓</div>
<div class="line">Processor₃: Compression (reduces peaks)</div>
<div class="line">    ↓</div>
<div class="line">Speakers</div>
</div><!-- fragment --><p>Each processor sees the <b>output</b> of the previous processor.</p>
<p><b>This is not parallel processing.</b> No branches. No simultaneous paths. Pure sequential transformation.</p>
<p>(Parallel routing requires <code>BufferPipeline</code>—covered in a later tutorial.)</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md399"></a>
Expansion 3: Default Processors vs. Chain Processors</h2>
<details >
<summary >
Click to expand: The Two-Stage Processing Model</summary>
<p></p>
<p>Every buffer has two processing stages:</p>
<p><b>Stage 1: Default Processor</b> (runs first, always)</p>
<ul>
<li>Defined by buffer type</li>
<li>Handles data <b>acquisition</b> or <b>generation</b></li>
<li>Examples:<ul>
<li><code>SoundContainerBuffer</code>: reads from file/stream</li>
<li><code>NodeBuffer</code>: evaluates a node</li>
<li><code>FeedbackBuffer</code>: mixes current + previous buffer</li>
<li><code>AudioBuffer</code>: none (generic accumulator)</li>
</ul>
</li>
</ul>
<p><b>Stage 2: Processing Chain</b> (runs second)</p>
<ul>
<li>Your custom processors</li>
<li>Handles data <b>transformation</b></li>
<li>Examples: filters, waveshaping, logic, etc.</li>
</ul>
<p><b>Execution flow:</b></p>
<div class="fragment"><div class="line">1. Buffer&#39;s default processor runs (fills buffer with data)</div>
<div class="line">2. Processing chain runs (transforms that data)</div>
<div class="line">3. Result goes to speakers</div>
</div><!-- fragment --><p>When you add processors via <code>create_processor()</code>, they go into <b>Stage 2</b> (the chain).</p>
<p>The <b>default processor</b> is fixed per buffer type. You can replace it, but usually you don't need to—the chain is where creativity happens.</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md401"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Stack multiple distortions (cascading saturation)</span></div>
<div class="line"><span class="keyword">auto</span> chain = <a class="code hl_function" href="namespaceMayaFlux_a2b1e7c1f92d6a0a70984440e9f32081c.html#a2b1e7c1f92d6a0a70984440e9f32081c">MayaFlux::create_processing_chain</a>();</div>
<div class="line"><span class="keyword">auto</span> light = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> std::tanh(x * 1.5); });</div>
<div class="line"><span class="keyword">auto</span> heavy = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> std::tanh(x * 5.0); });</div>
<div class="line"><span class="keyword">auto</span> fold = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> std::sin(x * 3.0); });</div>
<div class="line"> </div>
<div class="line">chain-&gt;add_processor(std::make_shared&lt;PolynomialProcessor&gt;( light), buffer);</div>
<div class="line">chain-&gt;add_processor(std::make_shared&lt;PolynomialProcessor&gt;( heavy), buffer);</div>
<div class="line">chain-&gt;add_processor(std::make_shared&lt;PolynomialProcessor&gt;( fold), buffer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Insert gating between stages</span></div>
<div class="line"><span class="keyword">auto</span> gate = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.2);</div>
<div class="line">chain-&gt;add_processor(std::make_shared&lt;PolynomialProcessor&gt;( light), buffer);</div>
<div class="line">chain-&gt;add_processor(std::make_shared&lt;LogicProcessor&gt;( gate), buffer);  <span class="comment">// Gate the distortion</span></div>
<div class="line">chain-&gt;add_processor(std::make_shared&lt;PolynomialProcessor&gt;( heavy), buffer); <span class="comment">// Distort the gated signal</span></div>
<div class="line"> </div>
<div class="line">buffer-&gt;set_processing_chain(chain);</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md403"></a>
Tutorial: Various Buffer Types</h1>
<h2><a class="anchor" id="autotoc_md404"></a>
Generating from Nodes (NodeBuffer)</h2>
<h3><a class="anchor" id="autotoc_md405"></a>
The Next Pattern</h3>
<p>So far: buffers read from files, nodes affect buffer processing. Now: buffers <b>generate</b> from nodes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="comment">// Create a sine node</span></div>
<div class="line">    <span class="keyword">auto</span> sine = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(440.0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a NodeBuffer that captures the sine&#39;s output</span></div>
<div class="line">    <span class="keyword">auto</span> node_buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, sine)[0] | Audio;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add processing to the generated audio</span></div>
<div class="line">    <span class="keyword">auto</span> distortion = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> x * x * x; });</div>
<div class="line">    MayaFlux::create_processor&lt;PolynomialProcessor&gt;(node_buffer, distortion);</div>
<div class="line">}</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7_html_aec27c48bde31eca7f7c808b59f300fb7"><div class="ttname"><a href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">MayaFlux::Creator::NodeBuffer</a></div><div class="ttdeci">auto NodeBuffer(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Buffers::NodeBuffer &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00210">Creator.hpp:210</a></div></div>
</div><!-- fragment --><p>Run this. You hear a 440 Hz sine wave with cubic distortion.</p>
<p>No file loaded. The buffer <b>generates</b> audio by evaluating the node 512 times per cycle.</p>
<h3><a class="anchor" id="autotoc_md406"></a>
Expansion 1: What NodeBuffer Does</h3>
<details >
<summary >
Click to expand: Nodes → Buffers Bridge</summary>
<p></p>
<p><code>NodeBuffer</code> connects the <b>node system</b> (sample-by-sample evaluation) to the <b>buffer system</b> (block-based processing).</p>
<p><b>Default processor: <code>NodeSourceProcessor</code></b></p>
<p>Each cycle:</p>
<ol type="1">
<li>Node is evaluated 512 times: <code>node-&gt;process_sample()</code></li>
<li>Results fill the buffer</li>
<li>Processing chain runs (your custom processors)</li>
<li>Buffer outputs to speakers</li>
</ol>
<p><b>Why this matters:</b></p>
<p>Nodes are mathematical expressions—infinite generators. Buffers are temporal accumulators—finite chunks.</p>
<p><code>NodeBuffer</code> bridges the two: <b>continuous expression → discrete blocks</b>.</p>
<p>Without <code>NodeBuffer</code>, you'd manually call <code>node-&gt;process_sample()</code> 512 times and copy results into a buffer. <code>NodeBuffer</code> automates this.</p>
<p></p>
</details>
<h3><a class="anchor" id="autotoc_md407"></a>
Expansion 2: The &lt;tt&gt;clear_before_process&lt;/tt&gt; Parameter</h3>
<details >
<summary >
Click to expand: Accumulation vs. Replacement</summary>
<p></p>
<p><code>NodeBuffer</code> has a flag: <code>clear_before_process</code></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> node_buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, sine, <span class="keyword">true</span>);  <span class="comment">// Clear first (default)</span></div>
</div><!-- fragment --><p><b>true (default)</b>: Buffer is zeroed, then filled with node output</p>
<ul>
<li>Result: pure node output</li>
</ul>
<p><b>false</b>: Node output is <b>added</b> to existing buffer content</p>
<ul>
<li>Result: node output + previous buffer state</li>
</ul>
<p>Why use <code>false</code>?</p>
<ul>
<li><b>Layering</b>: Multiple nodes contributing to the same buffer</li>
<li><b>Feedback</b>: Previous cycle's output influences current cycle</li>
<li><b>Additive synthesis</b>: Mix multiple generators</li>
</ul>
<p>Example (layering):</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sine = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(440.0);</div>
<div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, sine, <span class="keyword">true</span>)[0] | Audio;  <span class="comment">// First node clears</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> noise = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">Random</a>();</div>
<div class="line"><span class="keyword">auto</span> noise_buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, noise, <span class="keyword">false</span>)[0] | Audio;  <span class="comment">// Adds to sine</span></div>
</div><!-- fragment --><p>Result: sine + noise.</p>
<p></p>
</details>
<h3><a class="anchor" id="autotoc_md408"></a>
Expansion 3: NodeSourceProcessor Mix Parameter</h3>
<details >
<summary >
Click to expand: Interpolation Between Existing and Incoming Data</summary>
<p></p>
<p><code>NodeSourceProcessor</code> has a <code>mix</code> parameter (default: 0.5):</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> processor = std::make_shared&lt;NodeSourceProcessor&gt;(node, 0.7f);</div>
</div><!-- fragment --><p><b>Mix = 0.0</b>: Preserve existing buffer content (node output ignored) <b>Mix = 0.5</b>: Equal blend of existing + node output <b>Mix = 1.0</b>: Replace with node output (existing content overwritten)</p>
<p>This is a <b>cross-fade</b> between what's in the buffer and what the node generates.</p>
<p><b>Use case</b>: Smoothly transition between sources, or create feedback loops where node output gradually replaces decaying buffer content.</p>
<p>Most of the time, you'll use the default (1.0 via <code>clear_before_process=true</code>). But for creative effects, <code>mix</code> is powerful.</p>
<p></p>
</details>
<hr  />
<h3><a class="anchor" id="autotoc_md410"></a>
Try It</h3>
<div class="fragment"><div class="line"><span class="comment">// Additive synthesis (multiple generators in one buffer)</span></div>
<div class="line"><span class="keyword">auto</span> fund = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(220.0);</div>
<div class="line"><span class="keyword">auto</span> harm2 = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(440.0);</div>
<div class="line"><span class="keyword">auto</span> harm3 = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(660.0);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, fund, <span class="keyword">true</span>)[0] | Audio;   <span class="comment">// First clears</span></div>
<div class="line">vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, harm2, <span class="keyword">false</span>)[0] | Audio;  <span class="comment">// Adds harmonic 2</span></div>
<div class="line">vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, harm3, <span class="keyword">false</span>)[0] | Audio;  <span class="comment">// Adds harmonic 3</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Waveshaping a generated tone</span></div>
<div class="line"><span class="keyword">auto</span> sine = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(110.0);</div>
<div class="line"><span class="keyword">auto</span> buffer2 = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, sine)[1] | Audio;</div>
<div class="line"><span class="keyword">auto</span> waveshape = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> std::tanh(x * 10.0); });</div>
<div class="line">MayaFlux::create_processor&lt;PolynomialProcessor&gt;(buffer2, waveshape);</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md412"></a>
FeedbackBuffer (Recursive Audio)</h2>
<h3><a class="anchor" id="autotoc_md413"></a>
The Pattern</h3>
<p>Buffers that <b>remember</b> their previous state.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="comment">// FeedbackBuffer: 70% feedback, 512 samples delay</span></div>
<div class="line">    <span class="keyword">auto</span> feedback_buf = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe.html#ab85cfd01b90a6a4684925d773afaf2fe">FeedbackBuffer</a>(0, 512, 0.7f, 512)[0] | Audio;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Feed an impulse into the buffer to kick-start resonance</span></div>
<div class="line">    <span class="keyword">auto</span> impulse = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a505c21d622a701dd6f2bc18962e8e45b.html#a505c21d622a701dd6f2bc18962e8e45b">Impulse</a>(2.0);  <span class="comment">// 2 Hz pulse train</span></div>
<div class="line">    vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, impulse, <span class="keyword">false</span>)[0] | Audio;  <span class="comment">// Adds to feedback buffer</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// WARN: Remember to turn OFF aftera a few seconds as feedback can build up!</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a505c21d622a701dd6f2bc18962e8e45b_html_a505c21d622a701dd6f2bc18962e8e45b"><div class="ttname"><a href="classMayaFlux_1_1Creator_a505c21d622a701dd6f2bc18962e8e45b.html#a505c21d622a701dd6f2bc18962e8e45b">MayaFlux::Creator::Impulse</a></div><div class="ttdeci">auto Impulse(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Generator::Impulse &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe_html_ab85cfd01b90a6a4684925d773afaf2fe"><div class="ttname"><a href="classMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe.html#ab85cfd01b90a6a4684925d773afaf2fe">MayaFlux::Creator::FeedbackBuffer</a></div><div class="ttdeci">auto FeedbackBuffer(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Buffers::FeedbackBuffer &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00210">Creator.hpp:210</a></div></div>
</div><!-- fragment --><p>Run this. You hear: repeating echoes, each 70% of the previous amplitude.</p>
<p>The buffer **feeds back into itself**—output becomes input next cycle.</p>
<h3><a class="anchor" id="autotoc_md414"></a>
Expansion 1: What FeedbackBuffer Does</h3>
<details >
<summary >
Click to expand: Recursive Temporal Processing</summary>
<p></p>
<p><b>Default processor: <code>FeedbackProcessor</code></b></p>
<p>Each cycle:</p>
<ol type="1">
<li>Current buffer content: <code>buffer[n]</code></li>
<li>Previous buffer content: <code>previous_buffer[n-1]</code></li>
<li>Output: <code>buffer[n] + (feedback_amount * previous_buffer[n-1])</code></li>
<li>Store output as next cycle's "previous"</li>
</ol>
<p>This is a <b>simple delay line</b> with feedback.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>feedback_amount</code>: 0.0–1.0 (how much previous state contributes)</li>
<li><code>feed_samples</code>: Delay length in samples</li>
</ul>
<p>Example: <code>FeedbackBuffer(0, 512, 0.7, 512)</code> creates:</p>
<ul>
<li>512-sample delay (~10.6 ms at 48 kHz)</li>
<li>70% feedback (echoes decay to 0.7 → 0.49 → 0.343 → ...)</li>
</ul>
<p><b>Stability:</b> Keep <code>feedback_amount &lt; 1.0</code> or output will grow unbounded.</p>
<p></p>
</details>
<h3><a class="anchor" id="autotoc_md415"></a>
Expansion 2: FeedbackBuffer Limitations</h3>
<details >
<summary >
Click to expand: What FeedbackBuffer Cannot Do</summary>
<p></p>
<p><code>FeedbackBuffer</code> is simple—intentionally. It implements <b>one specific recursive algorithm</b>: linear feedback delay.</p>
<p><b>Limitations:</b></p>
<ol type="1">
<li><b>Fixed feedback coefficient</b>: Can't modulate feedback amount per sample (it's buffer-wide)</li>
<li><b>No filtering in loop</b>: Can't insert lowpass/highpass in the feedback path</li>
<li><b>No cross-channel feedback</b>: Single-channel only</li>
<li><b>No time-varying delay</b>: Delay length is fixed at creation</li>
</ol>
<p><b>Why these limitations?</b></p>
<p><code>FeedbackBuffer</code> is a <b>building block</b>, not a complete reverb/delay effect.</p>
<p>For complex feedback systems:</p>
<ul>
<li>Use <code>PolynomialProcessor</code> in <code>RECURSIVE</code> mode (per-sample nonlinear feedback)</li>
<li>Use <code>BufferPipeline</code> to route buffers back to themselves with processing</li>
<li>Build custom feedback networks with multiple buffers</li>
</ul>
<p><code>FeedbackBuffer</code> is for **simple echoes and resonances**—quick and efficient.</p>
<p></p>
</details>
<h3><a class="anchor" id="autotoc_md416"></a>
Expansion 3: When to Use FeedbackBuffer</h3>
<details >
<summary >
Click to expand: Use Cases and Alternatives</summary>
<p></p>
<p><b>Use <code>FeedbackBuffer</code> when:</b></p>
<ul>
<li>You need a simple delay line with fixed feedback</li>
<li>Building Karplus-Strong string synthesis</li>
<li>Creating rhythmic echoes</li>
<li>Implementing comb filters</li>
</ul>
<p><b>Use <code>PolynomialProcessor(RECURSIVE)</code> when:</b></p>
<ul>
<li>You need nonlinear feedback (saturation, distortion in loop)</li>
<li>Feedback amount varies per sample</li>
<li>Building filters with arbitrary feedback functions</li>
</ul>
<p><b>Use <code>BufferPipeline</code> when:</b></p>
<ul>
<li>You need complex routing (buffer A → process → buffer B → back to A)</li>
<li>Multi-buffer feedback networks</li>
<li>Cross-channel feedback</li>
</ul>
<p><b>Example: Filtered feedback (requires multiple approaches):</b></p>
<div class="fragment"><div class="line"><span class="comment">// FeedbackBuffer can&#39;t do this alone:</span></div>
<div class="line"><span class="comment">// current + lowpass(feedback * previous)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Solution: Use PolynomialProcessor RECURSIVE mode with filtering</span></div>
<div class="line"><span class="keyword">auto</span> filtered_feedback = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>(</div>
<div class="line">    [](std::span&lt;double&gt; history) {</div>
<div class="line">        <span class="keywordtype">double</span> fb = 0.7 * history[0];</div>
<div class="line">        <span class="keywordflow">return</span> fb * 0.5 + history[1] * 0.5;  <span class="comment">// Simple lowpass</span></div>
<div class="line">    },</div>
<div class="line">    PolynomialMode::RECURSIVE,</div>
<div class="line">    2</div>
<div class="line">);</div>
</div><!-- fragment --><p></p>
</details>
<hr  />
<h3><a class="anchor" id="autotoc_md418"></a>
Try It</h3>
<div class="fragment"><div class="line"><span class="comment">// Karplus-Strong string (plucked string synthesis)</span></div>
<div class="line"><span class="keyword">auto</span> feedback_buf = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe.html#ab85cfd01b90a6a4684925d773afaf2fe">FeedbackBuffer</a>(0, 512, 0.996f, 100)[0] | Audio;  <span class="comment">// ~480 Hz</span></div>
<div class="line"><span class="comment">// Excite with noise burst</span></div>
<div class="line"><span class="keyword">auto</span> noise = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">Random</a>();</div>
<div class="line">vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, noise, <span class="keyword">false</span>)[0] | Audio;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Ping-pong delay (requires two buffers—teaser for later)</span></div>
<div class="line"><span class="comment">// auto left = vega.FeedbackBuffer(0, 512, 0.6f, 2400)[0] | Audio;</span></div>
<div class="line"><span class="comment">// auto right = vega.FeedbackBuffer(1, 512, 0.6f, 2400)[1] | Audio;</span></div>
<div class="line"><span class="comment">// Route left → right, right → left (needs BufferPipeline)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Resonant comb filter</span></div>
<div class="line"><span class="keyword">auto</span> feedback_buf2 = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe.html#ab85cfd01b90a6a4684925d773afaf2fe">FeedbackBuffer</a>(0, 512, 0.95f, 50)[1] | Audio;</div>
<div class="line"><span class="keyword">auto</span> input = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(220.0);</div>
<div class="line">vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, input, <span class="keyword">false</span>)[1] | Audio;</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md420"></a>
SoundStreamWriter (Capturing Audio)</h2>
<h3><a class="anchor" id="autotoc_md421"></a>
The Pattern</h3>
<p>Processors that <b>write</b> buffer data somewhere (instead of transforming it).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> sound = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0.html#a8437a7d641c0011d359c38f13881adc0">read_audio</a>(<span class="stringliteral">&quot;path/to/file.wav&quot;</span>) | Audio;</div>
<div class="line">    <span class="keyword">auto</span> buffer = <a class="code hl_function" href="namespaceMayaFlux_a16a769fcbec756197086526ac9297aa8.html#a16a769fcbec756197086526ac9297aa8">MayaFlux::get_last_created_container_buffers</a>()[0];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a DynamicSoundStream (accumulator for captured audio)</span></div>
<div class="line">    <span class="keyword">auto</span> capture_stream = std::make_shared&lt;DynamicSoundStream&gt;(48000, 2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a processor that writes buffer data to the stream</span></div>
<div class="line">    <span class="keyword">auto</span> writer = std::make_shared&lt;SoundStreamWriter&gt;(capture_stream);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add to buffer&#39;s processing chain</span></div>
<div class="line">    <span class="keyword">auto</span> chain = buffer-&gt;get_processing_chain();</div>
<div class="line">    chain-&gt;add_processor(writer);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// File plays AND is captured to stream simultaneously</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Run this. The file plays <b>and</b> is written to <code>capture_stream</code> every cycle.</p>
<p>After playback, <code>capture_stream</code> contains a copy of the entire file (processed through any other processors in the chain before the writer).</p>
<h3><a class="anchor" id="autotoc_md422"></a>
Expansion 1: What SoundStreamWriter Does</h3>
<details >
<summary >
Click to expand: Buffers → Containers Bridge</summary>
<p></p>
<p><code>SoundStreamWriter</code> is the <b>inverse</b> of <code>SoundContainerBuffer</code>:</p>
<ul>
<li><b>SoundContainerBuffer</b>: reads from container → fills buffer (source)</li>
<li><b>SoundStreamWriter</b>: reads from buffer → writes to container (sink)</li>
</ul>
<p><b>Each cycle:</b></p>
<ol type="1">
<li>Extract 512 samples from the buffer</li>
<li>Write them to the <code>DynamicSoundStream</code> at the current write position</li>
<li>Increment write position by 512</li>
</ol>
<p>The stream grows dynamically as data arrives. No pre-allocation needed (though you can for performance).</p>
<p><b>Use cases:</b></p>
<ul>
<li>Record processed audio to memory</li>
<li>Capture intermediate processing stages for analysis</li>
<li>Build delay lines / loopers</li>
<li>Create feedback paths (buffer → stream → buffer)</li>
</ul>
<p></p>
</details>
<h3><a class="anchor" id="autotoc_md423"></a>
Expansion 2: Channel-Aware Writing</h3>
<details >
<summary >
Click to expand: Multi-Channel Capture</summary>
<p></p>
<p><code>SoundStreamWriter</code> respects buffer channel IDs:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> left_buffer = buffers[0];   <span class="comment">// channel 0</span></div>
<div class="line"><span class="keyword">auto</span> right_buffer = buffers[1];  <span class="comment">// channel 1</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> stream = std::make_shared&lt;DynamicSoundStream&gt;(48000, 2);  <span class="comment">// stereo</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> writer_L = std::make_shared&lt;SoundStreamWriter&gt;(stream);</div>
<div class="line"><span class="keyword">auto</span> writer_R = std::make_shared&lt;SoundStreamWriter&gt;(stream);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add to respective buffers</span></div>
<div class="line">left_buffer-&gt;get_processing_chain()-&gt;add_processor(writer_L);</div>
<div class="line">right_buffer-&gt;get_processing_chain()-&gt;add_processor(writer_R);</div>
</div><!-- fragment --><p>Result: Stereo file captured to stereo stream—channels preserved.</p>
<p><b>Critical:</b> Buffer's <code>channel_id</code> determines which stream channel receives data. Mismatch = warning + skip.</p>
<p></p>
</details>
<h3><a class="anchor" id="autotoc_md424"></a>
Expansion 3: Position Management</h3>
<details >
<summary >
Click to expand: Write Position Control</summary>
<p></p>
<p><code>SoundStreamWriter</code> tracks where it's writing:</p>
<div class="fragment"><div class="line">writer-&gt;set_write_position(0);        <span class="comment">// Write from start</span></div>
<div class="line">writer-&gt;set_write_position(48000);    <span class="comment">// Write from 1-second mark</span></div>
<div class="line">writer-&gt;reset_position();             <span class="comment">// Reset to 0</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Time-based positioning</span></div>
<div class="line">writer-&gt;set_write_position_time(2.5); <span class="comment">// Write from 2.5 seconds</span></div>
<div class="line"> </div>
<div class="line">uint64_t pos = writer-&gt;get_write_position();           <span class="comment">// Get current frame position</span></div>
<div class="line"><span class="keywordtype">double</span> time = writer-&gt;get_write_position_time();       <span class="comment">// Get current time position</span></div>
</div><!-- fragment --><p><b>Why control position?</b></p>
<ul>
<li><b>Overdubbing</b>: Write new audio over existing content</li>
<li><b>Looping</b>: Reset position to create cyclic recording</li>
<li><b>Multi-pass recording</b>: Capture different takes at different positions</li>
</ul>
<p>Default behavior: append at end. Position auto-increments.</p>
<p></p>
</details>
<h3><a class="anchor" id="autotoc_md425"></a>
Expansion 4: Circular Mode</h3>
<details >
<summary >
Click to expand: Fixed-Size Circular Buffers</summary>
<p></p>
<p><code>DynamicSoundStream</code> can operate in <b>circular mode</b>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> stream = std::make_shared&lt;DynamicSoundStream&gt;(48000, 2);</div>
<div class="line">stream-&gt;enable_circular_buffer(48000);  <span class="comment">// 1 second capacity</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> writer = std::make_shared&lt;SoundStreamWriter&gt;(stream);</div>
</div><!-- fragment --><p><b>Behavior:</b></p>
<p>When write position reaches capacity, it wraps to 0. Old data is overwritten.</p>
<p><b>Use cases:</b></p>
<ul>
<li><b>Delay lines</b>: Fixed-length delays for effects</li>
<li><b>Loopers</b>: Record N seconds, then loop</li>
<li><b>Rolling analysis</b>: Keep only the most recent N seconds</li>
</ul>
<p>Without circular mode, the stream grows unbounded—useful for full recording, problematic for long-running systems.</p>
<p></p>
</details>
<hr  />
<h3><a class="anchor" id="autotoc_md427"></a>
Try It</h3>
<div class="fragment"><div class="line"><span class="comment">// Record 5 seconds of audio</span></div>
<div class="line"><span class="keyword">auto</span> sound = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8437a7d641c0011d359c38f13881adc0.html#a8437a7d641c0011d359c38f13881adc0">read_audio</a>(<span class="stringliteral">&quot;path/to/file.wav&quot;</span>) | Audio;</div>
<div class="line"><span class="keyword">auto</span> buffer = <a class="code hl_function" href="namespaceMayaFlux_a16a769fcbec756197086526ac9297aa8.html#a16a769fcbec756197086526ac9297aa8">MayaFlux::get_last_created_container_buffers</a>()[0];</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> stream = std::make_shared&lt;DynamicSoundStream&gt;(48000, 1);</div>
<div class="line">stream-&gt;ensure_capacity(48000 * 5);  <span class="comment">// Pre-allocate 5 seconds</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> writer = std::make_shared&lt;SoundStreamWriter&gt;(stream);</div>
<div class="line">buffer-&gt;get_processing_chain()-&gt;add_processor(writer, buffer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After playback, stream contains the audio</span></div>
<div class="line"><span class="comment">// You can analyze it, write to disk, or feed it back</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Circular delay (1 second)</span></div>
<div class="line"><span class="keyword">auto</span> stream2 = std::make_shared&lt;DynamicSoundStream&gt;(48000, 1);</div>
<div class="line">stream2-&gt;enable_circular_buffer(48000);  <span class="comment">// Loop after 1 second</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> writer2 = std::make_shared&lt;SoundStreamWriter&gt;(stream);</div>
<div class="line">buffer-&gt;get_processing_chain()-&gt;add_processor(writer, buffer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Stream now acts as a 1-second tape loop</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md428"></a>
Closing: The Buffer Ecosystem</h2>
<p>You now understand:</p>
<p><b>Buffer Types:</b></p>
<ul>
<li><code>AudioBuffer</code>: Generic accumulator</li>
<li><code>SoundContainerBuffer</code>: Reads from files/streams (default: <code>SoundStreamReader</code>)</li>
<li><code>NodeBuffer</code>: Generates from nodes (default: <code>NodeSourceProcessor</code>)</li>
<li><code>FeedbackBuffer</code>: Recursive delay (default: <code>FeedbackProcessor</code>)</li>
</ul>
<p><b>Processor Types:</b></p>
<ul>
<li><code>PolynomialProcessor</code>: Waveshaping, filters, recursive math</li>
<li><code>LogicProcessor</code>: Decisions, gates, triggers</li>
<li><code>SoundStreamWriter</code>: Capture to containers</li>
</ul>
<p><b>Processing Flow:</b></p>
<div class="fragment"><div class="line">Default Processor (acquire/generate data)</div>
<div class="line">    ↓</div>
<div class="line">Processing Chain (transform data)</div>
<div class="line">    ↓</div>
<div class="line">Output (speakers/containers/other buffers)</div>
</div><!-- fragment --><p><b>Next:</b> Buffer routing, cloning, and supply mechanics—how to send processed buffers to multiple channels/domains.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md430"></a>
Tutorial: Audio Input, Routing, and Multi-Channel Distribution</h1>
<h2><a class="anchor" id="autotoc_md431"></a>
Tutorial: Capturing Audio Input</h2>
<h3><a class="anchor" id="autotoc_md432"></a>
The Simplest Path</h3>
<p>So far: buffers read from files or generate from nodes. Now: capture from your microphone.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> settings() {</div>
<div class="line">    <span class="keyword">auto</span>&amp; stream = <a class="code hl_function" href="namespaceMayaFlux_1_1Config_add02a960f8fdc0d03e7d4c0aa3c2b518.html#add02a960f8fdc0d03e7d4c0aa3c2b518">MayaFlux::Config::get_global_stream_info</a>();</div>
<div class="line">    stream.input.enabled = <span class="keyword">true</span>;   <span class="comment">// Enable microphone input</span></div>
<div class="line">    stream.input.channels = 1;      <span class="comment">// Mono input</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="comment">// Create a buffer that listens to microphone channel 0</span></div>
<div class="line">    <span class="keyword">auto</span> mic_buffer = <a class="code hl_function" href="namespaceMayaFlux_a156aa5a54a2a941e0eb8f9618d601be1.html#a156aa5a54a2a941e0eb8f9618d601be1">MayaFlux::create_input_listener_buffer</a>(0, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add processing to the live input</span></div>
<div class="line">    <span class="keyword">auto</span> distortion = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> std::tanh(x * 3.0); });</div>
<div class="line">    MayaFlux::create_processor&lt;PolynomialProcessor&gt;(mic_buffer, distortion);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceMayaFlux_1_1Config_add02a960f8fdc0d03e7d4c0aa3c2b518_html_add02a960f8fdc0d03e7d4c0aa3c2b518"><div class="ttname"><a href="namespaceMayaFlux_1_1Config_add02a960f8fdc0d03e7d4c0aa3c2b518.html#add02a960f8fdc0d03e7d4c0aa3c2b518">MayaFlux::Config::get_global_stream_info</a></div><div class="ttdeci">Core::GlobalStreamInfo &amp; get_global_stream_info()</div><div class="ttdoc">Gets the stream configuration from the default engine.</div><div class="ttdef"><b>Definition</b> <a href="Config_8cpp_source.html#l00019">Config.cpp:19</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_a156aa5a54a2a941e0eb8f9618d601be1_html_a156aa5a54a2a941e0eb8f9618d601be1"><div class="ttname"><a href="namespaceMayaFlux_a156aa5a54a2a941e0eb8f9618d601be1.html#a156aa5a54a2a941e0eb8f9618d601be1">MayaFlux::create_input_listener_buffer</a></div><div class="ttdeci">std::shared_ptr&lt; Buffers::AudioBuffer &gt; create_input_listener_buffer(uint32_t channel, bool add_to_output)</div><div class="ttdoc">Creates a new AudioBuffer for input listening.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00243">Graph.cpp:243</a></div></div>
</div><!-- fragment --><p>Run this. Speak into your microphone. You hear yourself with distortion applied in real-time.</p>
<h2><a class="anchor" id="autotoc_md433"></a>
Expansion 1: What &lt;tt&gt;create_input_listener_buffer()&lt;/tt&gt; Does</h2>
<details >
<summary >
Click to expand: Input System Architecture</summary>
<p></p>
<p><a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> has a dedicated <b>input subsystem</b> parallel to the output system.</p>
<p><b>Architecture:</b></p>
<div class="fragment"><div class="line">Hardware (Microphone)</div>
<div class="line">    ↓</div>
<div class="line">Audio Driver (RtAudio)</div>
<div class="line">    ↓</div>
<div class="line">BufferManager::process_input()</div>
<div class="line">    ↓</div>
<div class="line">InputAudioBuffer (per input channel)</div>
<div class="line">    ↓</div>
<div class="line">InputAccessProcessor (dispatches to listeners)</div>
<div class="line">    ↓</div>
<div class="line">Your listener buffers</div>
</div><!-- fragment --><p>When you call <code>create_input_listener_buffer(channel, add_to_output)</code>:</p>
<ol type="1">
<li>Creates a new <code>AudioBuffer</code></li>
<li>Registers it with <code>InputAudioBuffer[channel]</code> as a <b>listener</b></li>
<li>If <code>add_to_output=true</code>: Also registers it with output channel (so it plays back)</li>
</ol>
<p><b>Each audio cycle:</b></p>
<ul>
<li>Driver captures microphone data</li>
<li><code>InputAudioBuffer</code> receives it</li>
<li><code>InputAccessProcessor</code> <b>copies</b> data to all registered listeners</li>
<li>Your buffer gets fresh input every cycle</li>
</ul>
<p><b>Key insight:</b> <code>InputAudioBuffer</code> is a <b>hub</b>. Multiple buffers can listen to the same input channel simultaneously.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md434"></a>
Expansion 2: Manual Input Registration</h2>
<details >
<summary >
Click to expand: Fine-Grained Control</summary>
<p></p>
<p><code>create_input_listener_buffer()</code> is convenience. You can do it manually:</p>
<div class="fragment"><div class="line"><span class="comment">// Create your own buffer</span></div>
<div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c.html#a9fa2fd237baef3835e5d987262293c2c">AudioBuffer</a>()[0] | Audio;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register it as input listener</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_af1b88433262575214bbc89823736358c.html#af1b88433262575214bbc89823736358c">MayaFlux::read_from_audio_input</a>(buffer, 0);  <span class="comment">// Listen to input channel 0</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later, stop listening:</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_aa01b246fe947237c4ecc3b71d3984df9.html#aa01b246fe947237c4ecc3b71d3984df9">MayaFlux::detach_from_audio_input</a>(buffer, 0);</div>
<div class="ttc" id="anamespaceMayaFlux_aa01b246fe947237c4ecc3b71d3984df9_html_aa01b246fe947237c4ecc3b71d3984df9"><div class="ttname"><a href="namespaceMayaFlux_aa01b246fe947237c4ecc3b71d3984df9.html#aa01b246fe947237c4ecc3b71d3984df9">MayaFlux::detach_from_audio_input</a></div><div class="ttdeci">void detach_from_audio_input(const std::shared_ptr&lt; Buffers::AudioBuffer &gt; &amp;buffer, uint32_t channel)</div><div class="ttdoc">Stops reading audio data from the default input source.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00238">Graph.cpp:238</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_af1b88433262575214bbc89823736358c_html_af1b88433262575214bbc89823736358c"><div class="ttname"><a href="namespaceMayaFlux_af1b88433262575214bbc89823736358c.html#af1b88433262575214bbc89823736358c">MayaFlux::read_from_audio_input</a></div><div class="ttdeci">void read_from_audio_input(const std::shared_ptr&lt; Buffers::AudioBuffer &gt; &amp;buffer, uint32_t channel)</div><div class="ttdoc">Reads audio data from the default input source into a buffer.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00233">Graph.cpp:233</a></div></div>
</div><!-- fragment --><p><b>When to use manual registration:</b></p>
<ul>
<li>You already have a buffer (don't want to create a new one)</li>
<li>You want to dynamically start/stop listening (e.g., record button)</li>
<li>You need finer control over buffer lifecycle</li>
</ul>
<p><b>Example: Record button</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> recorder = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a9fa2fd237baef3835e5d987262293c2c.html#a9fa2fd237baef3835e5d987262293c2c">AudioBuffer</a>()[0] | Audio;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start recording</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_af1b88433262575214bbc89823736358c.html#af1b88433262575214bbc89823736358c">MayaFlux::read_from_audio_input</a>(recorder, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Stop recording (after some time)</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_aa01b246fe947237c4ecc3b71d3984df9.html#aa01b246fe947237c4ecc3b71d3984df9">MayaFlux::detach_from_audio_input</a>(recorder, 0);</div>
</div><!-- fragment --><p>The buffer continues to exist and process, but stops receiving new input.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md435"></a>
Expansion 3: Input Without Playback</h2>
<details >
<summary >
Click to expand: Silent Capture</summary>
<p></p>
<p>Often you want to <b>capture</b> input without <b>playing</b> it back:</p>
<div class="fragment"><div class="line"><span class="comment">// Create listener but don&#39;t add to output</span></div>
<div class="line"><span class="keyword">auto</span> mic_capture = <a class="code hl_function" href="namespaceMayaFlux_a156aa5a54a2a941e0eb8f9618d601be1.html#a156aa5a54a2a941e0eb8f9618d601be1">MayaFlux::create_input_listener_buffer</a>(0, <span class="keyword">false</span>);  <span class="comment">// false = silent</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Capture to a stream for analysis</span></div>
<div class="line"><span class="keyword">auto</span> stream = std::make_shared&lt;DynamicSoundStream&gt;(48000, 1);</div>
<div class="line"><span class="keyword">auto</span> writer = std::make_shared&lt;SoundStreamWriter&gt;(stream);</div>
<div class="line">mic_capture-&gt;get_processing_chain()-&gt;add_processor(writer);</div>
</div><!-- fragment --><p><b>Result:</b> Microphone data is captured to <code>stream</code>, but you don't hear it.</p>
<p><b>Use cases:</b></p>
<ul>
<li>Recording without monitoring</li>
<li>Voice analysis (pitch detection, speech recognition)</li>
<li>Trigger detection (clap to start/stop)</li>
<li>Level metering / VU display</li>
</ul>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md437"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Real-time vocal effects chain</span></div>
<div class="line"><span class="keyword">auto</span> mic = <a class="code hl_function" href="namespaceMayaFlux_a156aa5a54a2a941e0eb8f9618d601be1.html#a156aa5a54a2a941e0eb8f9618d601be1">MayaFlux::create_input_listener_buffer</a>(0, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> pitch_shift = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> x * 1.5; });  <span class="comment">// Naive pitch shift</span></div>
<div class="line"><span class="keyword">auto</span> reverb = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe.html#ab85cfd01b90a6a4684925d773afaf2fe">FeedbackBuffer</a>(0, 512, 0.3f, 2400);  <span class="comment">// Simple reverb</span></div>
<div class="line"><span class="keyword">auto</span> gate = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::THRESHOLD, 0.05);  <span class="comment">// Noise gate</span></div>
<div class="line"> </div>
<div class="line">MayaFlux::create_processor&lt;PolynomialProcessor&gt;(mic, pitch_shift);</div>
<div class="line">MayaFlux::create_processor&lt;LogicProcessor&gt;(mic, gate);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Record to disk simultaneously</span></div>
<div class="line"><span class="keyword">auto</span> stream = std::make_shared&lt;DynamicSoundStream&gt;(48000, 1);</div>
<div class="line"><span class="keyword">auto</span> writer = std::make_shared&lt;SoundStreamWriter&gt;(stream);</div>
<div class="line">mic-&gt;get_processing_chain()-&gt;add_processor(writer, mic);</div>
<div class="line"><span class="comment">// After session: save &#39;stream&#39; to file</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Voice-triggered synthesis</span></div>
<div class="line"><span class="keyword">auto</span> mic_silent = <a class="code hl_function" href="namespaceMayaFlux_a156aa5a54a2a941e0eb8f9618d601be1.html#a156aa5a54a2a941e0eb8f9618d601be1">MayaFlux::create_input_listener_buffer</a>(0, <span class="keyword">false</span>);</div>
<div class="line"><span class="keyword">auto</span> trigger = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ad172557289ef9c249a3cb0a3935bd1ef.html#ad172557289ef9c249a3cb0a3935bd1ef">Logic</a>(LogicOperator::EDGE);</div>
<div class="line">trigger-&gt;set_edge_detection(EdgeType::RISING, 0.3);</div>
<div class="line"><span class="keyword">auto</span> trigger_proc = MayaFlux::create_processor&lt;LogicProcessor&gt;(mic_silent, trigger);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When trigger fires, start a synthesizer...</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md439"></a>
Tutorial: Buffer Supply (Routing to Multiple Channels)</h2>
<h3><a class="anchor" id="autotoc_md440"></a>
The Pattern</h3>
<p>One buffer, multiple output channels.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> sine = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(440.0);</div>
<div class="line">    <span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, sine)[0] | Audio;  <span class="comment">// Registered to channel 0</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Supply this buffer to channels 1 and 2 as well</span></div>
<div class="line">    <a class="code hl_function" href="namespaceMayaFlux_a85e658c39b619933f0dddf2008b737f9.html#a85e658c39b619933f0dddf2008b737f9">MayaFlux::supply_buffer_to_channels</a>(buffer, {1, 2}, 0.5);  <span class="comment">// 50% mix level</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceMayaFlux_a85e658c39b619933f0dddf2008b737f9_html_a85e658c39b619933f0dddf2008b737f9"><div class="ttname"><a href="namespaceMayaFlux_a85e658c39b619933f0dddf2008b737f9.html#a85e658c39b619933f0dddf2008b737f9">MayaFlux::supply_buffer_to_channels</a></div><div class="ttdeci">void supply_buffer_to_channels(const std::shared_ptr&lt; Buffers::AudioBuffer &gt; &amp;buffer, const std::vector&lt; uint32_t &gt; &amp;channels, double mix)</div><div class="ttdoc">Supplies a buffer to multiple channels with mixing.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00280">Graph.cpp:280</a></div></div>
</div><!-- fragment --><p>Run this. You hear the same 440 Hz sine on <b>all three channels</b> (left, center, right in surround setup).</p>
<p>The buffer processes <b>once</b>, but outputs to <b>three channels</b>.</p>
<h2><a class="anchor" id="autotoc_md441"></a>
Expansion 1: What "Supply" Means</h2>
<details >
<summary >
Click to expand: The Difference Between Registration and Supply</summary>
<p></p>
<p><b>Registration</b> (<code>vega.AudioBuffer()[0] | Audio</code>):</p>
<ul>
<li>Adds buffer as a <b>child</b> of <code>RootAudioBuffer[0]</code></li>
<li>Buffer processes during channel 0's cycle</li>
<li>Output <b>accumulates</b> into channel 0</li>
</ul>
<p><b>Supply</b> (<code>supply_buffer_to_channels</code>):</p>
<ul>
<li>Adds buffer's <b>output</b> to other channels</li>
<li>Buffer still processes in its original channel</li>
<li>Output is <b>copied</b> to supplied channels</li>
</ul>
<p><b>Analogy:</b></p>
<ul>
<li>Registration = "This buffer lives in channel 0"</li>
<li>Supply = "After processing in channel 0, send copies to channels 1 and 2"</li>
</ul>
<p><b>Architecture:</b></p>
<div class="fragment"><div class="line">Buffer processes in channel 0</div>
<div class="line">    ↓</div>
<div class="line">Output goes to RootAudioBuffer[0]</div>
<div class="line">    ↓</div>
<div class="line">MixProcessor copies output to RootAudioBuffer[1]</div>
<div class="line">    ↓</div>
<div class="line">MixProcessor copies output to RootAudioBuffer[2]</div>
</div><!-- fragment --><p><b>Key:</b> The buffer only processes <b>once</b>. Supply is a <b>routing</b> operation, not a duplication of processing.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md442"></a>
Expansion 2: Mix Levels</h2>
<details >
<summary >
Click to expand: Controlling Supply Amplitude</summary>
<p></p>
<p>The <code>mix</code> parameter controls how much of the buffer's output is sent:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(buffer, 1, 1.0);  <span class="comment">// 100% (unity gain)</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(buffer, 2, 0.5);  <span class="comment">// 50% (half amplitude)</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(buffer, 3, 0.1);  <span class="comment">// 10% (quiet)</span></div>
<div class="ttc" id="anamespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84_html_a8f1eb4bef5683897c7977d5d1e0b9d84"><div class="ttname"><a href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a></div><div class="ttdeci">void supply_buffer_to_channel(const std::shared_ptr&lt; Buffers::AudioBuffer &gt; &amp;buffer, uint32_t channel, double mix)</div><div class="ttdoc">Supplies a buffer to a single channel with mixing.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00266">Graph.cpp:266</a></div></div>
</div><!-- fragment --><p><b>Use case: Stereo width control</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> mono_source = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(440.0);</div>
<div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, mono_source)[0] | Audio;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send to left (full) and right (half) for asymmetric stereo</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(buffer, 0, 1.0);  <span class="comment">// Left</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(buffer, 1, 0.5);  <span class="comment">// Right (quieter)</span></div>
</div><!-- fragment --><p><b>Use case: Send effects</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> dry = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, sine)[0] | Audio;  <span class="comment">// Dry signal, channel 0</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send 30% to reverb channel</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(dry, 2, 0.3);  <span class="comment">// Channel 2 = reverb bus</span></div>
</div><!-- fragment --><p>Mix is <b>additive</b>. If channel already has content, supply <b>adds</b> to it.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md443"></a>
Expansion 3: Removing Supply</h2>
<details >
<summary >
Click to expand: Dynamic Routing Changes</summary>
<p></p>
<p>You can remove supply relationships:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, sine)[0] | Audio;</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(buffer, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later: stop sending to channel 1</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_afc136ade4d9c21adf7ee7477021dc972.html#afc136ade4d9c21adf7ee7477021dc972">MayaFlux::remove_supplied_buffer_from_channel</a>(buffer, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or remove from multiple channels at once</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a7be0f5c248f2f766e85ac5034047f589.html#a7be0f5c248f2f766e85ac5034047f589">MayaFlux::remove_supplied_buffer_from_channels</a>(buffer, {1, 2, 3});</div>
<div class="ttc" id="anamespaceMayaFlux_a7be0f5c248f2f766e85ac5034047f589_html_a7be0f5c248f2f766e85ac5034047f589"><div class="ttname"><a href="namespaceMayaFlux_a7be0f5c248f2f766e85ac5034047f589.html#a7be0f5c248f2f766e85ac5034047f589">MayaFlux::remove_supplied_buffer_from_channels</a></div><div class="ttdeci">void remove_supplied_buffer_from_channels(const std::shared_ptr&lt; Buffers::AudioBuffer &gt; &amp;buffer, const std::vector&lt; uint32_t &gt; &amp;channels)</div><div class="ttdoc">Removes a supplied buffer from multiple channels.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00299">Graph.cpp:299</a></div></div>
<div class="ttc" id="anamespaceMayaFlux_afc136ade4d9c21adf7ee7477021dc972_html_afc136ade4d9c21adf7ee7477021dc972"><div class="ttname"><a href="namespaceMayaFlux_afc136ade4d9c21adf7ee7477021dc972.html#afc136ade4d9c21adf7ee7477021dc972">MayaFlux::remove_supplied_buffer_from_channel</a></div><div class="ttdeci">void remove_supplied_buffer_from_channel(const std::shared_ptr&lt; Buffers::AudioBuffer &gt; &amp;buffer, const uint32_t channel)</div><div class="ttdoc">Removes a supplied buffer from multiple channels.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00289">Graph.cpp:289</a></div></div>
</div><!-- fragment --><p><b>Use case: Mute individual sends</b></p>
<ul>
<li>Buffer still processes</li>
<li>Output still goes to its registered channel</li>
<li>Supplied channels no longer receive it</li>
</ul>
<p><b>Use case: Dynamic routing matrices</b></p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (user_pressed_button_A) {</div>
<div class="line">    <a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(buffer, 1);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_function" href="namespaceMayaFlux_afc136ade4d9c21adf7ee7477021dc972.html#afc136ade4d9c21adf7ee7477021dc972">MayaFlux::remove_supplied_buffer_from_channel</a>(buffer, 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p></p>
</details>
<h2><a class="anchor" id="autotoc_md444"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Quad panning (4-channel surround)</span></div>
<div class="line"><span class="keyword">auto</span> source = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(220.0);</div>
<div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, source)[0] | Audio;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Distribute to 4 corners with different levels (panning)</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(buffer, 0, 0.7);  <span class="comment">// Front-left</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(buffer, 1, 0.3);  <span class="comment">// Front-right</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(buffer, 2, 0.2);  <span class="comment">// Rear-left</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(buffer, 3, 0.1);  <span class="comment">// Rear-right</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send effects architecture</span></div>
<div class="line"><span class="keyword">auto</span> guitar = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, source)[0] | Audio;  <span class="comment">// Channel 0 = dry</span></div>
<div class="line"><span class="keyword">auto</span> reverb_bus = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe.html#ab85cfd01b90a6a4684925d773afaf2fe">FeedbackBuffer</a>(1, 512, 0.7f, 4800)[1] | Audio;  <span class="comment">// Channel 1 = reverb</span></div>
<div class="line"><span class="keyword">auto</span> delay_bus = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe.html#ab85cfd01b90a6a4684925d773afaf2fe">FeedbackBuffer</a>(2, 512, 0.6f, 9600)[2] | Audio;   <span class="comment">// Channel 2 = delay</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(guitar, 1, 0.4);  <span class="comment">// 40% to reverb</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(guitar, 2, 0.2);  <span class="comment">// 20% to delay</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Multi-band processing (split frequency ranges across channels)</span></div>
<div class="line"><span class="comment">// Process each band independently, then sum</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md446"></a>
Tutorial: Buffer Cloning</h2>
<h3><a class="anchor" id="autotoc_md447"></a>
The Pattern</h3>
<p>One buffer specification, multiple independent instances.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compose() {</div>
<div class="line">    <span class="keyword">auto</span> sine = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(440.0);</div>
<div class="line">    <span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, sine);  <span class="comment">// Don&#39;t register yet</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Clone to channels 0, 1, 2</span></div>
<div class="line">    <a class="code hl_function" href="namespaceMayaFlux_a8292200a0794717cafb259316c39f8a7.html#a8292200a0794717cafb259316c39f8a7">MayaFlux::clone_buffer_to_channels</a>(buffer, {0, 1, 2});</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceMayaFlux_a8292200a0794717cafb259316c39f8a7_html_a8292200a0794717cafb259316c39f8a7"><div class="ttname"><a href="namespaceMayaFlux_a8292200a0794717cafb259316c39f8a7.html#a8292200a0794717cafb259316c39f8a7">MayaFlux::clone_buffer_to_channels</a></div><div class="ttdeci">std::vector&lt; std::shared_ptr&lt; Buffers::AudioBuffer &gt; &gt; clone_buffer_to_channels(const std::shared_ptr&lt; Buffers::AudioBuffer &gt; &amp;buffer, const std::vector&lt; uint32_t &gt; &amp;channels)</div><div class="ttdoc">Clones a buffer to multiple channels.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8cpp_source.html#l00255">Graph.cpp:255</a></div></div>
</div><!-- fragment --><p>Run this. You hear <b>three independent sine waves</b> on three channels.</p>
<p>Each clone processes **independently**—they don't share data.</p>
<h2><a class="anchor" id="autotoc_md448"></a>
Expansion 1: Clone vs. Supply</h2>
<details >
<summary >
Click to expand: When to Use Each</summary>
<p></p>
<p><b>Supply:</b></p>
<ul>
<li>One buffer processes <b>once</b></li>
<li>Output is <b>copied</b> to multiple channels</li>
<li>Processing cost: <b>1× processing</b></li>
<li>Memory: <b>One buffer</b></li>
<li>Use when: Same signal needs to go to multiple places</li>
</ul>
<p><b>Clone:</b></p>
<ul>
<li>Multiple buffers process <b>independently</b></li>
<li>Each has its own data, state, processing chain</li>
<li>Processing cost: <b>N× processing</b> (N = number of clones)</li>
<li>Memory: <b>N buffers</b></li>
<li>Use when: Similar buffers need independent processing</li>
</ul>
<p><b>Example: Supply use case</b></p>
<div class="fragment"><div class="line"><span class="comment">// One reverb output to stereo speakers</span></div>
<div class="line"><span class="keyword">auto</span> reverb = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe.html#ab85cfd01b90a6a4684925d773afaf2fe">FeedbackBuffer</a>(0, 512, 0.8f, 4800)[0] | Audio;</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8f1eb4bef5683897c7977d5d1e0b9d84.html#a8f1eb4bef5683897c7977d5d1e0b9d84">MayaFlux::supply_buffer_to_channel</a>(reverb, 1);  <span class="comment">// Copy to right channel</span></div>
<div class="line"><span class="comment">// Cost: 1× reverb processing</span></div>
</div><!-- fragment --><p><b>Example: Clone use case</b></p>
<div class="fragment"><div class="line"><span class="comment">// Independent noise generators per channel</span></div>
<div class="line"><span class="keyword">auto</span> noise_template = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">Random</a>(-1.0, 1.0));</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8292200a0794717cafb259316c39f8a7.html#a8292200a0794717cafb259316c39f8a7">MayaFlux::clone_buffer_to_channels</a>(noise_template, {0, 1, 2, 3});</div>
<div class="line"><span class="comment">// Cost: 4× noise processing (each with different random seed/state)</span></div>
<div class="line"><span class="comment">// Result: Decorrelated noise on each channel</span></div>
</div><!-- fragment --><p></p>
</details>
<h2><a class="anchor" id="autotoc_md449"></a>
Expansion 2: Cloning Preserves Structure</h2>
<details >
<summary >
Click to expand: What Gets Cloned</summary>
<p></p>
<p>When you clone a buffer, each clone receives:</p>
<ul>
<li><b>Same buffer type</b> (NodeBuffer, FeedbackBuffer, etc.)</li>
<li><b>Same default processor</b> configuration</li>
<li><b>Same processing chain</b> (all added processors)</li>
<li><b>Independent data</b> (not shared—each clone has its own samples)</li>
<li><b>Independent state</b> (feedback buffers have separate history)</li>
</ul>
<p><b>Example: Clone a processed buffer</b></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sine = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(440.0);</div>
<div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, sine);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add processing before cloning</span></div>
<div class="line"><span class="keyword">auto</span> distortion = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a433b0c2da4871dc08e049d5ac64041b7.html#a433b0c2da4871dc08e049d5ac64041b7">Polynomial</a>([](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> std::tanh(x * 2.0); });</div>
<div class="line">MayaFlux::create_processor&lt;PolynomialProcessor&gt;(buffer, distortion);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now clone</span></div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8292200a0794717cafb259316c39f8a7.html#a8292200a0794717cafb259316c39f8a7">MayaFlux::clone_buffer_to_channels</a>(buffer, {0, 1, 2});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Result: Each channel gets sine → distortion (independently processed)</span></div>
</div><!-- fragment --><p>Each clone has its own instance of the distortion processor. They don't share state.</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md450"></a>
Expansion 3: Post-Clone Modification</h2>
<details >
<summary >
Click to expand: Differentiating Clones After Creation</summary>
<p></p>
<p>After cloning, you can modify individual clones:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(440.0));</div>
<div class="line"><span class="comment">// Store cloned buffers for later reference</span></div>
<div class="line"><span class="keyword">auto</span> cloned_buffers = <a class="code hl_function" href="namespaceMayaFlux_a8292200a0794717cafb259316c39f8a7.html#a8292200a0794717cafb259316c39f8a7">MayaFlux::clone_buffer_to_channels</a>(buffer, { 0, 1, 2 });</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add different processing to each</span></div>
<div class="line">std::vector&lt;double&gt; coeffs_a_2 = { 0.2, 0.3, 0.2 };</div>
<div class="line">std::vector&lt;double&gt; coeffs_b_2 = { 1.0, -0.7 };</div>
<div class="line"><span class="keyword">auto</span> filter1 = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8.html#a4d7d43fd4040c892d45d17d29fbe1de8">IIR</a>(coeffs_a_1, coeffs_b_1);</div>
<div class="line"><span class="keyword">auto</span> filter2 = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8.html#a4d7d43fd4040c892d45d17d29fbe1de8">IIR</a>(coeffs_a_2, coeffs_b_2);</div>
<div class="line"> </div>
<div class="line">MayaFlux::create_processor&lt;FilterProcessor&gt;(cloned_buffers[0], filter1);</div>
<div class="line">MayaFlux::create_processor&lt;FilterProcessor&gt;(cloned_buffers[1], filter2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now channel 0 has one filter, channel 1 has a different filter</span></div>
<div class="ttc" id="aclassMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8_html_a4d7d43fd4040c892d45d17d29fbe1de8"><div class="ttname"><a href="classMayaFlux_1_1Creator_a4d7d43fd4040c892d45d17d29fbe1de8.html#a4d7d43fd4040c892d45d17d29fbe1de8">MayaFlux::Creator::IIR</a></div><div class="ttdeci">auto IIR(Args &amp;&amp;... args) -&gt; CreationHandle&lt; MayaFlux::Nodes::Filters::IIR &gt;</div><div class="ttdef"><b>Definition</b> <a href="Creator_8hpp_source.html#l00190">Creator.hpp:190</a></div></div>
</div><!-- fragment --><p><b>Use case:</b> Stereo decorrelation (same source, slightly different processing per channel)</p>
<p></p>
</details>
<hr  />
<h2><a class="anchor" id="autotoc_md452"></a>
Try It</h2>
<div class="fragment"><div class="line"><span class="comment">// Stereo chorus (cloned with phase offset)</span></div>
<div class="line"><span class="keyword">auto</span> lfo = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_ae9b21dfc8a04dd2826b63cda4dae4687.html#ae9b21dfc8a04dd2826b63cda4dae4687">Sine</a>(0.5);  <span class="comment">// Slow LFO</span></div>
<div class="line"><span class="keyword">auto</span> buffer = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, lfo);</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8292200a0794717cafb259316c39f8a7.html#a8292200a0794717cafb259316c39f8a7">MayaFlux::clone_buffer_to_channels</a>(buffer, {0, 1});</div>
<div class="line"><span class="comment">// Modify one clone to have phase offset (requires accessing clone directly)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Multi-channel granular synthesis</span></div>
<div class="line"><span class="keyword">auto</span> grain_template = vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_aec27c48bde31eca7f7c808b59f300fb7.html#aec27c48bde31eca7f7c808b59f300fb7">NodeBuffer</a>(0, 512, vega.<a class="code hl_function" href="classMayaFlux_1_1Creator_a8a8d81842f8f6d77789cd3cd199c12e7.html#a8a8d81842f8f6d77789cd3cd199c12e7">Random</a>(-0.1, 0.1));</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8292200a0794717cafb259316c39f8a7.html#a8292200a0794717cafb259316c39f8a7">MayaFlux::clone_buffer_to_channels</a>(grain_template, {0, 1, 2, 3, 4, 5, 6, 7});</div>
<div class="line"><span class="comment">// Each channel generates independent grains</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Independent feedback loops per channel</span></div>
<div class="line"><span class="keyword">auto</span> feedback_template = <a class="code hl_variable" href="namespaceMayaFlux_a206db47ce24592b667c583d0047f745b.html#a206db47ce24592b667c583d0047f745b">vega</a>.<a class="code hl_function" href="classMayaFlux_1_1Creator_ab85cfd01b90a6a4684925d773afaf2fe.html#ab85cfd01b90a6a4684925d773afaf2fe">FeedbackBuffer</a>(0, 512, 0.8f, 1000);</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a8292200a0794717cafb259316c39f8a7.html#a8292200a0794717cafb259316c39f8a7">MayaFlux::clone_buffer_to_channels</a>(feedback_template, {0, 1, 2, 3});</div>
<div class="line"><span class="comment">// Excite each with different input → 4 independent resonances</span></div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md454"></a>
Closing: The Routing Ecosystem</h2>
<p>You now understand:</p>
<p><b>Input Capture:</b></p>
<ul>
<li><code>InputAudioBuffer</code>: Hardware input hub</li>
<li><code>InputAccessProcessor</code>: Dispatches to listeners</li>
<li><code>create_input_listener_buffer()</code>: Quick setup</li>
<li><code>read_from_audio_input()</code> / <code>detach_from_audio_input()</code>: Manual control</li>
</ul>
<p><b>Buffer Supply:</b></p>
<ul>
<li><code>supply_buffer_to_channel()</code>: Route one buffer to multiple outputs</li>
<li>Mix levels: Control send amounts</li>
<li>Efficiency: Process once, output many times</li>
<li><code>remove_supplied_buffer_from_channel()</code>: Dynamic routing changes</li>
</ul>
<p><b>Buffer Cloning:</b></p>
<ul>
<li><code>clone_buffer_to_channels()</code>: Create independent copies</li>
<li>Preserves structure: Type, processors, chains</li>
<li>Independent state: Each clone processes separately</li>
<li>Post-clone modification: Differentiate behavior after creation</li>
</ul>
<p><b>Mental Model:</b></p>
<div class="fragment"><div class="line">Input (Microphone)</div>
<div class="line">    ↓</div>
<div class="line">InputAudioBuffer → Listener buffers (capture)</div>
<div class="line">    ↓</div>
<div class="line">Processing chains (transform)</div>
<div class="line">    ↓</div>
<div class="line">Supply (route to multiple channels)</div>
<div class="line">    OR</div>
<div class="line">Clone (create independent instances)</div>
<div class="line">    ↓</div>
<div class="line">RootAudioBuffer (mix per channel)</div>
<div class="line">    ↓</div>
<div class="line">Output (Speakers)</div>
</div><!-- fragment --><p><b>Next:</b> BufferPipeline (declarative multi-stage workflows with temporal control)</p>
<hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
