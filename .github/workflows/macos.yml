name: MayaFlux MacOS CI

on:
  workflow_dispatch:
    inputs:
      run_tests:
        description: "Run tests after build"
        required: false
        default: false
        type: boolean
      skip_build:
        description: "Skip build job and only run release stage"
        required: true
        default: false
        type: boolean
      create_distribution:
        description: "Create MayaFlux distribution package"
        required: false
        default: true
        type: boolean

  # push:
  #   branches: [main]

permissions:
  contents: write

env:
  BUILD_TYPE: Release

jobs:
  determine_version:
    runs-on: ubuntu-latest
    outputs:
      VERSION: ${{ steps.ver.outputs.VERSION }}
    steps:
      - uses: actions/checkout@v4

      - name: Determine version
        id: ver
        run: |
          VERSION=$(grep -Eo 'VERSION [0-9]+\.[0-9]+\.[0-9]+' CMakeLists.txt | awk '{print $2}')
          if [[ "${GITHUB_REF_NAME}" != "main" ]]; then
            VERSION="${VERSION}-dev"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT

  build:
    needs: determine_version
    if: github.event.inputs.skip_build != 'true'
    strategy:
      matrix:
        include:
          - os: macos-14
            name: "macOS 14 System Clang (Minimum)"

    runs-on: ${{ matrix.os }}
    name: ${{ matrix.name }}

    steps:
      - name: Use version
        run: echo "Version is ${{ needs.determine_version.outputs.VERSION }}"

      - name: Install build tools on macOS
        run: brew install md5sha1sum

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check system Clang C++23 support
        shell: bash
        run: |
          echo "=== System Clang Version ==="
          clang++ --version
          echo "=== Testing C++23 standard library support ==="
          cat > test.cpp << 'EOF'
          #include <ranges>
          #include <vector>
          #include <cstddef>
          int main() {
              auto x = 42UZ;  // UZ suffix
              auto v = std::views::iota(0, 5) | std::ranges::to<std::vector>();
              return 0;
          }
          EOF
          clang++ -std=c++2b test.cpp -o test && echo "âœ… C++23 features work" || (echo "âŒ C++23 features failed" && exit 1)

      - name: Setup ccache
        uses: hendrikmuhs/ccache-action@v1.2
        with:
          key: ${{ runner.os }}-build
          max-size: "1G"

      - name: Install Homebrew tools (cached)
        uses: tecolicom/actions-use-homebrew-tools@v1
        with:
          tools: >
            rtaudio
            ffmpeg
            shaderc
            googletest
            pkg-config
            cmake
            eigen
            onedpl
            magic_enum
            fmt
            glfw
            glm
            llvm

      - name: Setup Homebrew Environment
        run: |
          eval "$(/opt/homebrew/bin/brew shellenv)"

          # Reinstall cmake to ensure post install steps are run
          brew reinstall cmake

          # Re-establish all the paths when cache is hit
          for tool in rtaudio ffmpeg shaderc googletest pkg-config eigen onedpl magic_enum fmt glfw glm llvm; do
            if TOOL_PREFIX=$(brew --prefix $tool 2>/dev/null); then
              if [ -d "$TOOL_PREFIX/lib/pkgconfig" ]; then
                export PKG_CONFIG_PATH="$TOOL_PREFIX/lib/pkgconfig:$PKG_CONFIG_PATH"
              fi
              if [ -d "$TOOL_PREFIX/lib/cmake" ]; then
                export CMAKE_PREFIX_PATH="$TOOL_PREFIX/lib/cmake:$CMAKE_PREFIX_PATH"
              fi
              # Special handling for eigen which uses eigen3 name
              if [ "$tool" = "eigen" ] && [ -d "$TOOL_PREFIX/share/eigen3/cmake" ]; then
                export CMAKE_PREFIX_PATH="$TOOL_PREFIX/share/eigen3/cmake:$CMAKE_PREFIX_PATH"
              fi
              # magic_enum also uses non standard pkg-config path
              if [ "$tool" = "magic_enum" ] && [ -d "$TOOL_PREFIX/include" ]; then
                export CPATH="$TOOL_PREFIX/include:$CPATH"
                export PKG_CONFIG_PATH="$TOOL_PREFIX/share/pkgconfig:$PKG_CONFIG_PATH"
                export CMAKE_PREFIX_PATH="$TOOL_PREFIX/share/cmake:$CMAKE_PREFIX_PATH"
              fi
            fi
          done

          # Eigen special handling - it installs to share/eigen3
          EIGEN_PREFIX=$(brew --prefix eigen)
          if [ -d "$EIGEN_PREFIX/share/pkgconfig" ]; then
            export PKG_CONFIG_PATH="$EIGEN_PREFIX/share/pkgconfig:$PKG_CONFIG_PATH"
          fi

          # Export all the paths
          echo "PATH=$PATH" >> $GITHUB_ENV
          echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH" >> $GITHUB_ENV
          echo "CMAKE_PREFIX_PATH=$(brew --prefix):$CMAKE_PREFIX_PATH" >> $GITHUB_ENV
          echo "CMAKE_INCLUDE_PATH=$(brew --prefix)/include" >> $GITHUB_ENV
          echo "CMAKE_LIBRARY_PATH=$(brew --prefix)/lib" >> $GITHUB_ENV

          # LLVM specific (critical for Lila JIT)
          LLVM_PREFIX=$(brew --prefix llvm)
          echo "LLVM_PREFIX=$LLVM_PREFIX" >> $GITHUB_ENV
          echo "PATH=$LLVM_PREFIX/bin:$PATH" >> $GITHUB_ENV
          echo "LLVM_DIR=$LLVM_PREFIX/lib/cmake/llvm" >> $GITHUB_ENV
          echo "Clang_DIR=$LLVM_PREFIX/lib/cmake/clang" >> $GITHUB_ENV

          # Verify the setup worked
          echo "=== Verifying environment ==="
          echo "CMAKE command: $(which cmake)"
          echo "CMAKE_ROOT: $CMAKE_ROOT"
          echo "CMAKE version: $(cmake --version | head -1)"
          echo "=== Verifying pkg-config can find packages ==="
          pkg-config --exists rtaudio && echo "âœ… rtaudio found" || echo "âŒ rtaudio not found"
          pkg-config --exists glfw3 && echo "âœ… glfw3 found" || echo "âŒ glfw3 not found"
          pkg-config --exists eigen3 && echo "âœ… eigen3 found" || echo "âŒ eigen3 not found"
          pkg-config --exists magic_enum && echo "âœ… magic_enum found" || echo "âŒ magic_enum not found"
          pkg-config --exists glm && echo "âœ… glm found" || echo "âŒ glm not found"

      - name: Install Vulkan SDK (LunarG)
        uses: jakoch/install-vulkan-sdk-action@v1
        with:
          cache: true
          install_runtime: true

      - name: Verify Vulkan SDK
        run: |
          echo "VULKAN_SDK=$VULKAN_SDK"

      - name: Install STB headers
        shell: bash
        run: |
          echo "Installing STB headers..."
          STB_INSTALL_DIR="$HOME/Libraries/stb"
          git clone https://github.com/nothings/stb.git "$STB_INSTALL_DIR/stb"
          ls "$STB_INSTALL_DIR"

          echo "STB_ROOT=$STB_INSTALL_DIR" >> $GITHUB_ENV
          echo "CPATH=$STB_INSTALL_DIR:$CPATH" >> $GITHUB_ENV

      - name: Configure CMake
        shell: bash
        run: |
          eval "$(/opt/homebrew/bin/brew shellenv)"

          export CMAKE_PREFIX_PATH="${STB_ROOT}:${CMAKE_PREFIX_PATH}"
          export PKG_CONFIG_PATH="${PKG_CONFIG_PATH}"

          echo "=== Final CMake environment ==="
          echo "CMAKE version: $(cmake --version | head -1)"
          echo "CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH"
          echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH"

          cmake -B build \
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
            -DCMAKE_CXX_STANDARD=23 \
            -DCMAKE_C_COMPILER_LAUNCHER=ccache \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
            -DCMAKE_VERBOSE_MAKEFILE=ON

      - name: Build
        shell: bash
        run: cmake --build build --config ${{ env.BUILD_TYPE }} --parallel $(sysctl -n hw.ncpu)

      # - name: Test (conditional)
      #   if: ${{ inputs.run_tests != false }}
      #   shell: bash
      #   working-directory: build
      #   run: ctest --output-on-failure --parallel 4

      - name: Install to staging directory
        if: ${{ inputs.create_distribution != false }}
        shell: bash
        run: |
          ls
          mkdir -p dist_staging
          cmake --install build --prefix dist_staging
          echo "Installation completed to dist_staging/"

      - name: Verify installation structure
        if: ${{ inputs.create_distribution != false }}
        shell: bash
        run: |
          echo "=== MayaFlux Distribution Structure ==="
          echo "MayaFluxLib (Core Library):"
          find dist_staging/include/MayaFlux -name "*.hpp" | head -5 || echo "No MayaFlux headers found"
          find dist_staging/lib -name "*MayaFlux*" | head -5 || echo "No MayaFlux libraries found"

          echo ""
          echo "Lila (JIT Interface):"
          find dist_staging/include/Lila -name "*.hpp" | head -5 || echo "No Lila headers found"
          find dist_staging/lib -name "*Lila*" | head -5 || echo "No Lila libraries found"

          echo ""
          echo "lila_server (User Executable):"
          find dist_staging/bin -name "*lila_server*" | head -5 || echo "No lila_server found"

          echo ""
          echo "Runtime (JIT Context):"
          find dist_staging/share/lila/runtime -type f | head -5 || echo "No runtime files found"

      - name: Copy distribution files
        shell: bash
        run: |
          cp .github/workflows/distribution/macos/README.md dist_staging/
          cp .github/workflows/distribution/macos/verify_components.sh dist_staging/
          chmod +x dist_staging/verify_components.sh

      - name: Create distribution package
        if: ${{ inputs.create_distribution != false }}
        shell: bash
        run: |
          # Use version from determine_version job
          VERSION="${{ needs.determine_version.outputs.VERSION }}"
          SHORT_SHA=${GITHUB_SHA:0:8}
          OS_NAME="macos-arm64"

          PACKAGE_NAME="MayaFlux-${VERSION}-${OS_NAME}"

          # Create packages
          tar -czf "${PACKAGE_NAME}.tar.gz" -C dist_staging .
          zip -r "${PACKAGE_NAME}.zip" dist_staging/

          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV

      - name: Upload MayaFlux distribution
        if: ${{ inputs.create_distribution != false }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PACKAGE_NAME }}
          path: |
            ${{ env.PACKAGE_NAME }}.tar.gz
            ${{ env.PACKAGE_NAME }}.zip
          retention-days: 30

      - name: Display build summary
        if: ${{ inputs.create_distribution != false }}
        run: |
          echo "=== MayaFlux macOS Build Complete ==="
          echo "ðŸ“¦ Package: ${{ env.PACKAGE_NAME }}"
          echo ""
          echo "Key Configuration:"
          echo "  Platform: ${{ matrix.os }} / ${{ matrix.name }}"
          echo "  Compiler: System Clang (Apple)"
          echo "  C++ Standard: C++23"
          echo "  Build Type: ${{ env.BUILD_TYPE }}"
          echo ""
          echo "Dependencies:"
          echo "  [Tier 1 - Homebrew Packages]"
          echo "  âœ“ LLVM (Lila JIT - Homebrew)"
          echo "  âœ“ Vulkan SDK (GitHub Action)"
          echo "  [Tier 2 - Homebrew Libraries]"
          echo "  âœ“ RtAudio, GLFW, FFmpeg"
          echo "  âœ“ Eigen3, GLM, magic_enum, fmt"
          echo "  [Tier 3 - Header-Only Direct]"
          echo "  âœ“ STB (direct git clone)"
          echo ""
          echo "Distribution Package:"
          echo "  âœ“ ${{ env.PACKAGE_NAME }}.tar.gz"
          echo "  âœ“ ${{ env.PACKAGE_NAME }}.zip"
          echo "  âœ“ Universal macOS ARM64 binaries"
          echo "  âœ“ Ready for standalone deployment"

      - name: Upload build artifacts (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ matrix.os }}
          path: |
            build/CMakeFiles/CMakeOutput.log
            build/CMakeFiles/CMakeError.log
            build/Testing/Temporary/LastTest.log
            build/compile_commands.json

  create_release:
    if: (success() || github.event.inputs.skip_build == 'true') && github.event.inputs.create_distribution != 'false'
    needs: [determine_version, build]
    runs-on: ubuntu-latest
    name: "Create GitHub Release"
    permissions:
      contents: write

    steps:
      - name: Checkout repository (for release template & tag push)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true
          sparse-checkout: .github/workflows/distribution

      - name: Version
        run: echo "Release version = ${{ needs.determine_version.outputs.VERSION }}"

      - name: Download artifacts from this run (if any)
        id: dl_current
        uses: actions/download-artifact@v4
        with:
          path: artifacts
        continue-on-error: true

      - name: Check artifact presence
        id: check_artifacts
        run: |
          if [ -d artifacts ] && [ "$(ls -A artifacts)" ]; then
            echo "found=true" >> $GITHUB_OUTPUT
          else
            echo "found=false" >> $GITHUB_OUTPUT
          fi

      - name: Download artifacts from previous runs
        if: ${{ steps.check_artifacts.outputs.found == 'false' }}
        uses: dawidd6/action-download-artifact@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          workflow: "macos.yml"
          name: "MayaFlux-${{ needs.determine_version.outputs.VERSION }}-macos-arm64"
          path: artifacts
          search_artifacts: true

      - name: Calculate release version and metadata
        id: set_vars
        run: |
          # Find an archive (tar.gz preferred then zip)
          PACKAGE_FILE=$(find artifacts -maxdepth 3 -type f \( -name "MayaFlux*.tar.gz" -o -name "MayaFlux*.zip" \) | head -1)
          if [[ -z "$PACKAGE_FILE" ]]; then
            echo "ERROR: No MayaFlux package found."
            ls -R artifacts || true
            exit 1
          fi

          BASENAME=$(basename "$PACKAGE_FILE")

          # VERSION may be 0.1.0 or 0.1.0-dev
          VERSION=$(echo "$BASENAME" | sed -E 's/^MayaFlux-([0-9]+\.[0-9]+\.[0-9]+(-dev)?)-.*/\1/')
          if [[ -z "$VERSION" ]]; then
            echo "ERROR: Could not parse version from $BASENAME"
            exit 1
          fi

          # CLEAN_VERSION without -dev
          CLEAN_VERSION=$(echo "$VERSION" | sed 's/-dev//')

          # OS name = everything after version, before extension
          OS_NAME=$(echo "$BASENAME" | sed -E 's/^MayaFlux-[0-9]+\.[0-9]+\.[0-9]+(-dev)?-([^.]+)\.(tar\.gz|zip)$/\2/')
          if [[ -z "$OS_NAME" ]]; then
            echo "ERROR: Could not parse OS name from $BASENAME"
            exit 1
          fi

          # dev detection
          if [[ "$VERSION" == *"-dev" ]]; then
            IS_DEV=1
          else
            IS_DEV=0
          fi

          SHORT_SHA=${GITHUB_SHA:0:8}

          echo "PACKAGE_FILE=$PACKAGE_FILE"
          echo "BASENAME=$BASENAME"
          echo "VERSION=$VERSION"
          echo "CLEAN_VERSION=$CLEAN_VERSION"
          echo "OS_NAME=$OS_NAME"
          echo "IS_DEV=$IS_DEV"
          echo "SHORT_SHA=$SHORT_SHA"

          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "CLEAN_VERSION=$CLEAN_VERSION" >> $GITHUB_OUTPUT
          echo "OS_NAME=$OS_NAME" >> $GITHUB_OUTPUT
          echo "IS_DEV=$IS_DEV" >> $GITHUB_OUTPUT
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_OUTPUT

          # Tags we will use
          echo "RELEASE_TAG=v${CLEAN_VERSION}" >> $GITHUB_OUTPUT
          echo "DEV_TAG=v${CLEAN_VERSION}-dev" >> $GITHUB_OUTPUT

      - name: Prepare tag for dev builds (create/update DEV_TAG -> this commit)
        if: steps.set_vars.outputs.IS_DEV == '1'
        run: |
          set -e
          DEV_TAG="${{ steps.set_vars.outputs.DEV_TAG }}"
          echo "Preparing dev tag: $DEV_TAG -> ${GITHUB_SHA}"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"

          # create or move the dev tag to the commit we built
          git tag -f "$DEV_TAG" "${GITHUB_SHA}"
          git push -f origin "$DEV_TAG"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Process unified release template
        id: process_template
        run: |
          MACOS_SECTION=$(cat .github/workflows/distribution/macos/section.md)
          WINDOWS_SECTION=$(cat .github/workflows/distribution/windows/section.md)

          awk -v version="$VERSION" \
              -v commit_sha="$SHORT_SHA" \
              -v repository="${{ github.repository }}" \
              -v os_name="$OS_NAME" \
              -v macos_section="$MACOS_SECTION" \
              -v windows_section="$WINDOWS_SECTION" \
          '
          {
            gsub("{{VERSION}}", version);
            gsub("{{COMMIT_SHA}}", commit_sha);
            gsub("{{REPOSITORY}}", repository);
            gsub("{{OS_NAME}}", os_name);
            gsub("{{MACOS_SECTION}}", macos_section);
            gsub("{{WINDOWS_SECTION}}", windows_section);
            print
          }
          ' .github/workflows/distribution/shared/release_body.md > processed_release_body.md

      - name: Compute release name
        id: namefix
        run: |
          if [[ "${{ steps.set_vars.outputs.IS_DEV }}" == "1" ]]; then
            RELEASE_NAME="MayaFlux ${{ steps.set_vars.outputs.CLEAN_VERSION }}-dev (${{ steps.set_vars.outputs.OS_NAME }})"
          else
            RELEASE_NAME="MayaFlux ${{ steps.set_vars.outputs.CLEAN_VERSION }} (${{ steps.set_vars.outputs.OS_NAME }})"
          fi
          echo "RELEASE_NAME=$RELEASE_NAME"
          echo "RELEASE_NAME=$RELEASE_NAME" >> $GITHUB_OUTPUT

      - name: Create Release and Upload Assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.set_vars.outputs.IS_DEV == '1' && steps.set_vars.outputs.DEV_TAG || steps.set_vars.outputs.RELEASE_TAG }}
          name: ${{ steps.namefix.outputs.RELEASE_NAME }}
          body_path: processed_release_body.md
          prerelease: ${{ steps.set_vars.outputs.IS_DEV == '1' }}
          draft: false
          overwrite: ${{ steps.set_vars.outputs.IS_DEV == '1' }}
          files: artifacts/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
