<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MayaFlux: Advanced System Architecture: Complete Replacement and Custom Implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MayaFlux<span id="projectnumber">&#160;0.2.0</span>
   </div>
   <div id="projectbrief">Digital-First Multimedia Processing Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2Advanced__Context__Control.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Advanced System Architecture: Complete Replacement and Custom Implementation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md139"></a> The previous document <a class="el" href="md_docs_2Domain__and__Control.html">Domain and Control</a> demonstrated <b>true digital-first multimedia coordination</b> where computational domains interact through shared timing references, data transformation pipelines, and temporal coordination mechanisms. Rather than separating audio, visual, and temporal processing into isolated systems, <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> treats them as unified aspects of a single computational-creative expression.</p>
<p>The Engine's default automation provides optimal performance for common workflows, while explicit control mechanisms enable precise customization when specific computational patterns are required. This <b>default automation with expressive override</b> philosophy ensures that creative flow remains uninterrupted while advanced techniques remain accessible when needed.</p>
<p>This document explores replacing Engine defaults with custom managers, handlers, subsystems, backends, and the default Engine itselfâ€”enabling complete architectural customization while maintaining the digital-first computational paradigm.</p>
<hr  />
<p><b>Note</b> Many currently non existent subsystems will me mentioned to showcase possible actions, workflows and overrides. All referenced methods are available in the <code>ISubsystem</code> interface, but the specific concrete class may not be part of the default library.</p>
<hr  />
<hr  />
<p><b>Note</b> This document offers less textural or verbose explanations as most low level c++ code itself contains explanations within its structure and via comments. Textual context is added only where it is necessary to describe intent of operation beyond whats made obvious by the code. As the title suggests, this is an advanced section.</p>
<ul>
<li>Processing Handles: Token-Scoped System Access<ul>
<li>BufferProcessingHandle<ul>
<li>Direct handle creation</li>
</ul>
</li>
<li>NodeProcessingHandle</li>
<li>TaskSchedulerHandle</li>
<li>SubsystemProcessingHandle<ul>
<li>Handle composition and custom contexts</li>
</ul>
</li>
<li>Why Processing Handles Instead of Direct Manager Access?<ul>
<li>Handle Performance Characteristics</li>
</ul>
</li>
</ul>
</li>
<li>SubsystemManager: Computational Domain Orchestration<ul>
<li>Subsystem Registration and Lifecycle<ul>
<li>Cross-Subsystem Data Access Control</li>
<li>Processing Hooks and Custom Integration</li>
<li>Direct SubsystemManager Control</li>
</ul>
</li>
</ul>
</li>
<li>Subsystems: Computational Domain Implementation<ul>
<li>ISubsystem Interface and Implementation Patterns</li>
<li>Specialized Subsystem Examples<ul>
<li>AudioSubsystem</li>
<li>GraphicsSubsystem</li>
<li>Subsystem Communication and Coordination</li>
</ul>
</li>
<li>Direct Subsystem Management</li>
</ul>
</li>
<li>Backends: Hardware and Platform Abstraction<ul>
<li>Audio Backend Architecture<ul>
<li>IAudioBackend Interface</li>
<li>Backend Factory Expansion</li>
</ul>
</li>
<li>Graphics Backend Architecture<ul>
<li>IGraphicsBackend Interface</li>
<li>Custom Rendering Pipeline</li>
</ul>
</li>
<li>Network Backend for Distributed Processing%</li>
</ul>
</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md144"></a>
Processing Handles: Token-Scoped System Access</h1>
<p>Processing handles provide token-scoped access to the core processing systems (Nodes, Buffers, Coroutines), ensuring proper domain isolation and thread safety. Rather than direct access to managers, handles act as computational interfaces that enforce processing boundaries while enabling cross-domain coordination.</p>
<p>Each handle represents a specific computational context defined by processing tokens, providing controlled access to the underlying systems while maintaining the engine's coordination patterns.</p>
<h2><a class="anchor" id="autotoc_md145"></a>
BufferProcessingHandle</h2>
<p>Provides token-scoped access to buffer operations within a specific processing domain:</p>
<div class="fragment"><div class="line"><span class="comment">// Engine-managed buffer handle access</span></div>
<div class="line"><span class="keyword">auto</span> audio_subsystem = get_context()-&gt;<a class="code hl_function" href="classMayaFlux_1_1Core_1_1Engine_a83aa8950ad3b4e75ac761410da96dd39.html#a83aa8950ad3b4e75ac761410da96dd39">get_subsystem_manager</a>()-&gt;get_audio_subsystem();</div>
<div class="line"><span class="keyword">auto</span> buffer_handle = audio_subsystem-&gt;get_processing_context_handle()-&gt;buffers;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Token-scoped buffer operations</span></div>
<div class="line"><span class="keyword">auto</span> audio_buffer = buffer_handle.create_buffer&lt;AudioBuffer&gt;(0, 1024);</div>
<div class="line">buffer_handle.process(512);  <span class="comment">// Process 512 samples for all channels</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Handle respects token boundaries</span></div>
<div class="line"><span class="keyword">auto</span> buffer_data = buffer_handle.get_buffer_data(0);  <span class="comment">// Only AUDIO_BACKEND token buffers</span></div>
<div class="ttc" id="aclassMayaFlux_1_1Core_1_1Engine_a83aa8950ad3b4e75ac761410da96dd39_html_a83aa8950ad3b4e75ac761410da96dd39"><div class="ttname"><a href="classMayaFlux_1_1Core_1_1Engine_a83aa8950ad3b4e75ac761410da96dd39.html#a83aa8950ad3b4e75ac761410da96dd39">MayaFlux::Core::Engine::get_subsystem_manager</a></div><div class="ttdeci">std::shared_ptr&lt; SubsystemManager &gt; get_subsystem_manager()</div><div class="ttdoc">Gets the subsystem manager for advanced component access.</div><div class="ttdef"><b>Definition</b> <a href="Engine_8hpp_source.html#l00296">Engine.hpp:296</a></div></div>
</div><!-- fragment --><p>The handle automatically routes operations through the appropriate token-specific processing paths, ensuring that buffer operations remain within their designated computational domain while enabling optimal performance.</p>
<h3><a class="anchor" id="autotoc_md146"></a>
Direct handle creation</h3>
<p>Handles can be created independently for custom processing scenarios:</p>
<div class="fragment"><div class="line"><span class="comment">// Create custom buffer handle with specific token</span></div>
<div class="line"><span class="keyword">auto</span> custom_handle = BufferProcessingHandle(</div>
<div class="line">    custom_buffer_manager,</div>
<div class="line">    Buffers::ProcessingToken::CUSTOM | Buffers::ProcessingToken::PARALLEL</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use handle for domain-specific operations</span></div>
<div class="line">custom_handle.add_buffer(gpu_accelerated_buffer);</div>
<div class="line">custom_handle.process(1024);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Handle maintains token constraints</span></div>
<div class="line"><span class="keyword">auto</span> gpu_buffer_data = custom_handle.read_channel_data(0);  <span class="comment">// Only GPU_PROCESS token buffers</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md147"></a>
NodeProcessingHandle</h2>
<p>Provides token-scoped access to node graph operations within specific processing domains:</p>
<div class="fragment"><div class="line"><span class="comment">// Subsystem-managed node handle</span></div>
<div class="line"><span class="keyword">auto</span> graphics_subsystem = get_context()-&gt;<a class="code hl_function" href="classMayaFlux_1_1Core_1_1Engine_a83aa8950ad3b4e75ac761410da96dd39.html#a83aa8950ad3b4e75ac761410da96dd39">get_subsystem_manager</a>()-&gt;get_graphics_subsystem();</div>
<div class="line"><span class="keyword">auto</span> node_handle = graphics_subsystem-&gt;get_processing_context_handle()-&gt;nodes;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Token-specific node operations</span></div>
<div class="line"><span class="keyword">auto</span> visual_output = node_handle.process_channel(0, 1024);  <span class="comment">// VISUAL_RATE processing</span></div>
<div class="line"><span class="keyword">auto</span> sample_output = node_handle.process_sample(0);         <span class="comment">// Single sample processing</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Handle coordinates with appropriate token processor</span></div>
<div class="line">node_handle.register_node(visual_processor_node, 0);  <span class="comment">// Register to VISUAL_RATE channel 0</span></div>
</div><!-- fragment --><p>Node handles ensure that processing operations respect the temporal characteristics of their assigned domain while providing unified access patterns across different processing contexts.</p>
<h2><a class="anchor" id="autotoc_md148"></a>
TaskSchedulerHandle</h2>
<p>Provides token-scoped access to coroutine scheduling within specific temporal domains:</p>
<div class="fragment"><div class="line"><span class="comment">// Temporal domain handle access</span></div>
<div class="line"><span class="keyword">auto</span> sync_subsystem = get_engine()-&gt;get_subsystem_manager()-&gt;get_sync_subsystem();</div>
<div class="line"><span class="keyword">auto</span> task_handle = sync_subsystem-&gt;get_processing_context_handle()-&gt;tasks;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Token-specific temporal processing</span></div>
<div class="line">task_handle.process(1024);  <span class="comment">// Process 1024 temporal units for this token</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Handle manages domain-specific scheduling</span></div>
<div class="line"><span class="keyword">auto</span> routine = create_sync_routine();</div>
<div class="line">task_handle.add_task(routine, <span class="stringliteral">&quot;cross_domain_sync&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md149"></a>
SubsystemProcessingHandle</h2>
<p>Combines all three processing handles into a unified computational context for subsystem operations:</p>
<div class="fragment"><div class="line"><span class="comment">// Unified subsystem processing context</span></div>
<div class="line"><span class="keyword">class </span>CustomMultimediaSubsystem : <span class="keyword">public</span> ISubsystem {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    SubsystemProcessingHandle* m_handle;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="main_8cpp_a25a40b6614565f755233080a384c35f1.html#a25a40b6614565f755233080a384c35f1">initialize</a>(SubsystemProcessingHandle&amp; handle)<span class="keyword"> override </span>{</div>
<div class="line">        m_handle = &amp;handle;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Access all processing systems through unified handle</span></div>
<div class="line">        <span class="keyword">auto</span> audio_buffer = m_handle-&gt;buffers.create_buffer&lt;AudioBuffer&gt;(0, 512);</div>
<div class="line">        <span class="keyword">auto</span> visual_node = create_visual_processor();</div>
<div class="line">        m_handle-&gt;nodes.register_node(visual_node, 0);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Coordinate temporal processing</span></div>
<div class="line">        <span class="keyword">auto</span> sync_routine = create_coordination_routine();</div>
<div class="line">        m_handle-&gt;tasks.add_task(sync_routine, <span class="stringliteral">&quot;multimedia_sync&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> process_multimedia_frame() {</div>
<div class="line">        <span class="comment">// Coordinated processing across all domains</span></div>
<div class="line">        m_handle-&gt;buffers.process_all_buffers(512);</div>
<div class="line">        <span class="keyword">auto</span> visual_data = m_handle-&gt;nodes.process_channel(0, 512);</div>
<div class="line">        m_handle-&gt;tasks.process(512);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Cross-domain data coordination</span></div>
<div class="line">        coordinate_audio_visual_data(visual_data);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="amain_8cpp_a25a40b6614565f755233080a384c35f1_html_a25a40b6614565f755233080a384c35f1"><div class="ttname"><a href="main_8cpp_a25a40b6614565f755233080a384c35f1.html#a25a40b6614565f755233080a384c35f1">initialize</a></div><div class="ttdeci">void initialize()</div><div class="ttdef"><b>Definition</b> <a href="main_8cpp_source.html#l00011">main.cpp:11</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md150"></a>
Handle composition and custom contexts</h3>
<p>Processing handles can be composed for specialized computational requirements:</p>
<div class="fragment"><div class="line"><span class="comment">// Custom handle composition for advanced workflows</span></div>
<div class="line"><span class="keyword">auto</span> multimedia_tokens = SubsystemTokens{</div>
<div class="line">    .Buffer = Buffers::ProcessingToken::AUDIO_BACKEND | Buffers::ProcessingToken::GRAPHICS_BACKEND,</div>
<div class="line">    .Node = Nodes::ProcessingToken::AUDIO_RATE | Nodes::ProcessingToken::VISUAL_RATE,</div>
<div class="line">    .Task = Vruta::ProcessingToken::MULTI_RATE</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> multimedia_handle = SubsystemProcessingHandle(</div>
<div class="line">    buffer_manager, node_manager, task_scheduler, multimedia_tokens</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use composed handle for cross-domain operations</span></div>
<div class="line">multimedia_handle.buffers.transfer_data_between_domains(audio_buffer, graphics_buffer);</div>
<div class="line">multimedia_handle.nodes.coordinate_processing_rates(audio_nodes, visual_nodes);</div>
<div class="line">multimedia_handle.tasks.sync_temporal_domains();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md151"></a>
Why Processing Handles Instead of Direct Manager Access?</h2>
<p>Processing handles enforce <b>computational boundaries</b> that prevent:</p>
<ul>
<li>Cross-domain memory corruption</li>
<li>Token privilege escalation</li>
<li>Uncontrolled resource access</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// This enforces token boundaries automatically</span></div>
<div class="line"><span class="keyword">auto</span> buffer_data = buffer_handle.get_buffer_data(0);  <span class="comment">// Only AUDIO_BACKEND token buffers</span></div>
</div><!-- fragment --><p>Direct manager access would require manual boundary checking in every subsystem.</p>
<h3><a class="anchor" id="autotoc_md152"></a>
Handle Performance Characteristics</h3>
<ul>
<li><b>Token validation</b>: O(1) bitfield operations</li>
<li><b>Cross-domain access</b>: Single atomic read with permission check</li>
<li><b>Memory overhead</b>: ~64 bytes per handle (pointer + token state)</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Zero-copy when tokens match</span></div>
<div class="line"><span class="keyword">auto</span> data = handle.get_buffer_data(0);  <span class="comment">// Direct pointer return</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Copy required when crossing domains</span></div>
<div class="line"><span class="keyword">auto</span> cross_data = handle.read_cross_subsystem_buffer(...);  <span class="comment">// Memcpy + validation</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md153"></a>
SubsystemManager: Computational Domain Orchestration</h1>
<p>The SubsystemManager serves as the central coordinator for all computational domains in <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>, managing subsystem lifecycle, processing handle distribution, and cross-domain data access. Rather than a simple container, it acts as a computational orchestrator that ensures proper isolation while enabling coordinated operation across different processing contexts.</p>
<h2><a class="anchor" id="autotoc_md154"></a>
Subsystem Registration and Lifecycle</h2>
<div class="fragment"><div class="line"><span class="comment">// Engine creates SubsystemManager with core processing systems</span></div>
<div class="line"><span class="keyword">auto</span> subsystem_manager = std::make_shared&lt;SubsystemManager&gt;(</div>
<div class="line">    node_graph_manager, buffer_manager, task_scheduler</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Automatic subsystem creation with proper handle assignment</span></div>
<div class="line">subsystem_manager-&gt;create_audio_subsystem(stream_info, AudioBackendType::PORTAUDIO);</div>
<div class="line">subsystem_manager-&gt;create_graphics_subsystem(display_config, GraphicsBackendType::VULKAN);</div>
<div class="line">subsystem_manager-&gt;create_sync_subsystem(sync_config);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Coordinated startup sequence</span></div>
<div class="line">subsystem_manager-&gt;start_all_subsystems();</div>
</div><!-- fragment --><p>The manager automatically creates appropriate processing handles for each subsystem based on their token requirements, ensuring that each computational domain receives properly scoped access to the core processing systems.</p>
<h3><a class="anchor" id="autotoc_md155"></a>
Cross-Subsystem Data Access Control</h3>
<div class="fragment"><div class="line"><span class="comment">// Configure cross-domain data access permissions</span></div>
<div class="line">subsystem_manager-&gt;allow_cross_access(SubsystemType::AUDIO, SubsystemType::GRAPHICS);</div>
<div class="line">subsystem_manager-&gt;allow_cross_access(SubsystemType::GRAPHICS, SubsystemType::AUDIO);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Safe cross-domain data access</span></div>
<div class="line"><span class="keyword">auto</span> spectral_data = subsystem_manager-&gt;read_cross_subsystem_buffer(</div>
<div class="line">    SubsystemType::GRAPHICS,  <span class="comment">// Requesting subsystem</span></div>
<div class="line">    SubsystemType::AUDIO,     <span class="comment">// Target subsystem</span></div>
<div class="line">    0                         <span class="comment">// Channel</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (spectral_data) {</div>
<div class="line">    apply_spectral_visualization(*spectral_data);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Cross-access permissions ensure that data flow between computational domains remains controlled and explicit, preventing unintended interference while enabling intentional coordination.</p>
<h3><a class="anchor" id="autotoc_md156"></a>
Processing Hooks and Custom Integration</h3>
<div class="fragment"><div class="line"><span class="comment">// Register custom processing hooks for specialized workflows</span></div>
<div class="line">subsystem_manager-&gt;register_process_hook(</div>
<div class="line">    SubsystemType::AUDIO,</div>
<div class="line">    <span class="stringliteral">&quot;spectral_analysis&quot;</span>,</div>
<div class="line">    [](SubsystemProcessingHandle&amp; handle) {</div>
<div class="line">        <span class="comment">// Custom pre-processing logic</span></div>
<div class="line">        <span class="keyword">auto</span> audio_data = handle.buffers.get_buffer_data(0);</div>
<div class="line">        perform_spectral_analysis(audio_data);</div>
<div class="line">    },</div>
<div class="line">    HookPosition::PRE_PROCESS</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">subsystem_manager-&gt;register_process_hook(</div>
<div class="line">    SubsystemType::GRAPHICS,</div>
<div class="line">    <span class="stringliteral">&quot;visual_coordination&quot;</span>,</div>
<div class="line">    [](SubsystemProcessingHandle&amp; handle) {</div>
<div class="line">        <span class="comment">// Custom post-processing coordination</span></div>
<div class="line">        coordinate_visual_elements();</div>
<div class="line">        update_display_parameters();</div>
<div class="line">    },</div>
<div class="line">    HookPosition::POST_PROCESS</div>
<div class="line">);</div>
</div><!-- fragment --><p>Processing hooks enable custom integration points without modifying subsystem internals, supporting the <b>expressive override</b> philosophy by allowing precise customization when specific computational patterns are required.</p>
<h3><a class="anchor" id="autotoc_md157"></a>
Direct SubsystemManager Control</h3>
<div class="fragment"><div class="line"><span class="comment">// Custom subsystem manager configuration</span></div>
<div class="line"><span class="keyword">auto</span> custom_manager = std::make_shared&lt;SubsystemManager&gt;(</div>
<div class="line">    custom_node_manager, custom_buffer_manager, custom_scheduler</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Manual subsystem registration with custom tokens</span></div>
<div class="line"><span class="keyword">auto</span> custom_subsystem = std::make_shared&lt;CustomProcessingSubsystem&gt;();</div>
<div class="line">custom_manager-&gt;add_subsystem(SubsystemType::CUSTOM, custom_subsystem);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Direct subsystem access and control</span></div>
<div class="line"><span class="keyword">auto</span> subsystem = custom_manager-&gt;get_subsystem(SubsystemType::CUSTOM);</div>
<div class="line"><span class="keyword">auto</span> processing_handle = subsystem-&gt;get_processing_context_handle();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Manual processing coordination</span></div>
<div class="line">processing_handle-&gt;buffers.process_all_buffers(1024);</div>
<div class="line">processing_handle-&gt;nodes.process_channel(0, 1024);</div>
<div class="line">processing_handle-&gt;tasks.process(1024);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md158"></a>
Subsystems: Computational Domain Implementation</h1>
<p>Subsystems represent complete computational domains that encapsulate specific processing characteristics, resource management, and coordination patterns. Each subsystem implements the <code>ISubsystem</code> interface, defining how it integrates with the broader <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a> processing architecture.</p>
<h2><a class="anchor" id="autotoc_md159"></a>
ISubsystem Interface and Implementation Patterns</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomAudioVisualSubsystem : <span class="keyword">public</span> ISubsystem {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    SubsystemProcessingHandle* m_handle;</div>
<div class="line">    std::atomic&lt;bool&gt; m_running{<span class="keyword">false</span>};</div>
<div class="line">    std::atomic&lt;bool&gt; m_ready{<span class="keyword">false</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Domain-specific processing state</span></div>
<div class="line">    std::unique_ptr&lt;SpectralAnalyzer&gt; m_spectral_analyzer;</div>
<div class="line">    std::unique_ptr&lt;VisualRenderer&gt; m_visual_renderer;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="main_8cpp_a25a40b6614565f755233080a384c35f1.html#a25a40b6614565f755233080a384c35f1">initialize</a>(SubsystemProcessingHandle&amp; handle)<span class="keyword"> override </span>{</div>
<div class="line">        m_handle = &amp;handle;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Initialize domain-specific components</span></div>
<div class="line">        m_spectral_analyzer = std::make_unique&lt;SpectralAnalyzer&gt;();</div>
<div class="line">        m_visual_renderer = std::make_unique&lt;VisualRenderer&gt;();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Set up processing resources</span></div>
<div class="line">        setup_audio_visual_coordination();</div>
<div class="line">        m_ready = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> start()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (!m_ready) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">        m_running = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Start domain-specific processing</span></div>
<div class="line">        m_spectral_analyzer-&gt;start();</div>
<div class="line">        m_visual_renderer-&gt;start();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Register processing callbacks</span></div>
<div class="line">        register_audio_callback();</div>
<div class="line">        register_visual_callback();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    SubsystemTokens get_tokens()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">            .Buffer = Buffers::ProcessingToken::AUDIO_BACKEND |</div>
<div class="line">                     Buffers::ProcessingToken::GRAPHICS_BACKEND,</div>
<div class="line">            .Node = Nodes::ProcessingToken::AUDIO_RATE |</div>
<div class="line">                   Nodes::ProcessingToken::VISUAL_RATE,</div>
<div class="line">            .Task = Vruta::ProcessingToken::MULTI_RATE</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_audio_visual_coordination() {</div>
<div class="line">        <span class="comment">// Create coordination buffers</span></div>
<div class="line">        <span class="keyword">auto</span> audio_buffer = m_handle-&gt;buffers.create_buffer&lt;AudioBuffer&gt;(0, 1024);</div>
<div class="line">        <span class="keyword">auto</span> texture_buffer = m_handle-&gt;buffers.create_buffer&lt;TextureBuffer&gt;(0, 1024);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Set up processing nodes</span></div>
<div class="line">        <span class="keyword">auto</span> fft_node = create_spectral_analyzer_node();</div>
<div class="line">        <span class="keyword">auto</span> visual_node = create_visual_processor_node();</div>
<div class="line"> </div>
<div class="line">        m_handle-&gt;nodes.register_node(fft_node, 0);</div>
<div class="line">        m_handle-&gt;nodes.register_node(visual_node, 1);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Create coordination coroutine</span></div>
<div class="line">        <span class="keyword">auto</span> sync_routine = create_audio_visual_sync_routine();</div>
<div class="line">        m_handle-&gt;tasks.add_task(sync_routine, <span class="stringliteral">&quot;audio_visual_sync&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md160"></a>
Specialized Subsystem Examples</h2>
<h3><a class="anchor" id="autotoc_md161"></a>
AudioSubsystem</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>AudioSubsystem : <span class="keyword">public</span> ISubsystem {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Core::AudioBackendType m_backend_type;</div>
<div class="line">    std::unique_ptr&lt;IAudioBackend&gt; m_backend;</div>
<div class="line">    std::unique_ptr&lt;AudioDevice&gt; m_audio_device;</div>
<div class="line">    std::unique_ptr&lt;AudioStream&gt; m_audio_stream;</div>
<div class="line">    GlobalStreamInfo m_stream_info;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AudioSubsystem(GlobalStreamInfo&amp; stream_info)</div>
<div class="line">        : m_stream_info(stream_info), m_backend_type(stream_info.backend) {</div>
<div class="line">        <span class="comment">// Create appropriate audio backend</span></div>
<div class="line">        m_backend = AudioBackendFactory::create_backend(backend_type);</div>
<div class="line">        m_audio_device = m_backend-&gt;create_device_manager();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="main_8cpp_a25a40b6614565f755233080a384c35f1.html#a25a40b6614565f755233080a384c35f1">initialize</a>(SubsystemProcessingHandle&amp; handle)<span class="keyword"> override </span>{</div>
<div class="line">        m_handle = &amp;handle;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Initialize audio-specific processing</span></div>
<div class="line">        setup_audio_buffers(handle);</div>
<div class="line">        setup_audio_nodes(handle);</div>
<div class="line">        setup_sample_accurate_timing(handle);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Create audio stream</span></div>
<div class="line">        m_audio_stream = m_backend-&gt;create_stream(</div>
<div class="line">            m_audio_device-&gt;get_default_output_device(),</div>
<div class="line">            m_audio_device-&gt;get_default_input_device(),</div>
<div class="line">            m_stream_info,</div>
<div class="line">            <span class="keyword">this</span></div>
<div class="line">        );</div>
<div class="line"> </div>
<div class="line">        m_ready = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    SubsystemTokens get_tokens()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">            .Buffer = Buffers::ProcessingToken::AUDIO_BACKEND,</div>
<div class="line">            .Node = Nodes::ProcessingToken::AUDIO_RATE,</div>
<div class="line">            .Task = Vruta::ProcessingToken::SAMPLE_ACCURATE</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_audio_buffers(SubsystemProcessingHandle&amp; handle) {</div>
<div class="line">        <span class="comment">// Create input/output buffers for hardware interface</span></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t channel = 0; channel &lt; m_stream_info.output.channels; ++channel) {</div>
<div class="line">            <span class="keyword">auto</span> input_buffer = handle.buffers.create_buffer&lt;AudioInputBuffer&gt;(channel, 512);</div>
<div class="line">            <span class="keyword">auto</span> output_buffer = handle.buffers.create_buffer&lt;AudioOutputBuffer&gt;(channel, 512);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md162"></a>
GraphicsSubsystem</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>GraphicsSubsystem : <span class="keyword">public</span> ISubsystem {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Utils::GraphicsBackendType m_backend_type;</div>
<div class="line">    std::unique_ptr&lt;IGraphicsBackend&gt; m_backend;</div>
<div class="line">    std::unique_ptr&lt;VulkanRenderer&gt; m_renderer;</div>
<div class="line">    std::unique_ptr&lt;DisplayManager&gt; m_display_manager;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    GraphicsSubsystem(DisplayConfig&amp; display_config, Utils::GraphicsBackendType backend_type)</div>
<div class="line">        : m_display_config(display_config), m_backend_type(backend_type) {</div>
<div class="line">        <span class="comment">// Create graphics backend (Vulkan, OpenGL, etc.)</span></div>
<div class="line">        m_backend = GraphicsBackendFactory::create_backend(backend_type);</div>
<div class="line">        m_display_manager = m_backend-&gt;create_display_manager();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="main_8cpp_a25a40b6614565f755233080a384c35f1.html#a25a40b6614565f755233080a384c35f1">initialize</a>(SubsystemProcessingHandle&amp; handle)<span class="keyword"> override </span>{</div>
<div class="line">        m_handle = &amp;handle;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Initialize graphics-specific processing</span></div>
<div class="line">        setup_texture_buffers(handle);</div>
<div class="line">        setup_visual_nodes(handle);</div>
<div class="line">        setup_frame_timing(handle);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Create renderer</span></div>
<div class="line">        m_renderer = m_backend-&gt;create_renderer(m_display_config);</div>
<div class="line"> </div>
<div class="line">        m_ready = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    SubsystemTokens get_tokens()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">            .Buffer = Buffers::ProcessingToken::GRAPHICS_BACKEND,</div>
<div class="line">            .Node = Nodes::ProcessingToken::VISUAL_RATE,</div>
<div class="line">            .Task = Vruta::ProcessingToken::FRAME_ACCURATE</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_texture_buffers(SubsystemProcessingHandle&amp; handle) {</div>
<div class="line">        <span class="comment">// Create texture buffers for GPU processing</span></div>
<div class="line">        <span class="keyword">auto</span> color_buffer = handle.buffers.create_buffer&lt;ColorBuffer&gt;(0, 1920*1080);</div>
<div class="line">        <span class="keyword">auto</span> depth_buffer = handle.buffers.create_buffer&lt;DepthBuffer&gt;(0, 1920*1080);</div>
<div class="line">        <span class="keyword">auto</span> compute_buffer = handle.buffers.create_buffer&lt;ComputeBuffer&gt;(0, 1024*1024);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md163"></a>
Subsystem Communication and Coordination</h3>
<div class="fragment"><div class="line"><span class="comment">// Cross-subsystem coordination patterns</span></div>
<div class="line"><span class="keyword">class </span>SynchronizationSubsystem : <span class="keyword">public</span> ISubsystem {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    SubsystemManager* m_manager;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="main_8cpp_a25a40b6614565f755233080a384c35f1.html#a25a40b6614565f755233080a384c35f1">initialize</a>(SubsystemProcessingHandle&amp; handle)<span class="keyword"> override </span>{</div>
<div class="line">        m_handle = &amp;handle;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Set up cross-domain synchronization</span></div>
<div class="line">        setup_audio_visual_sync(handle);</div>
<div class="line">        setup_temporal_coordination(handle);</div>
<div class="line"> </div>
<div class="line">        m_ready = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    SubsystemTokens get_tokens()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> {</div>
<div class="line">            .Buffer = Buffers::ProcessingToken::CUSTOM,</div>
<div class="line">            .Node = Nodes::ProcessingToken::CUSTOM_RATE,</div>
<div class="line">            .Task = Vruta::ProcessingToken::MULTI_RATE</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_audio_visual_sync(SubsystemProcessingHandle&amp; handle) {</div>
<div class="line">        <span class="comment">// Create sync routine that coordinates between domains</span></div>
<div class="line">        <span class="keyword">auto</span> sync_routine = [<span class="keyword">this</span>, &amp;handle](Vruta::TaskScheduler&amp; scheduler) -&gt; Vruta::SoundRoutine {</div>
<div class="line">            <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">                <span class="comment">// Wait for audio frame completion</span></div>
<div class="line">                <span class="keyword">co_await</span> Kriya::ProcessingGate{scheduler,</div>
<div class="line">                    [<span class="keyword">this</span>]() { <span class="keywordflow">return</span> m_manager-&gt;get_audio_subsystem()-&gt;frame_complete(); }};</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Trigger visual frame processing</span></div>
<div class="line">                <span class="keyword">auto</span> visual_subsystem = m_manager-&gt;get_graphics_subsystem();</div>
<div class="line">                visual_subsystem-&gt;trigger_frame_render();</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Coordinate timing for next cycle</span></div>
<div class="line">                <span class="keyword">co_await</span> Kriya::SampleDelay{scheduler.seconds_to_samples(1.0/60.0)};</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        handle.tasks.add_task(sync_routine(scheduler), <span class="stringliteral">&quot;cross_domain_sync&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md164"></a>
Direct Subsystem Management</h2>
<p>Subsystems can operate independently of the SubsystemManager when specific computational patterns require direct control:</p>
<div class="fragment"><div class="line"><span class="comment">// Direct subsystem instantiation and management</span></div>
<div class="line"><span class="keyword">auto</span> custom_subsystem = std::make_shared&lt;CustomProcessingSubsystem&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create custom processing handle</span></div>
<div class="line"><span class="keyword">auto</span> custom_tokens = SubsystemTokens{</div>
<div class="line">    .Buffer = Buffers::ProcessingToken::CUSTOM,</div>
<div class="line">    .Node = Nodes::ProcessingToken::CUSTOM_RATE,</div>
<div class="line">    .Task = Vruta::ProcessingToken::CUSTOM</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> custom_handle = SubsystemProcessingHandle(</div>
<div class="line">    buffer_manager, node_manager, task_scheduler, custom_tokens</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Manual subsystem lifecycle management</span></div>
<div class="line">custom_subsystem-&gt;initialize(custom_handle);</div>
<div class="line">custom_subsystem-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Direct processing control</span></div>
<div class="line"><span class="keyword">auto</span> processing_handle = custom_subsystem-&gt;get_processing_context_handle();</div>
<div class="line"><a class="code hl_function" href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a>(0.02, [=]() {</div>
<div class="line">    processing_handle-&gt;buffers.process_all_buffers(512);</div>
<div class="line">    processing_handle-&gt;nodes.process_channel(0, 512);</div>
<div class="line">    processing_handle-&gt;tasks.process(512);</div>
<div class="line">});</div>
<div class="ttc" id="anamespaceMayaFlux_a0b2f122006fb411804adab9baa87647d_html_a0b2f122006fb411804adab9baa87647d"><div class="ttname"><a href="namespaceMayaFlux_a0b2f122006fb411804adab9baa87647d.html#a0b2f122006fb411804adab9baa87647d">MayaFlux::schedule_metro</a></div><div class="ttdeci">void schedule_metro(double interval_seconds, std::function&lt; void()&gt; callback, std::string name)</div><div class="ttdoc">Creates a metronome task and addes it to the default scheduler list for evaluation.</div><div class="ttdef"><b>Definition</b> <a href="Chronie_8cpp_source.html#l00041">Chronie.cpp:41</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md165"></a>
Backends: Hardware and Platform Abstraction</h1>
<p>Backends provide the abstraction layer between <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>'s computational architecture and platform-specific hardware or software interfaces. Each backend type handles a specific category of external interface: audio hardware, graphics systems, file I/O, networking, etc.</p>
<h2><a class="anchor" id="autotoc_md166"></a>
Audio Backend Architecture</h2>
<p>The audio backend system abstracts different audio APIs (RtAudio, JACK, ASIO, CoreAudio, etc.) behind a unified interface:</p>
<h3><a class="anchor" id="autotoc_md167"></a>
IAudioBackend Interface</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomAudioBackend : <span class="keyword">public</span> IAudioBackend {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;CustomAudioContext&gt; m_context;</div>
<div class="line">    std::unique_ptr&lt;CustomDeviceManager&gt; m_device_manager;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    CustomAudioBackend() {</div>
<div class="line">        m_context = std::make_unique&lt;CustomAudioContext&gt;();</div>
<div class="line">        m_device_manager = std::make_unique&lt;CustomDeviceManager&gt;(m_context.get());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;AudioDevice&gt; create_device_manager()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;CustomAudioDevice&gt;(m_context.get());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;AudioStream&gt; create_stream(</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_device_id,</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> input_device_id,</div>
<div class="line">        <span class="keyword">const</span> GlobalStreamInfo&amp; stream_info,</div>
<div class="line">        <span class="keywordtype">void</span>* user_data)<span class="keyword"> override </span>{</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;CustomAudioStream&gt;(</div>
<div class="line">            m_context.get(), output_device_id, input_device_id, stream_info, user_data</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string get_version_string()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;CustomAudioBackend v1.0.0&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> get_api_type()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(Core::AudioBackendType::CUSTOM);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> cleanup()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (m_context) {</div>
<div class="line">            m_context-&gt;shutdown();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md168"></a>
Backend Factory Expansion</h3>
<div class="fragment"><div class="line"><span class="comment">// Extended AudioBackendFactory for custom backends</span></div>
<div class="line"><span class="keyword">class </span>AudioBackendFactory {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> std::unique_ptr&lt;IAudioBackend&gt; create_backend(Core::AudioBackendType type) {</div>
<div class="line">        <span class="keywordflow">switch</span> (type) {</div>
<div class="line">        <span class="keywordflow">case</span> Core::AudioBackendType::RTAUDIO:</div>
<div class="line">            <span class="keywordflow">return</span> std::make_unique&lt;RtAudioBackend&gt;();</div>
<div class="line">        <span class="keywordflow">case</span> Core::AudioBackendType::JACK:</div>
<div class="line">            <span class="keywordflow">return</span> std::make_unique&lt;JackAudioBackend&gt;();</div>
<div class="line">        <span class="keywordflow">case</span> Core::AudioBackendType::ASIO:</div>
<div class="line">            <span class="keywordflow">return</span> std::make_unique&lt;AsioAudioBackend&gt;();</div>
<div class="line">        <span class="keywordflow">case</span> Core::AudioBackendType::CUSTOM:</div>
<div class="line">            <span class="keywordflow">return</span> std::make_unique&lt;CustomAudioBackend&gt;();</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Unsupported audio backend type&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Register custom backend at runtime</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> register_custom_backend(</div>
<div class="line">        Core::AudioBackendType type,</div>
<div class="line">        std::function&lt;std::unique_ptr&lt;IAudioBackend&gt;()&gt; factory) {</div>
<div class="line"> </div>
<div class="line">        custom_factories[type] = factory;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> std::map&lt;Core::AudioBackendType,</div>
<div class="line">                   std::function&lt;std::unique_ptr&lt;IAudioBackend&gt;()&gt;&gt; custom_factories;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md169"></a>
Graphics Backend Architecture</h2>
<p>Similar to audio backends, graphics backends abstract different rendering APIs:</p>
<h3><a class="anchor" id="autotoc_md170"></a>
IGraphicsBackend Interface</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>VulkanGraphicsBackend : <span class="keyword">public</span> IGraphicsBackend {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;VulkanContext&gt; m_vulkan_context;</div>
<div class="line">    std::unique_ptr&lt;VulkanRenderer&gt; m_renderer;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    VulkanGraphicsBackend() {</div>
<div class="line">        m_vulkan_context = std::make_unique&lt;VulkanContext&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;DisplayManager&gt; create_display_manager()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;VulkanDisplayManager&gt;(m_vulkan_context.get());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;IRenderer&gt; create_renderer(<span class="keyword">const</span> DisplayConfig&amp; config)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;VulkanRenderer&gt;(m_vulkan_context.get(), config);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;ComputeManager&gt; create_compute_manager()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;VulkanComputeManager&gt;(m_vulkan_context.get());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string get_version_string()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Vulkan Backend v1.3.0&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> cleanup()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (m_vulkan_context) {</div>
<div class="line">            m_vulkan_context-&gt;shutdown();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md171"></a>
Custom Rendering Pipeline</h3>
<div class="fragment"><div class="line"><span class="comment">// Custom renderer for specialized visual processing</span></div>
<div class="line"><span class="keyword">class </span>SpectralVisualizationRenderer : <span class="keyword">public</span> IRenderer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;VulkanComputeShader&gt; m_fft_shader;</div>
<div class="line">    std::unique_ptr&lt;VulkanRenderPass&gt; m_spectral_pass;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="main_8cpp_a25a40b6614565f755233080a384c35f1.html#a25a40b6614565f755233080a384c35f1">initialize</a>(<span class="keyword">const</span> DisplayConfig&amp; config)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Set up specialized shaders for spectral visualization</span></div>
<div class="line">        m_fft_shader = create_fft_compute_shader();</div>
<div class="line">        m_spectral_pass = create_spectral_render_pass();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> render_frame(<span class="keyword">const</span> RenderData&amp; data)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Custom rendering pipeline for audio-visual coordination</span></div>
<div class="line">        m_fft_shader-&gt;dispatch(data.audio_buffer);</div>
<div class="line">        m_spectral_pass-&gt;render(data.spectral_data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> coordinate_with_audio(<span class="keyword">const</span> AudioFrameData&amp; audio_data) {</div>
<div class="line">        <span class="comment">// Real-time coordination with audio processing</span></div>
<div class="line">        update_spectral_parameters(audio_data.frequency_data);</div>
<div class="line">        trigger_visual_events(audio_data.onset_detection);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md172"></a>
Network Backend for Distributed Processing</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>NetworkAudioBackend : <span class="keyword">public</span> IAudioBackend {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;NetworkManager&gt; m_network;</div>
<div class="line">    std::unique_ptr&lt;AudioCodec&gt; m_codec;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    NetworkAudioBackend(<span class="keyword">const</span> NetworkConfig&amp; config) {</div>
<div class="line">        m_network = std::make_unique&lt;NetworkManager&gt;(config);</div>
<div class="line">        m_codec = std::make_unique&lt;AudioCodec&gt;(CodecType::OPUS);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;AudioStream&gt; create_stream(</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_device_id,</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> input_device_id,</div>
<div class="line">        <span class="keyword">const</span> GlobalStreamInfo&amp; stream_info,</div>
<div class="line">        <span class="keywordtype">void</span>* user_data)<span class="keyword"> override </span>{</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;NetworkAudioStream&gt;(</div>
<div class="line">            m_network.get(), m_codec.get(), stream_info, user_data</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Network-specific methods</span></div>
<div class="line">    <span class="keywordtype">void</span> connect_to_peer(<span class="keyword">const</span> std::string&amp; address) {</div>
<div class="line">        m_network-&gt;connect(address);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> start_collaboration_session() {</div>
<div class="line">        m_network-&gt;enable_multicast();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<p>This comprehensive architecture enables <b>complete computational paradigm customization</b> while maintaining the digital-first creative philosophy. Every layerâ€”from processing handles through backends to the engine itselfâ€”can be replaced with custom implementations that serve specific creative or technical requirements.</p>
<p>The three-tier architecture (Processing Handles â†’ SubsystemManager â†’ Subsystems) combined with replaceable backends and engine contexts provides <b>ultimate flexibility</b> for specialized computational workflows. Whether implementing quantum-inspired processing, neural adaptation, biomimetic algorithms, or entirely novel paradigms, the architecture supports seamless integration while preserving the unified data transformation approach that defines <a class="el" href="namespaceMayaFlux.html" title="Main namespace for the Maya Flux audio engine.">MayaFlux</a>'s digital-first creative environment.</p>
<p>The <b>expressive override</b> philosophy extends through every architectural level, ensuring that creative expression never encounters artificial limitations while computational precision remains accessible at every scale of interaction. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
